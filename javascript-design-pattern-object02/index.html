<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
<title>【讀書筆記】JavaScript Design Pattern Chapter05 物件建立模式（下） - CodingWife 寇丁人妻日安</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">




<meta name="description" content="JavaScript Design Pattern，第五章物件建立模式。">





<meta name="description" content="JavaScript Design Pattern，第五章物件建立模式。">
<meta name="keywords" content="讀書筆記,JSDP">
<meta property="og:type" content="article">
<meta property="og:title" content="【讀書筆記】JavaScript Design Pattern Chapter05 物件建立模式（下）">
<meta property="og:url" content="http://codingwife.com/javascript-design-pattern-object02/index.html">
<meta property="og:site_name" content="CodingWife 寇丁人妻日安">
<meta property="og:description" content="JavaScript Design Pattern，第五章物件建立模式。">
<meta property="og:locale" content="zh-tw">
<meta property="og:image" content="http://codingwife.com/img/cover/books.jpg">
<meta property="og:updated_time" content="2019-10-24T06:50:39.036Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【讀書筆記】JavaScript Design Pattern Chapter05 物件建立模式（下）">
<meta name="twitter:description" content="JavaScript Design Pattern，第五章物件建立模式。">
<meta name="twitter:image" content="http://codingwife.com/img/cover/books.jpg">





<link rel="icon" href="/images/logo.ico">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto+Sans+TC|Open+Sans&display=swap">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">

<link rel="stylesheet" href="/css/style.css">
<script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"CodingWife 寇丁人妻日安","sameAs":["https://github.com/leiadot","https://facebook.com/CodingwifeHy2","mailto:luv.hsu@gmail.com"],"image":"http://codingwife.com/images/leia.png"},"articleBody":"模組模式提供了結構化，所以被廣泛使用，JavaScript 沒有專給套件用的特殊語法，而模組模式提供工具，來建立自成一體且去耦合的程式碼。\n\n\n模組模式模組模式提供了結構化，所以被廣泛使用，JavaScript 沒有專給套件用的特殊語法，而模組模式提供工具，來建立自成一體且去耦合的程式碼。\n模組模式是數種模式的組合：\n\n命名模式\n立即函式\nPrivate 成員和特權方法\n宣告相依性\n\n第一步：建立命名空間——參考之前使用 namespace() 建立出 utility 模組範例：\nvar MYAPP = namespace('MYAPP.utilities.array');\n第二步：定義模組。此模組使用一個立即執行函式，如果需要隱私權就提供 private 作用域，立即函式會回傳一個物件：真正的模組，有自己 public 介面，給模組的客戶使用：\nMYAPP.utilities.array = (function() &#123;  return &#123;    //...  &#125;;&#125;)();\n接著新增一些 public 方法：\nMYAPP.utilities.array = (function() &#123;  return &#123;    inArray: function(needle, haystack) &#123;      //...    &#125;,    isArray: function(a) &#123;      //...    &#125;,  &#125;;&#125;)();\n揭示模組模式前面介紹隱私權模式的時候已經討論過揭露模式，請參考前面範例，就是讓縮有方法保持 private 而僅在最後建立 public API。\n產生建構式的模組有時候建構式建立物件會更方便，唯一的差別就是包裝模組的立即函式回傳的不是物件，是函式。\nMYAPP.utilities.array = (function() &#123;  // 宣告相依性  var uobj = MYAPP.utilities.object,    ulang = MYAPP.utilities.lang,    // private 屬性跟方法    Constr;  //Public API —— 建構式  Constr = function(o) &#123;    this.elements = this.toArray(o);  &#125;;  //Public API —— 原型  Constr.prototype = &#123;    consturctor: MYAPP.utilities.Array,    version: '2.0',    toArray: function(obj) &#123;      for (var i = 0, a = [], len = obj.length; i &lt; len; i += 1) &#123;        a[i] = obj[i];      &#125;      return a;    &#125;,  &#125;;  // 回傳建構式  // 給新的命名空間  return Constr;&#125;)();var arr = new MYAPP.utilities.Array(obj);\n引進全域物件你可以傳遞參數給包裝模組的建構式，通常是全域變數的參考，甚至是全域物件的本身，引入全域物件可以幫忙加速立即函式的執行，因為引入的變數對函式來說而言已經是區域的。\nMYAPP.utilities.module = (function(app, global) &#123;  //全域物件的參考  //還有全域命名空間的物件  //現在都為區域&#125;)(MYAPP, this);\n沙盒模式沙盒模式提供一個環境讓模組執行，此環境不會影響其他模組或沙盒。\n除此之外，也解決了命名模式的缺點：\n\n命名模式依賴一個全域變數，不可能在同一頁面上讓同一個函式庫或程式的兩種版本同時執行，因為他們都需要全域符號。\n命名空間需要輸入很長的明稱，執行時需要解析多層的命名。\n\n一個全域建構式全域物件的差別：\n\n命名空間模式：全域物件。\n沙盒模式：全域建構式。\n\n利用這個建構式來建立物件，並同時傳遞一個回呼函式，此函式會讓沙盒看起來像一個孤立的環境。此建構式看起來像上個 MYAPP 範例。\nnew Sandbox(function (box))&#123;\t//here is the code&#125;);\n再新增兩個特性：\n\n建立物件時可以使用 new ，也可以不用。\n建構式可以額外接受一些設定值參數，來指定該物件實體所需要的模組名稱。\n\n略過 new 並用虛構的「ajax」、「event」模組來建立：\nSandbox(['ajax', 'event'], function(box) &#123;  //console.log(box);&#125;);\n拆成個別參數傳遞的用法：\nSandbox('ajax', 'dom', function(box) &#123;  //console.log(box);&#125;);\n當沒有傳遞任何模組的時候：\nSandbox('*', function (box) &#123;\t//console.log(box);&#125;Sandbox(function (box) &#123;\t//console.log(box);&#125;);\n巢狀化：\nSandbox('dom', 'dom', function(box) &#123;  Sandbox('ajax', function(box) &#123;    //兩邊的 box 物件是不同的    // ajax  &#125;);  //這邊的程式不會有 ajax 模組&#125;);\n這邊可以看到，程式碼被包進回呼函式來保護全域命名空間。除此之外也可以利用函式也是物件的特性，將資料用靜態屬性的方式儲存在沙盒建構式中。\n新增模組沙盒建構式也是物件，可以新增一個名為 modules 的靜態屬性，這屬性又是另一個物件：\nSandbox.modules = &#123;&#125;;Sandbox.modules.dom = function(box) &#123;  box.getElement = function() &#123;&#125;;  box.getStyle = function() &#123;&#125;;  box.foo = 'bar';&#125;;Sandbox.modules.event = function(box) &#123;  // box.constructor.prototype.m = \"mm\"  // 如有必要則存取沙盒的原型  box.attachEvent = function() &#123;&#125;;  box.dettachEvent = function() &#123;&#125;;&#125;;\n這個範例中加入了 dom 模組與 event 模組，每個函式都接受 box 實體為參數，可能會新增屬性或方法到這個 box 裡面。\n實作建構式沙盒建構式實作範例：\nfunction Sandbox() &#123;  //將參數轉為陣列  var args = Array.prototype.slice.call(argument),    callback = args.pop(),    modules = (atgs[0] &amp;&amp; typeof atgs[0] === \"string\") ? args : args[0],    i;  // 確保函式是建構式呼叫  if (!(this instanceof Sandbox)) &#123;    return new Sandbox(modules, callback);  &#125;  // 依照需要為 this 增加屬性  this.a = 1;  this.b = 2;  // 現在將模組新增至核心的 this 物件  // 沒有指定模組或是用 * 來表示所有模組  if (!module || modules === '*') &#123;    modules = [];    for (i in Sandbox.modules) &#123;      if (Sandbox.modules.hasownProperty(i)) &#123;        modules.push(i);      &#125;      //初始所需要的模組      for (i = 0; i &lt; modules.length; i += 1) &#123;        Sandbox.modules[modules[i]](this);      &#125;      //執行回呼      callback(this);    &#125;  &#125;Sandbox.prototype = &#123;\tname: \"My App\",\tversion: 1.0,\tgetName: function () &#123;\t\treturn this.name;\t&#125;&#125;\n\n檢查 this 是否為 Sandbox 的實體，如果不是，表示呼叫 Sandbox 沒有加 new ，那麼就以建構式的方式再呼叫函式。\n可以在建構式中，新增屬性到 this ，也可以新增屬性到此函式的原型。\nSandbox 中所使用的模組名稱可以用陣列、個別參數、* 字號，或不填入參數。\n你可以只載入最基礎的模組，所需的模組都可以用命名慣例找到外部檔案並載入。\n如果已經知道所需模組便可初始化，意思是呼叫所有模組的實作函式。\n建構式最後一個參數是回呼，會在新被建立好的實體中呼叫，這個回呼就是 Sandbox ，他會取得一個裝好全部所需功能的 box 物件。\n\n靜態成員\n靜態的屬性和方法不會在實體之間有所改變。\n以 class 為基礎的語言，靜態成員使用特別的語法建立並使用，也可以有 private 成員。\n\nPublic 靜態成員JavaScript 沒有特別的語法來表達靜態成員，但你可以使用建構式，並新增屬性到建構式中， 這樣如同擁有 class 語言的語法，因為建構式跟函式一樣都是物件，也可以擁有屬性，新增屬性可參考上一章記憶模式。\n這個例子定義了一個建構式，有一個靜態方法和一個實體方法，靜態方法不需要 Gadget 物件就可以運作，但實體方法則需要。\n//建構式var Gadget = function() &#123;&#125;;//靜態方法Gadget.isShiny = function() &#123;  return 'u bet';&#125;;//加在原型中的一般方法Gadget.prototype.setPrice = function(price) &#123;  this.price = price;&#125;;\n一般的方法要透過實體呼叫，而靜態方法可以直接透過建構式呼叫。\n// 呼叫靜態方法Gadget.isShiny(); // \"u bet\"// 建立一個實體然後呼叫方法var iphone = new Gadget();iphone.setPrice(500);\n無法試圖用靜態方法呼叫實體，也同樣不能用實體呼叫靜態方法。\ntypeof Gadget.setPrice; // \"undefined\"typeof iphone.isShiny; // \"undefined\"\n有時候讓實體也使用靜態方法會很方便，只要在原型新增就可以了，並以此方法作為外觀，指向原本的靜態方法。\nGadget.pototype.isShiny = Gadget.isShiny;iphone.isShiny(); // \"u bet\"\n小心！呼叫 Gadget.isShiny() 會將 this 指向建構式；呼叫 iphone.isShiny(); 而 this 將指向 iphone。\n//建構式var Gadget = function(price) &#123;  this.price = price;&#125;;//一個靜態方法Gadget.isShiny = function() &#123;  //這裡永遠都會運作  var msg = 'u bet';  if (this instanceof Gadget) &#123;    msg += ', it costs $' + this.price + '!';  &#125;  return msg;&#125;;//將一個一般的方法加到原型Gadget.prototype.isShiny = function() &#123;  return Gadget.isShiny.call(this);&#125;;//測試呼叫靜態方法Gadget.isShiny(); // \"u bet\"//測試一個實體，並非用靜態的方式呼叫var a = new Gadget('499.99');a.isShiny(); // \"u bet , it costs $499.99!\"\nPrivate 靜態成員\n由同個建構式建立的物件之間都可分享的成員\n建構式之外不可存取的成員\n\nvar Gadget = (function() &#123;  var counter = 0;  return function() &#123;    console.log((counter += 1));  &#125;;&#125;)(); // 立即執行\n這個範例有一個靜態屬性名稱 counter ，參考前面討論過的 private 屬性，現在也是需要建立一個閉包來裝 private 成員，讓函式執行並回傳一個函式。將回傳的函式指派給變數 Gadget。\nvar g1 = new Gadget(); //logs 1var g2 = new Gadget(); //logs 2var g3 = new Gadget(); //logs 3\n因為每個物件都讓 counter 值增加，這種靜態屬性就成為一個 ID ，這種唯一識別符非常有用。\n接下來承上範例，來試看看特權方法\n//建構式var Gadget = (function() &#123;  //靜態變數/屬性  var counter = 0;  NewGadget;  //新的實作  NewGadget = function() &#123;    counter += 1;  &#125;;  //特權方法  NewGadget.prototype.getLastId = function() &#123;    return counter;  &#125;;  //覆蓋原本的建構式  return NewGadget;&#125;)(); // 立即執行\nvar iphone = new Gadget();iphone.getLastId(); // 1var ipod = new Gadget();ipod.getLastId(); // 2var ipad = new Gadget();ipad.getLastId(); //3\n無論 public 還是 private ，他們可以包含非特定於實體的方法和資料，且不會隨著新的實體又重新建立，這種靜態屬性實作有點類似之後會講的單體建構式。\n物件常數JavaScript 沒有常數，一種常見的變通方法就是使用命名慣例將變數全部大寫。\nMath.PI;Math.SQRT2;Number.MAX_VALUE;\n你也可以為你的常數使用相同命名慣例，並讓他們變成建構式靜態屬性。\nvar Widget = function() &#123;  //實作&#125;;Widget.MAX_HEIGHT = 320;Widget.MAX_WIDTH = 480;\n假設真的需要一個不可變動的值，可以建立 private 屬性，並提供一個 getter 方法且不要有 setter。\n一個泛用的 constant 物件實作，提供這些方法：\nset(name, value);//用來定義一個新的常數isDefined(name);//檢查常數是否存在get(name);//取得常數值\n下面這份實作允許原始型別為常數值，且採用額外的保護措施（hasOwnProperty），以確保是用內建屬性的名稱來宣告屬性，並每個常數名稱再額外隨機產生一個前綴詞。\nvar constant = function() &#123;  var constants = &#123;&#125;,    ownProp = Object.prototype.hasOwnProperty,    allowed = &#123;      string: 1,      number: 1,      boolean: 1,    &#125;,    prefix = (Math.random() + '_').slice(2);  return &#123;    set: function(name, value) &#123;      if (this.isDefined(name)) &#123;        return false;      &#125;      if (!ownProp.call(allowed, typeof value)) &#123;        return false;      &#125;      constants[prefix + name] = value;      return true;    &#125;,    isDefined: function(name) &#123;      return ownProp.call(constants, prefix + name);    &#125;,    get: function(name) &#123;      if (this.isDefined(name)) &#123;        return constants[prefix + name];      &#125;      return null;    &#125;,  &#125;;&#125;;\n實作範例：\n//檢查是否定義過constant.isDefined('maxwidth'); //false//定義常數constant.set('maxwidth', 480); //true//再檢查一次constant.isDefined('maxwidth'); //true//嘗試重新定義constant.set('maxwidth', 320); //false//確認常數值constant.get('maxwidth'); //480\n鏈接模式鏈接模式允許你讓物件一個接著一個呼叫多個方法，既不需要將前一次操作賦值給變數，也不需要將你的呼叫拆成多行。\n當建立的方法不具有意義的回傳值時，你可以讓他們回傳 this ，也就是方法所運作的實體物件，這樣就能讓物件的使用者直接呼叫下一個方法：\nvar obj = &#123;  value: 1,  increment: function() &#123;    this.value += 1;    return this;  &#125;,  add: function(v) &#123;    this.value += v;    return this;  &#125;,  shout: function() &#123;    alert(this.value);  &#125;,&#125;;//鏈接呼叫obj  .increment()  .add(3)  .shout(); //5//逐一呼叫obj.increment();obj.add(3);obj.shout(); //5\n鏈接模式的優點與缺點優點：\n\n少打字\n幫助思考，看能不能建立更小更專門的函式，可提升維護性\n\n缺點：\n\ndebug 困難（又稱為火車事故）\n\nmethod() 方法（sugar method）對於習慣 method() 思考，JS 可能會讓他們困惑，這就是為什麼有些程式員會把 JS 寫得 class-like，提出 method() 的作者（Douglas Crockford）承認這個方法並不是推薦的方式，但可能會在未來某些應用程式中碰到。\n使用建構式就像在 Java 中使用 class ，也讓你可以在建構式本體中，新增實體的屬性到 this，但在 this 上新增方法非常沒效率，會造成每個實體都重新建立，這就是為什麼可重用的方法需要新增在 prototype 上。\n定義一個 class 的方法類似這樣：\nvar Person = function(name) &#123;  this.name = name;&#125;  .method('getName', function() &#123;    return this.name;  &#125;)  .method('setName', function(name) &#123;    this.name = name;    return this;  &#125;);\n注意建構式是如何鏈接 method 的呼叫，這用到鏈接模式，幫助你單一敘述定義整個 class。\n這個 method 接受兩個參數：\n\n新方法的名稱\n新方法的實作\n\n這些鏈接的新方法就會新增到 Person 的 class 裡面，而方法的實作也就是一個函式，內部的 this 會指向 Person 所建立的物件。\n用 Person() 建立新物件：\nvar a = new Person('Adam');a.getName(); //'Adam'a.setName('Eve').getName(); // 'Eve'\n注意範例的 setName，可以這樣是因為 setName 回傳 this。\n最後這是 method 模式實作的方法：\nif (typeof Function.prototype.method !== 'function') &#123;  //先檢查是否已經建立過了  Function.prototype.method = function(name, implementation) &#123;    this.prototype[name] = implementation;    //將 implementation 傳遞的函式加到建構式的原型中，this 會指向建構式    //原型就會被擴充    return this;  &#125;;&#125;\n","dateCreated":"2018-11-07T17:56:10+00:00","dateModified":"2019-10-24T06:50:39+00:00","datePublished":"2018-11-07T17:56:10+00:00","description":"模組模式提供了結構化，所以被廣泛使用，JavaScript 沒有專給套件用的特殊語法，而模組模式提供工具，來建立自成一體且去耦合的程式碼。","headline":"【讀書筆記】JavaScript Design Pattern Chapter05 物件建立模式（下）","image":["/img/cover/books.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"http://codingwife.com/javascript-design-pattern-object02/"},"publisher":{"@type":"Organization","name":"CodingWife 寇丁人妻日安","sameAs":["https://github.com/leiadot","https://facebook.com/CodingwifeHy2","mailto:luv.hsu@gmail.com"],"image":"http://codingwife.com/images/leia.png","logo":{"@type":"ImageObject","url":"http://codingwife.com/images/leia.png"}},"url":"http://codingwife.com/javascript-design-pattern-object02/","keywords":"讀書筆記, JSDP"}</script>
<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>















</head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                    
                    <img src="/images/codingwife.png" alt height="28">
                    
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item " href="/archives">Archives</a>
            
            <a class="navbar-item " href="/categories">Categories</a>
            
            <a class="navbar-item " href="/tags">Tags</a>
            
            <a class="navbar-item " href="/about">About</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" title="搜尋" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" title="GitHub" href="https://github.com/leiadot">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            <a class="navbar-item" title="Facebook" href="https://facebook.com/CodingwifeHy2">
                
                <i class="fab fa-facebook"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

    <section class="section">
    <div class="container">
    <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
        【讀書筆記】JavaScript Design Pattern Chapter05 物件建立模式（下）
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">2018-11-07 17:56
            （<time datetime="2018-11-07T17:56:10.000Z" itemprop="datePublished">11月 7 2018</time>）
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Front-end/">Front-end</a>
        </span>
        
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
        
        <p>模組模式提供了結構化，所以被廣泛使用，JavaScript 沒有專給套件用的特殊語法，而模組模式提供工具，來建立自成一體且去耦合的程式碼。</p>
<a id="more"></a>

<h2 id="模組模式"><a href="#模組模式" class="headerlink" title="模組模式"></a>模組模式</h2><p>模組模式提供了結構化，所以被廣泛使用，JavaScript 沒有專給套件用的特殊語法，而模組模式提供工具，來建立自成一體且去耦合的程式碼。</p>
<p>模組模式是數種模式的組合：</p>
<ul>
<li>命名模式</li>
<li>立即函式</li>
<li>Private 成員和特權方法</li>
<li>宣告相依性</li>
</ul>
<p>第一步：建立命名空間——參考之前使用 namespace() 建立出 utility 模組範例：</p>
<p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> MYAPP = namespace(<span class="hljs-string">'MYAPP.utilities.array'</span>);</span><br></pre></td></tr></table></figure></p>
<p>第二步：定義模組。此模組使用一個立即執行函式，如果需要隱私權就提供 private 作用域，立即函式會回傳一個物件：真正的模組，有自己 public 介面，給模組的客戶使用：</p>
<p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line">MYAPP.utilities.array = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> &#123;</span><br><span class="line">    <span class="hljs-comment">//...</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>接著新增一些 public 方法：</p>
<p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line">MYAPP.utilities.array = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> &#123;</span><br><span class="line">    inArray: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">needle, haystack</span>) </span>&#123;</span><br><span class="line">      <span class="hljs-comment">//...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    isArray: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>) </span>&#123;</span><br><span class="line">      <span class="hljs-comment">//...</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<h3 id="揭示模組模式"><a href="#揭示模組模式" class="headerlink" title="揭示模組模式"></a>揭示模組模式</h3><p>前面介紹隱私權模式的時候已經討論過揭露模式，請參考前面範例，就是讓縮有方法保持 private 而僅在最後建立 public API。</p>
<h3 id="產生建構式的模組"><a href="#產生建構式的模組" class="headerlink" title="產生建構式的模組"></a>產生建構式的模組</h3><p>有時候建構式建立物件會更方便，唯一的差別就是包裝模組的立即函式回傳的不是物件，是函式。</p>
<p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line">MYAPP.utilities.array = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// 宣告相依性</span></span><br><span class="line">  <span class="hljs-keyword">var</span> uobj = MYAPP.utilities.object,</span><br><span class="line">    ulang = MYAPP.utilities.lang,</span><br><span class="line">    <span class="hljs-comment">// private 屬性跟方法</span></span><br><span class="line">    Constr;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">//Public API —— 建構式</span></span><br><span class="line">  Constr = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.elements = <span class="hljs-keyword">this</span>.toArray(o);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="hljs-comment">//Public API —— 原型</span></span><br><span class="line">  Constr.prototype = &#123;</span><br><span class="line">    consturctor: MYAPP.utilities.Array,</span><br><span class="line">    version: <span class="hljs-string">'2.0'</span>,</span><br><span class="line">    toArray: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>&#123;</span><br><span class="line">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, a = [], len = obj.length; i &lt; len; i += <span class="hljs-number">1</span>) &#123;</span><br><span class="line">        a[i] = obj[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="hljs-keyword">return</span> a;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="hljs-comment">// 回傳建構式</span></span><br><span class="line">  <span class="hljs-comment">// 給新的命名空間</span></span><br><span class="line">  <span class="hljs-keyword">return</span> Constr;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> MYAPP.utilities.Array(obj);</span><br></pre></td></tr></table></figure></p>
<h3 id="引進全域物件"><a href="#引進全域物件" class="headerlink" title="引進全域物件"></a>引進全域物件</h3><p>你可以傳遞參數給包裝模組的建構式，通常是全域變數的參考，甚至是全域物件的本身，引入全域物件可以幫忙加速立即函式的執行，因為引入的變數對函式來說而言已經是區域的。</p>
<p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line">MYAPP.utilities.module = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">app, global</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">//全域物件的參考</span></span><br><span class="line">  <span class="hljs-comment">//還有全域命名空間的物件</span></span><br><span class="line">  <span class="hljs-comment">//現在都為區域</span></span><br><span class="line">&#125;)(MYAPP, <span class="hljs-keyword">this</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="沙盒模式"><a href="#沙盒模式" class="headerlink" title="沙盒模式"></a>沙盒模式</h2><p>沙盒模式提供一個環境讓模組執行，此環境不會影響其他模組或沙盒。</p>
<p>除此之外，也解決了命名模式的缺點：</p>
<ul>
<li>命名模式依賴一個全域變數，不可能在同一頁面上讓同一個函式庫或程式的兩種版本同時執行，因為他們都需要全域符號。</li>
<li>命名空間需要輸入很長的明稱，執行時需要解析多層的命名。</li>
</ul>
<h3 id="一個全域建構式"><a href="#一個全域建構式" class="headerlink" title="一個全域建構式"></a>一個全域建構式</h3><p>全域物件的差別：</p>
<ul>
<li>命名空間模式：全域物件。</li>
<li>沙盒模式：全域建構式。</li>
</ul>
<p>利用這個建構式來建立物件，並同時傳遞一個回呼函式，此函式會讓沙盒看起來像一個孤立的環境。此建構式看起來像上個 MYAPP 範例。</p>
<p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">new</span> Sandbox(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">box</span>))</span>&#123;</span><br><span class="line">	<span class="hljs-comment">//here is the code</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>再新增兩個特性：</p>
<ul>
<li>建立物件時可以使用 new ，也可以不用。</li>
<li>建構式可以額外接受一些設定值參數，來指定該物件實體所需要的模組名稱。</li>
</ul>
<p>略過 new 並用虛構的「ajax」、「event」模組來建立：</p>
<p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line">Sandbox([<span class="hljs-string">'ajax'</span>, <span class="hljs-string">'event'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">box</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">//console.log(box);</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>拆成個別參數傳遞的用法：</p>
<p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line">Sandbox(<span class="hljs-string">'ajax'</span>, <span class="hljs-string">'dom'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">box</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">//console.log(box);</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>當沒有傳遞任何模組的時候：</p>
<p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line">Sandbox(<span class="hljs-string">'*'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">box</span>) </span>&#123;</span><br><span class="line">	<span class="hljs-comment">//console.log(box);</span></span><br><span class="line">&#125;</span><br><span class="line">Sandbox(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">box</span>) </span>&#123;</span><br><span class="line">	<span class="hljs-comment">//console.log(box);</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>巢狀化：</p>
<p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line">Sandbox(<span class="hljs-string">'dom'</span>, <span class="hljs-string">'dom'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">box</span>) </span>&#123;</span><br><span class="line">  Sandbox(<span class="hljs-string">'ajax'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">box</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//兩邊的 box 物件是不同的</span></span><br><span class="line">    <span class="hljs-comment">// ajax</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="hljs-comment">//這邊的程式不會有 ajax 模組</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>這邊可以看到，程式碼被包進回呼函式來保護全域命名空間。除此之外也可以利用函式也是物件的特性，將資料用靜態屬性的方式儲存在沙盒建構式中。</p>
<h3 id="新增模組"><a href="#新增模組" class="headerlink" title="新增模組"></a>新增模組</h3><p>沙盒建構式也是物件，可以新增一個名為 modules 的靜態屬性，這屬性又是另一個物件：</p>
<p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line">Sandbox.modules = &#123;&#125;;</span><br><span class="line">Sandbox.modules.dom = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">box</span>) </span>&#123;</span><br><span class="line">  box.getElement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;</span><br><span class="line">  box.getStyle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;</span><br><span class="line">  box.foo = <span class="hljs-string">'bar'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Sandbox.modules.event = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">box</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// box.constructor.prototype.m = "mm"</span></span><br><span class="line">  <span class="hljs-comment">// 如有必要則存取沙盒的原型</span></span><br><span class="line">  box.attachEvent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;</span><br><span class="line">  box.dettachEvent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>這個範例中加入了 dom 模組與 event 模組，每個函式都接受 box 實體為參數，可能會新增屬性或方法到這個 box 裡面。</p>
<h3 id="實作建構式"><a href="#實作建構式" class="headerlink" title="實作建構式"></a>實作建構式</h3><p>沙盒建構式實作範例：</p>
<p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sandbox</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">//將參數轉為陣列</span></span><br><span class="line">  <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(argument),</span><br><span class="line">    callback = args.pop(),</span><br><span class="line">    modules = (atgs[<span class="hljs-number">0</span>] &amp;&amp; <span class="hljs-keyword">typeof</span> atgs[<span class="hljs-number">0</span>] === <span class="hljs-string">"string"</span>) ? args : args[<span class="hljs-number">0</span>],</span><br><span class="line">    i;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 確保函式是建構式呼叫</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Sandbox)) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Sandbox(modules, callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 依照需要為 this 增加屬性</span></span><br><span class="line">  <span class="hljs-keyword">this</span>.a = <span class="hljs-number">1</span>;</span><br><span class="line">  <span class="hljs-keyword">this</span>.b = <span class="hljs-number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 現在將模組新增至核心的 this 物件</span></span><br><span class="line">  <span class="hljs-comment">// 沒有指定模組或是用 * 來表示所有模組</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">module</span> || modules === <span class="hljs-string">'*'</span>) &#123;</span><br><span class="line">    modules = [];</span><br><span class="line">    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> Sandbox.modules) &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span> (Sandbox.modules.hasownProperty(i)) &#123;</span><br><span class="line">        modules.push(i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="hljs-comment">//初始所需要的模組</span></span><br><span class="line">      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; modules.length; i += <span class="hljs-number">1</span>) &#123;</span><br><span class="line">        Sandbox.modules[modules[i]](<span class="hljs-keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="hljs-comment">//執行回呼</span></span><br><span class="line">      callback(<span class="hljs-keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">Sandbox.prototype = &#123;</span><br><span class="line">	name: <span class="hljs-string">"My App"</span>,</span><br><span class="line">	version: <span class="hljs-number">1.0</span>,</span><br><span class="line">	getName: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>檢查 this 是否為 Sandbox 的實體，如果不是，表示呼叫 Sandbox 沒有加 new ，那麼就以建構式的方式再呼叫函式。</li>
<li>可以在建構式中，新增屬性到 this ，也可以新增屬性到此函式的原型。</li>
<li>Sandbox 中所使用的模組名稱可以用陣列、個別參數、* 字號，或不填入參數。</li>
<li>你可以只載入最基礎的模組，所需的模組都可以用命名慣例找到外部檔案並載入。</li>
<li>如果已經知道所需模組便可初始化，意思是呼叫所有模組的實作函式。</li>
<li>建構式最後一個參數是回呼，會在新被建立好的實體中呼叫，這個回呼就是 Sandbox ，他會取得一個裝好全部所需功能的 box 物件。</li>
</ul>
<h2 id="靜態成員"><a href="#靜態成員" class="headerlink" title="靜態成員"></a>靜態成員</h2><ul>
<li>靜態的屬性和方法不會在實體之間有所改變。</li>
<li>以 class 為基礎的語言，靜態成員使用特別的語法建立並使用，也可以有 private 成員。</li>
</ul>
<h3 id="Public-靜態成員"><a href="#Public-靜態成員" class="headerlink" title="Public 靜態成員"></a>Public 靜態成員</h3><p>JavaScript 沒有特別的語法來表達靜態成員，但你可以使用建構式，並新增屬性到建構式中， 這樣如同擁有 class 語言的語法，因為建構式跟函式一樣都是物件，也可以擁有屬性，新增屬性可參考上一章記憶模式。</p>
<p>這個例子定義了一個建構式，有一個靜態方法和一個實體方法，靜態方法不需要 Gadget 物件就可以運作，但實體方法則需要。</p>
<p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">//建構式</span></span><br><span class="line"><span class="hljs-keyword">var</span> Gadget = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="hljs-comment">//靜態方法</span></span><br><span class="line">Gadget.isShiny = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-string">'u bet'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">//加在原型中的一般方法</span></span><br><span class="line">Gadget.prototype.setPrice = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">price</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.price = price;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>一般的方法要透過實體呼叫，而靜態方法可以直接透過建構式呼叫。</p>
<p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 呼叫靜態方法</span></span><br><span class="line">Gadget.isShiny(); <span class="hljs-comment">// "u bet"</span></span><br><span class="line"><span class="hljs-comment">// 建立一個實體然後呼叫方法</span></span><br><span class="line"><span class="hljs-keyword">var</span> iphone = <span class="hljs-keyword">new</span> Gadget();</span><br><span class="line">iphone.setPrice(<span class="hljs-number">500</span>);</span><br></pre></td></tr></table></figure></p>
<p>無法試圖用靜態方法呼叫實體，也同樣不能用實體呼叫靜態方法。</p>
<p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">typeof</span> Gadget.setPrice; <span class="hljs-comment">// "undefined"</span></span><br><span class="line"><span class="hljs-keyword">typeof</span> iphone.isShiny; <span class="hljs-comment">// "undefined"</span></span><br></pre></td></tr></table></figure></p>
<p>有時候讓實體也使用靜態方法會很方便，只要在原型新增就可以了，並以此方法作為外觀，指向原本的靜態方法。</p>
<p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line">Gadget.pototype.isShiny = Gadget.isShiny;</span><br><span class="line">iphone.isShiny(); <span class="hljs-comment">// "u bet"</span></span><br></pre></td></tr></table></figure></p>
<p><strong>小心！呼叫 <code>Gadget.isShiny()</code> 會將 this 指向建構式；呼叫 <code>iphone.isShiny();</code> 而 this 將指向 iphone。</strong></p>
<p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">//建構式</span></span><br><span class="line"><span class="hljs-keyword">var</span> Gadget = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">price</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.price = price;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">//一個靜態方法</span></span><br><span class="line">Gadget.isShiny = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">//這裡永遠都會運作</span></span><br><span class="line">  <span class="hljs-keyword">var</span> msg = <span class="hljs-string">'u bet'</span>;</span><br><span class="line">  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Gadget) &#123;</span><br><span class="line">    msg += <span class="hljs-string">', it costs $'</span> + <span class="hljs-keyword">this</span>.price + <span class="hljs-string">'!'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> msg;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//將一個一般的方法加到原型</span></span><br><span class="line">Gadget.prototype.isShiny = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> Gadget.isShiny.call(<span class="hljs-keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">//測試呼叫靜態方法</span></span><br><span class="line">Gadget.isShiny(); <span class="hljs-comment">// "u bet"</span></span><br><span class="line"><span class="hljs-comment">//測試一個實體，並非用靜態的方式呼叫</span></span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> Gadget(<span class="hljs-string">'499.99'</span>);</span><br><span class="line">a.isShiny(); <span class="hljs-comment">// "u bet , it costs $499.99!"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Private-靜態成員"><a href="#Private-靜態成員" class="headerlink" title="Private 靜態成員"></a>Private 靜態成員</h3><ul>
<li>由同個建構式建立的物件之間都可分享的成員</li>
<li>建構式之外不可存取的成員</li>
</ul>
<p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> Gadget = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log((counter += <span class="hljs-number">1</span>));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(); <span class="hljs-comment">// 立即執行</span></span><br></pre></td></tr></table></figure></p>
<p>這個範例有一個靜態屬性名稱 <code>counter</code> ，參考前面討論過的 private 屬性，現在也是需要建立一個閉包來裝 private 成員，讓函式執行並回傳一個函式。將回傳的函式指派給變數 Gadget。</p>
<p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> g1 = <span class="hljs-keyword">new</span> Gadget(); <span class="hljs-comment">//logs 1</span></span><br><span class="line"><span class="hljs-keyword">var</span> g2 = <span class="hljs-keyword">new</span> Gadget(); <span class="hljs-comment">//logs 2</span></span><br><span class="line"><span class="hljs-keyword">var</span> g3 = <span class="hljs-keyword">new</span> Gadget(); <span class="hljs-comment">//logs 3</span></span><br></pre></td></tr></table></figure></p>
<p>因為每個物件都讓 counter 值增加，這種靜態屬性就成為一個 ID ，這種唯一識別符非常有用。</p>
<p>接下來承上範例，來試看看特權方法</p>
<p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">//建構式</span></span><br><span class="line"><span class="hljs-keyword">var</span> Gadget = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">//靜態變數/屬性</span></span><br><span class="line">  <span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>;</span><br><span class="line">  NewGadget;</span><br><span class="line">  <span class="hljs-comment">//新的實作</span></span><br><span class="line">  NewGadget = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    counter += <span class="hljs-number">1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="hljs-comment">//特權方法</span></span><br><span class="line">  NewGadget.prototype.getLastId = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> counter;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="hljs-comment">//覆蓋原本的建構式</span></span><br><span class="line">  <span class="hljs-keyword">return</span> NewGadget;</span><br><span class="line">&#125;)(); <span class="hljs-comment">// 立即執行</span></span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> iphone = <span class="hljs-keyword">new</span> Gadget();</span><br><span class="line">iphone.getLastId(); <span class="hljs-comment">// 1</span></span><br><span class="line"><span class="hljs-keyword">var</span> ipod = <span class="hljs-keyword">new</span> Gadget();</span><br><span class="line">ipod.getLastId(); <span class="hljs-comment">// 2</span></span><br><span class="line"><span class="hljs-keyword">var</span> ipad = <span class="hljs-keyword">new</span> Gadget();</span><br><span class="line">ipad.getLastId(); <span class="hljs-comment">//3</span></span><br></pre></td></tr></table></figure></p>
<p>無論 public 還是 private ，他們可以包含非特定於實體的方法和資料，且不會隨著新的實體又重新建立，這種靜態屬性實作有點類似之後會講的單體建構式。</p>
<h2 id="物件常數"><a href="#物件常數" class="headerlink" title="物件常數"></a>物件常數</h2><p>JavaScript 沒有常數，一種常見的變通方法就是使用命名慣例將變數全部大寫。</p>
<p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">Math</span>.PI;</span><br><span class="line"><span class="hljs-built_in">Math</span>.SQRT2;</span><br><span class="line"><span class="hljs-built_in">Number</span>.MAX_VALUE;</span><br></pre></td></tr></table></figure></p>
<p>你也可以為你的常數使用相同命名慣例，並讓他們變成建構式靜態屬性。</p>
<p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> Widget = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">//實作</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget.MAX_HEIGHT = <span class="hljs-number">320</span>;</span><br><span class="line">Widget.MAX_WIDTH = <span class="hljs-number">480</span>;</span><br></pre></td></tr></table></figure></p>
<p>假設真的需要一個不可變動的值，可以建立 private 屬性，並提供一個 getter 方法且不要有 setter。</p>
<p>一個泛用的 constant 物件實作，提供這些方法：</p>
<p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">set</span>(name, value);</span><br><span class="line">//用來定義一個新的常數</span><br><span class="line">isDefined(name);</span><br><span class="line">//檢查常數是否存在</span><br><span class="line"><span class="hljs-keyword">get</span>(name);</span><br><span class="line">//取得常數值</span><br></pre></td></tr></table></figure></p>
<p>下面這份實作允許原始型別為常數值，且採用額外的保護措施（hasOwnProperty），以確保是用內建屬性的名稱來宣告屬性，並每個常數名稱再額外隨機產生一個前綴詞。</p>
<p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> constant = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> constants = &#123;&#125;,</span><br><span class="line">    ownProp = <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty,</span><br><span class="line">    allowed = &#123;</span><br><span class="line">      string: <span class="hljs-number">1</span>,</span><br><span class="line">      number: <span class="hljs-number">1</span>,</span><br><span class="line">      boolean: <span class="hljs-number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    prefix = (<span class="hljs-built_in">Math</span>.random() + <span class="hljs-string">'_'</span>).slice(<span class="hljs-number">2</span>);</span><br><span class="line">  <span class="hljs-keyword">return</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">set</span>: function(name, value) &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isDefined(name)) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="hljs-keyword">if</span> (!ownProp.call(allowed, <span class="hljs-keyword">typeof</span> value)) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      constants[prefix + name] = value;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    isDefined: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>&#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> ownProp.call(constants, prefix + name);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="hljs-keyword">get</span>: function(name) &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isDefined(name)) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> constants[prefix + name];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>實作範例：</p>
<p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">//檢查是否定義過</span></span><br><span class="line">constant.isDefined(<span class="hljs-string">'maxwidth'</span>); <span class="hljs-comment">//false</span></span><br><span class="line"><span class="hljs-comment">//定義常數</span></span><br><span class="line">constant.set(<span class="hljs-string">'maxwidth'</span>, <span class="hljs-number">480</span>); <span class="hljs-comment">//true</span></span><br><span class="line"><span class="hljs-comment">//再檢查一次</span></span><br><span class="line">constant.isDefined(<span class="hljs-string">'maxwidth'</span>); <span class="hljs-comment">//true</span></span><br><span class="line"><span class="hljs-comment">//嘗試重新定義</span></span><br><span class="line">constant.set(<span class="hljs-string">'maxwidth'</span>, <span class="hljs-number">320</span>); <span class="hljs-comment">//false</span></span><br><span class="line"><span class="hljs-comment">//確認常數值</span></span><br><span class="line">constant.get(<span class="hljs-string">'maxwidth'</span>); <span class="hljs-comment">//480</span></span><br></pre></td></tr></table></figure></p>
<h2 id="鏈接模式"><a href="#鏈接模式" class="headerlink" title="鏈接模式"></a>鏈接模式</h2><p>鏈接模式允許你讓物件一個接著一個呼叫多個方法，既不需要將前一次操作賦值給變數，也不需要將你的呼叫拆成多行。</p>
<p>當建立的方法不具有意義的回傳值時，你可以讓他們回傳 this ，也就是方法所運作的實體物件，這樣就能讓物件的使用者直接呼叫下一個方法：</p>
<p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> obj = &#123;</span><br><span class="line">  value: <span class="hljs-number">1</span>,</span><br><span class="line">  increment: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.value += <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  add: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.value += v;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  shout: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="hljs-keyword">this</span>.value);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">//鏈接呼叫</span></span><br><span class="line">obj</span><br><span class="line">  .increment()</span><br><span class="line">  .add(<span class="hljs-number">3</span>)</span><br><span class="line">  .shout(); <span class="hljs-comment">//5</span></span><br><span class="line"><span class="hljs-comment">//逐一呼叫</span></span><br><span class="line">obj.increment();</span><br><span class="line">obj.add(<span class="hljs-number">3</span>);</span><br><span class="line">obj.shout(); <span class="hljs-comment">//5</span></span><br></pre></td></tr></table></figure></p>
<h3 id="鏈接模式的優點與缺點"><a href="#鏈接模式的優點與缺點" class="headerlink" title="鏈接模式的優點與缺點"></a>鏈接模式的優點與缺點</h3><p>優點：</p>
<ul>
<li>少打字</li>
<li>幫助思考，看能不能建立更小更專門的函式，可提升維護性</li>
</ul>
<p>缺點：</p>
<ul>
<li>debug 困難（又稱為火車事故）</li>
</ul>
<h2 id="method-方法（sugar-method）"><a href="#method-方法（sugar-method）" class="headerlink" title="method() 方法（sugar method）"></a>method() 方法（sugar method）</h2><p>對於習慣 method() 思考，JS 可能會讓他們困惑，這就是為什麼有些程式員會把 JS 寫得 class-like，提出 method() 的作者（Douglas Crockford）承認這個方法並不是推薦的方式，但可能會在未來某些應用程式中碰到。</p>
<p>使用建構式就像在 Java 中使用 class ，也讓你可以在建構式本體中，新增實體的屬性到 this，但在 this 上新增方法非常沒效率，會造成每個實體都重新建立，這就是為什麼可重用的方法需要新增在 prototype 上。</p>
<p>定義一個 class 的方法類似這樣：</p>
<p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> Person = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">  .method(<span class="hljs-string">'getName'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;</span><br><span class="line">  &#125;)</span><br><span class="line">  .method(<span class="hljs-string">'setName'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p>
<p><strong>注意建構式是如何鏈接 <code>method</code> 的呼叫，這用到鏈接模式，幫助你單一敘述定義整個 class。</strong></p>
<p>這個 method 接受兩個參數：</p>
<ul>
<li>新方法的名稱</li>
<li>新方法的實作</li>
</ul>
<p>這些鏈接的新方法就會新增到 Person 的 class 裡面，而方法的實作也就是一個函式，內部的 this 會指向 Person 所建立的物件。</p>
<p>用 Person() 建立新物件：</p>
<p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'Adam'</span>);</span><br><span class="line">a.getName(); <span class="hljs-comment">//'Adam'</span></span><br><span class="line">a.setName(<span class="hljs-string">'Eve'</span>).getName(); <span class="hljs-comment">// 'Eve'</span></span><br></pre></td></tr></table></figure></p>
<p>注意範例的 setName，可以這樣是因為 setName 回傳 this。</p>
<p>最後這是 method 模式實作的方法：</p>
<p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Function</span>.prototype.method !== <span class="hljs-string">'function'</span>) &#123;</span><br><span class="line">  <span class="hljs-comment">//先檢查是否已經建立過了</span></span><br><span class="line">  <span class="hljs-built_in">Function</span>.prototype.method = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, implementation</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.prototype[name] = implementation;</span><br><span class="line">    <span class="hljs-comment">//將 implementation 傳遞的函式加到建構式的原型中，this 會指向建構式</span></span><br><span class="line">    <span class="hljs-comment">//原型就會被擴充</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        
    </div>
    
    <div class="columns is-variable is-1 is-multiline is-mobile">
        
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/讀書筆記/">#讀書筆記</a></span>
        
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/JSDP/">#JSDP</a></span>
        
    </div>
    
    
    <div class="columns is-mobile is-multiline article-nav">
        <span class="column is-12-mobile is-half-desktop  article-nav-prev">
            
            <a href="/javascript-design-pattern-multiplexing01/">【讀書筆記】JavaScript Design Pattern Chapter06 程式碼重用模式（上）</a>
            
        </span>
        <span class="column is-12-mobile is-half-desktop  article-nav-next">
            
            <a href="/javascript-design-pattern-object01/">【讀書筆記】JavaScript Design Pattern Chapter05 物件建立模式（上）</a>
            
        </span>
    </div>
    
</article>


<div class="sharebox">
    
<div class="sharethis-inline-share-buttons"></div>
<script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5d9b1ebc2b036a0011ed0d83&amp;product=inline-share-buttons" async="async"></script>

</div>



<div class="comments">
    <h3 class="title is-4">評論</h3>
    
<div id="comment-container"></div>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
	var gitment = new Gitment({
		id: 'javascript-design-pattern-object02/',
		owner: 'leiadot',
		repo: 'leiadot.github.io',
		oauth: {
			client_id: '51ce642a9a95d7ccdf4d',
			client_secret: '6bf1657de06ee2fbaf452b4752567ab313277f50',
		},
	})
	gitment.render('comment-container')
</script>

</div>

    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2019 [object Object]&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" title="GitHub" href="https://github.com/ppoffice/leiadot">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("zh-CN");
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
</script>

    
    
    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
    <style>
        .hljs {
            position: relative;
        }

        .hljs .clipboard-btn {
            float: right;
            color: #9a9a9a;
            background: none;
            border: none;
            cursor: pointer;
        }

        .hljs .clipboard-btn:hover {
          color: #8a8a8a;
        }

        .hljs > .clipboard-btn {
            display: none;
            position: absolute;
            right: 4px;
            top: 4px;
        }

        .hljs:hover > .clipboard-btn {
            display: inline;
        }

        .hljs > figcaption > .clipboard-btn {
            margin-right: 4px;
        }
    </style>
    <script>
      $(document).ready(function () {
        $('figure.hljs').each(function(i, figure) {
          var codeId = 'code-' + i;
          var code = figure.querySelector('.code');
          var copyButton = $('<button>Copy <i class="far fa-clipboard"></i></button>');
          code.id = codeId;
          copyButton.addClass('clipboard-btn');
          copyButton.attr('data-clipboard-target-id', codeId);

          var figcaption = figure.querySelector('figcaption');

          if (figcaption) {
            figcaption.append(copyButton[0]);
          } else {
            figure.prepend(copyButton[0]);
          }
        })

        var clipboard = new ClipboardJS('.clipboard-btn', {
          target: function(trigger) {
            return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
          }
        });
        clipboard.on('success', function(e) {
          e.clearSelection();
        })
      })
    </script>

    
    

    


<script src="/js/script.js"></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="站內搜尋">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '頁面',
                CATEGORIES: '分類',
                TAGS: '標籤',
                UNTITLED: '(無標題)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js"></script>
    
</body>
</html>