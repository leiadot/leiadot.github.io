---
title: 【讀書筆記】圖解 HTTP Chapter 02 簡單的 HTTP 協議
date: 2018-10-20 08:12:21
tags:
  - 圖解 HTTP
  - Http
categories: 前端讀書筆記
urlname: graphic-http-chapter02
description: 了解簡單的 HTTP 協議的特性，HTTP 協議用於客戶端和伺服端之間的通訊並通過請求和回應的交換達成通訊。
photos:
  - '/img/cover/http.png'
---

<!--more-->

## HTTP 協議用於客戶端和伺服端之間的通訊

請求訪問文字或圖像等資料一端稱為客戶端；提供資料的一端稱為伺服器端。

## 通過請求和回應的交換達成通訊

請求必定為客戶端發出，最後伺服器端回應資料，換言之，請求一定是客戶端率先發起，在那之前伺服器端不會有動作。

請求訊息的構成：

- 請求方法：訪問伺服器的類型
- 請求 URI 字串：請求訪問的相關資料
- HTTP/1.1：客戶端使用的 HTTP 協議。
- 請求 header
- 請求 body

伺服器端的回應：

- 協議版本
- HTTP 狀態碼
- 狀態碼原因
- 回應 header
- 回應 body

## HTTP 是無狀態協議

HTTP 是無狀態協議，意思就是 HTTP 本身對於不對請求和回應的狀態做保留，也不做持久連接。

使用 HTTP 協議，每次有新的請求發送，就會有對應的回應，這樣是為了能更快速大量的處理資料，但如今也遇到了問題，假設我們在一個購物網站登入，我們會希望他在這個網站的其他頁面也保持登錄的狀態，因此引入了 Cookie 的技術。

## 請求 URI 定位資源

當客戶端使用 URI 發送請求，HTTP 也將請求的 URI 放入請求訊息中。
如果不是特別請求一個特定的資料，可以用 \* 來替代請求 URI 。

## 告知伺服器意圖的 HTTP 方法

HTTP / 1.1 可使用的方法：
GET：獲取資料。請求展示指定資源，僅有請求資源。
POST：提交指定資源實體，通常會改變伺服器的狀態或副作用。
PUT：傳輸文件，文件存在請求訊息的 Body 中，傳送到指定的 URI 的位置。
DELETE：刪除文件，請求 URI 刪除特定的資源。
HEAD：與 GET 相同，但不回傳訊息 Body 的部分。
OPTION：查詢該 URI 支援的資料溝通方法。
TRACE：指定資源標明的伺服器之間，執行迴路返回測試。

發送請求時：會在 `Max-Forwards` 填入數值，每經過一個代理伺服器數值就`-1`，而剛好到 `0` 的時候就停止傳輸，最後接收到請求的伺服器就回傳 `200` 的 http code。
CONNECT：會利用請求資源與代理伺服器啟動一個雙向通訊。

## 使用方法下達命令

客戶端向 URI 發送請求，採用稱為方法的命令。

## 持久連接節省通訊量

在 HTTP 協議的初始版本中，每進行一次通訊就要斷開一次 TCP 連接，當時都是容量小的資料，但如今的狀況，這樣做十分消耗通訊成本。

### 持久連接

為了解決上述問題，HTTP / 1.1 和部分 HTTP / 1.0 想出了持久連接（HTTP persistent connection）的辦法，只要任何一端沒有提出要斷開連接，就保持 TCP 狀態。

如此減少了 TCP 重複建立和斷開的成本，減輕伺服器端的負擔，頁面的顯示也更加快速。

### 管線化

以前的技術是每發出一個請求，需要接受到回應後，才能進行下一個請求，而管線化是將多個 HTTP 請求整批送出的技術，而在傳送過程中不需先等待伺服端的回應，可以在等待的過程中發出下一個請求。

## 使用 Cookie 的狀態管理

在提到 HTTP 是無狀態協議的時候有講到 Cookie ，Cookie 就是在請求和回應的訊息中寫入 Cookie 的訊息來控制客戶端的狀態。

1. 客戶端請求
2. 伺服端會在發送回應訊息中 Header 的 `Set-Cookie` 欄位填入 Cookie 的訊息通知客戶端保存 Cookie 值。
3. 客戶端再發送請求的時候會自動在請求訊息中的 Header 加入 Cookie 值。
4. 伺服端發現客戶端送來的 Cookie 值，比對伺服器的紀錄，最後得到之前的狀態紀錄。

> 資料來源：《圖解 HTTP》 上野宣 人民郵電出版社
> 筆記純屬推廣及分享，如有侵權，請告知。
> Please advise to remove immediately if any infringement caused.
