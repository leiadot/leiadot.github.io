{"pages":[{"title":"","text":"","link":"/archives/index.html"},{"title":"關於日安","text":"","link":"/404/index.html"},{"title":"關於日安","text":"","link":"/about/index.html"},{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"Repository","text":"","link":"/repository/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"【CSS】nth-child 與 nth-of-type","text":"早上聽到旁邊的同學在討論這個問題，有時候會遇到使用nth-child沒反應的狀況，如今是該釐清的時候了。 &lt;div class=\"container\"&gt; &lt;h2&gt;Hello&lt;/h2&gt; &lt;ul class=\"ul01\"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"ul02\"&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt; &lt;span&gt;span1&lt;/span&gt; &lt;span&gt;span2&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; .container ul:nth-child(2) &#123; background-color: red;&#125; 現在有一段程式碼，原本我預期的狀況ul02會吃到底色，因為我選擇的是container下第二個ul，但吃到底色的ul01。為什麼呢？因為nth-child在數 DOM 元素的時候不看 tag ，意思就是他在數元素的時候不會幫你過濾元素 type 。 假設我們將 CSS 選擇器更改為 .container ul:nth-child(1)，會發現沒有元素吃到 CSS，因為他選擇的是container下的第一個元素，而且必須為ul。換句話說在container下的第一個元素如果不是ul，他就不會吃到 CSS， 在container下第一個元素是h2，所以他不會吃到 CSS ，如果你希望選擇container下第一個ul，必須使用.container ul:nth-of-type(1)。 對於後代選擇器使用nth-child也有一個很特殊的發現，如果選擇器更改為.container :nth-child(2)或.container *:nth-child(2)，你會發現從container開始各階層下的第二個元素都會被選擇到。如果更改為.container *:nth-of-type(2)，各元素類型的第二個選擇器會被選擇到。 這邊要注意的是，of-type選擇器會以元素類型做區隔，而nth-child會計算到所有元素。","link":"/css-child-of-type/"},{"title":"【CSS】如何使用阿里巴巴圖標庫","text":"阿里巴巴是中國境內最大的圖標庫，裡面有各式各樣的圖示可以使用，這邊簡單教授以 CSS 的方法使用。 當某天 fontawesome GG 時，我們還有 iconfontType: CSS 進入 Iconfont 登入，選擇喜歡的 icon 放進購物車，匯集完之後，可以選擇加入項目，匯集到資料夾中。 進到進到項目中，可以看到下面的圖示。 點擊下載至本地會有一個 zip 檔案。 嵌入字體檔，並以 Unicode 方式引入定義 font-facefont-family: 'iconfont';src: url('iconfont.eot');src: url('iconfont.eot?#iefix') format('embedded-opentype'), url('iconfont.woff2') format('woff2'), url('iconfont.woff') format('woff'), url('iconfont.ttf') format('truetype'), url('iconfont.svg#iconfont') format('svg');&#125; 使用定義的 iconfont.iconfont &#123; font-family: 'iconfont' !important; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125; 使用 Unicode&lt;span class=\"iconfont\"&gt;&amp;#x33;&lt;/span&gt; 嵌入 CSS，並以 class 方式引入引入 CSS&lt;link rel=\"stylesheet\" href=\"./iconfont.css\" /&gt; 使用&lt;span class=\"iconfont icon-xxx\"&gt;&lt;/span&gt; 引入 JS ，使用 Symbol （SVG 的集合）引入 JS&lt;script src=\"./iconfont.js\"&gt;&lt;/script&gt; 使用通用的 CSS.icon &#123; width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden;&#125; 使用 SVG&lt;svg class=\"icon\" aria-hidden=\"true\"&gt; &lt;use xlink:href=\"#icon-xxx\"&gt;&lt;/use&gt;&lt;/svg&gt; 如何引進 Vue第一種的形式是 unicode，複雜的編碼對於前端來說，我個人覺得沒有比較方便， 第三種是用 js 的方法引入 svg，因為解壓縮的資料夾中其實有 svg 檔，這個方法我覺得也不好，所以這邊教授用 class 的方式引入。 在 public/index.html 引入，vue-cli 3 中的 webpack 會解析 &lt;%= BASE_URL %&gt; 把 iconfont.css 的檔案也放在 public 資料夾底下。 &lt;link rel=\"stylesheet\" href=\"&lt;%= BASE_URL %&gt;iconfont.css\" /&gt;","link":"/how-to-use-iconfont/"},{"title":"【Hexo】使用 Travis CI 自動佈署 Blog","text":"這兩天忙著處理 Travis CI ，終於有點心得，來簡單分享不加密自動佈署，以及使用 ssh 的方法。 Travis CI 自動化執行Travis CI 就是一種代理媽媽（？）的概念，他可以代替你在 terminal 的行為，在網路上看到一些分享文章都會要你裝 ruby ，但假設你不加密可以省略這個步驟，因為我們只是一般的部落格，所以我們這邊選擇不加密的方式。 那我們開始吧。 一、新建 repository ，並分支。首先要先新建一個 repository ，一般來說 master 放 source code 是比較好的，但是因為我的 repository name 是 user.github.io 格式，所以 github page 只能是 master，因此我把 source code 放 branch ，產出的文章放 master 。 二、申請 token在 Github 裡面，進入到Settings。 選擇Developer Settings。 選擇Personal access tokens再選擇右邊的Generate new token。 命名，依照你的需要選擇權限。我自己權限是只選擇第一個repo，當然你也可以全部選起來。 接著 Github 就會產生一組編碼，這個編碼只會出現一次，請務必保存。 三、設定 Travis CIGithub 帳號授權連結申請後。 點進 Travis CI 的Profile。 把你需要自動化的 repository 打開，在點進旁邊的零件圖示。 這是放置 Travis CI 環境變數的地方。新增一個GH_TOKEN，值為剛剛 Github 給的編碼，新增一個GH_REF，值為 git repository 的位置，像是我部落格的位置是github.com/leiadot/leiadot.github.io.git。 四、新增 .travis.yml 在.git的同層新增.travis.yml，如果你的 hexo 沒有指定package.json，要將# before_install的註解打開，否則 Travis CI 無法執行 hexo 的 command line ，檔案內容如下。 ymllanguage: node_js #選擇語言node_js: stable #選擇版本# before_install: # - npm install -g hexo-cliinstall: - npm install #安裝npmscript: #要執行的程式 - hexo clean # 清除 - hexo generate # 生成after_success: #執行完成後的 git push - cd ./public - git init - git config user.name &quot;你的user帳號&quot; - git config user.email &quot;你的email&quot; - git add . - git commit -m &quot;Update by travis ci&quot; - git push --force --quiet &quot;https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;&quot; master:masterbranches: #分支 only: - source 回到 Travis CI 查看是否執行完成。 SSH key 設定要 Travis CI 觸發，必須 branch 要有動作，為了節省打帳號密碼的上傳時間，在這邊簡單介紹 ssh key 設定。 $ ssh-keygen -t rsa -C &quot;user@gmail.com&quot; 在 Terminal 上，輸入新建 ssh key 指令。 Generating public/private rsa key pair.Enter file in which to save the key (/home/user/.ssh/id_rsa): 輸入 ssh key 檔案存放位置，一般預設在~/.ssh資料夾裡面，這邊我輸入/home/user/.ssh/id_rsa。 Enter passphrase (empty for no passphrase):Enter same passphrase again: 都按Enter跳過 Your identification has been saved in /home/user/.ssh/id_rsa.Your public key has been saved in /home/user/.ssh/id_rsa.pub. ssh key 檔案產生完成。 cd ~/.sshcat id_rsa.pub 到 ssh key 資料夾位置，下cat指令得到 key 碼，在 github 上新增 ssh key 之後。 ssh -v git@github.com 輸入測試 command line。 The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 得到訊息，輸入yes。 Hi username! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 授權成功 $ git remote set-url origin git@github.com:user/repo.git 如果已經 clone 過，只要再掛載這串指令就好。","link":"/travis-ci-deploy/"},{"title":"【Github】不開 branch 使用 github page","text":"突然發現一個可以不用開 branch ，但也能使用 github page 的方法，因為最近都在研究 Vue ，所以以 Vue 的專案來做講解。 假設我們現在已經把專案完成了，現在要用 webpack 來產出檔案，在那之前我們先改一下 webpack 的設定。 如果你的專案是使用vue cli 2.9的版本，那你在config/index.js下更改就可以了，其他專案就在 webpack build 的設定下更改就好。 module.exports = &#123; build: &#123; // Template for index.html index: path.resolve(__dirname, '../docs/index.html'), // Paths assetsRoot: path.resolve(__dirname, '../docs'), assetsSubDirectory: 'static', assetsPublicPath: './', &#125;,&#125;; 把dist更改為docs，把assetsPublicPath的設定更改為./。 如此一來產出的資料夾就為docs，assetsPublicPath正常來說應該更改成/就可以，可是在 webpack 產出的index.html會有錯誤，index.html引用的路徑會變為/static/..，index.html會無法正確讀取到檔案，再來就是在 repo settings 的 github pages 更改為master branch / docs folder 就可以了。","link":"/github-doc/"},{"title":"【JS】Debounce and Throttle","text":"* @param delay &#123;Number&#125; 延遲時間，單位毫秒** @return &#123;Function&#125; return 一個去彈跳的函數*/function debounce(fn, delay) &#123; var timer // 接收一個 setTimeout 的 return 值 // 返回一个函数，这个函数会在一个时间区间结束后的 delay 毫秒时执行 fn 函数 return function (arguments) &#123; var context = this // window var args = arguments // event // 每次这个返回的函数被调用，就清除定时器，以保证不执行 fn clearTimeout(timer) // 清空 setTimeout // 当返回的函数被最后一次调用后（也就是用户停止了某个连续的操作）， // 再过 delay 毫秒就执行 fn timer = setTimeout(function () &#123; fn.apply(context, args) //指向初始環境（如果為 window 呼叫，把 function 的指向再轉回 window） &#125;, delay) &#125;&#125; /** * * @param fn &#123;Function&#125; 實際執行的函式 * @param delay &#123;Number&#125; 執行間隔 * * @return &#123;Function&#125; return 的節流函數 */function throttle(fn, threshhold) &#123; // 记录上次执行的时间 var last; // 定时器 var timer; // 默认间隔为 250ms threshhold || (threshhold = 250); // 返回的函数，每过 threshhold 毫秒就执行一次 fn 函数 return function() &#123; // 保存函数调用时的上下文和参数，传递给 fn var context = this; var args = arguments; var now = +new Date(); // 如果距离上次执行 fn 函数的时间小于 threshhold，那么就放弃 // 执行 fn，并重新计时 if (last &amp;&amp; now &lt; last + threshhold) &#123; clearTimeout(timer); // 保证在当前时间区间结束后，再执行一次 fn timer = setTimeout(function() &#123; last = now; fn.apply(context, args); &#125;, threshhold); // 在时间区间的最开始和到达指定间隔的时候执行一次 fn &#125; else &#123; last = now; fn.apply(context, args); &#125; &#125;;&#125;","link":"/javascript-debounce-throttle/"},{"title":"【JS】事件循環 Event-loop","text":"javascript 身為一個單線程語言，我們必須了解他在運行事件的方法是如何，才能避免一些值在錯誤的時機出現。 程式碼擷取自 Philip Roberts: What the heck is the event loop anyway? 在了解事件循環前，必須先瞭解幾個專有名詞。 單線程 single threaded意味同一時間，只能做一件事。在 javascript 裡面，則是會依據順序堆疊（stack）執行，而且一次只能執行一段程式碼。 stack 堆疊執行堆疊，javascript 為單線程，因此在進入函式中執行程式碼，該函式會被加在堆疊最上方，直到函式執行完成後被抽離堆疊，下方程式碼為堆疊範例。 function multiply(a, b) &#123; return a * b;&#125;function square(n) &#123; return multiply(n, n);&#125;function printSquare(n) &#123; let squared = square(n); console.log(squared);&#125;printSquare(4); 無窮迴圈如果執行無窮迴圈，堆疊會不斷增加到瀏覽器出現錯誤為止。 function foo() &#123; return foo();&#125;foo(); Blocking 阻塞當瀏覽器進行同步請求，在等待期間的狀態，就稱為 blocking，blocking 狀態會使瀏覽器形成假死狀態，所有動作無法運行，因此為了避免 blocking 的狀況，所以一般使用非同步請求，關於同步與非同步，請看此 。 console.log('hi');$.get('url', function cb(data) &#123; console.log(data);&#125;);console.log('JSConfEU'); task queue 任務佇列在取得 web api 的結果後，瀏覽器會將回呼函式推進一個等待的地方，就是任務佇列（task queue ）。等瀏覽器執行完 stack 的程式，便會開始讀取任務佇列的回呼函式，讀取完成之後便會開始執行，再讀取下一個回呼。 非同步的事件循環其實重點在任務佇列的部分已經說完了，就是瀏覽器必須等主任務（stack）執行完後，再開始讀取任務佇列並執行回呼函式，稱為事件循環。 範例一：執行順序為 h1 → setTimeout（非同步） → JSConfEU → thereconsole.log('hi');setTimeout(function() &#123; console.log('there');&#125;, 5000);console.log('JSConfEU'); 範例二：執行順序為setTimeout（非同步） → 接回結果，放入佇列 →setTimeout（非同步） → 接回結果，放入佇列 →setTimeout（非同步） → 接回結果，放入佇列 →setTimeout（非同步） → 接回結果，放入佇列 → 讀取timeout();，執行 →console.log(&#39;hi&#39;)，讀取timeout();，執行 →console.log(&#39;hi&#39;)，讀取timeout();，執行 →console.log(&#39;hi&#39;)，讀取timeout();，執行 →console.log(&#39;hi&#39;)，結束。 setTimeout(function timeout() &#123; console.log('hi');&#125;, 1000);setTimeout(function timeout() &#123; console.log('hi');&#125;, 1000);setTimeout(function timeout() &#123; console.log('hi');&#125;, 1000);setTimeout(function timeout() &#123; console.log('hi');&#125;, 1000); 其他可以參考講者寫的一個事件循環模擬器。","link":"/javascript-event-loop/"},{"title":"【JS】Functional Programming","text":"Functional Programming 是一種程式設計範例，但把函式本身上升到一等公民的位置，就像是物件導向編程（Object-oriented Programming）一樣，是一種寫程式的方法。 什麼是 Functional ProgrammingFunctional Programming 是一種程式設計範例，但把函式本身上升到一等公民的位置，就像是物件導向編程（Object-oriented Programming）一樣，是一種寫程式的方法。 Expression, no Statement 概念：僅有表達式，沒有陳述式。 表達式：一個運算過程，一定有回傳值。 陳述式：表現某個行為，例如：賦值給變數。 First Class Function 一級函式：函式可以被賦值給變數。1234const greet = function(msg) &#123; console.log(`Hello $&#123;msg&#125;`);&#125;;greet('Semlinker'); // Output: 'Hello Semlinker' 函式可以當參數被傳遞。1234567const logger = function(msg) &#123; console.log(`Hello $&#123;msg&#125;`);&#125;;const greet = function(msg, print) &#123; print(msg);&#125;;greet('Semlinker', logger); 函式可以當作回傳值。1234567const a = function(a) &#123; return function(b) &#123; return a + b; &#125;;&#125;;const add5 = a(5);add5(10); // Output: 15 Pure Function 純函數 概念：給這個函式相同的輸入值，無論這個函數在哪個時間、哪個地點，得到都會是同一個結果，並且沒有副作用。 123456789101112// impurevar minimum = 21;var checkAge = function(age) &#123; return age &gt;= minimum;&#125;;// purevar checkAge = function(age) &#123; var minimum = 21; return age &gt;= minimum;&#125;; Side Effect 副作用 概念：與函式外部環境相互作用的都是副作用。 副作用可能包含以下（但不僅僅只有以下）： 更改檔案系統 在資料庫寫入紀錄 發送一個 http 請求 可變資料 印出至畫面 / log 取得使用者輸入 DOM 查詢 存取系統狀態 immutable 不可變性概念：建立某個變數之後就不能再更改其值。 12var statement = 'I am an immutable value';var otherStr = statement.slice(8, 17); 我們可以說 statement 是 immutable，因為他的變形是由 otherStr 儲存。 Partial Application 部分應用概念：提供部分參數給其函式應用 一般函式：123456789function map(list, unaryFn) &#123; return [].map.call(list, unaryFn);&#125;function square(n) &#123; return n * n;&#125;map([2, 3, 5], square); // =&gt; [4, 9, 25] map：接受一組陣列跟函式 square：接受一個數值 實作部分應用123function mapWith(list, unaryFn) &#123; return map(list, unaryFn);&#125; 接著把二元函式變成疊層的一元函式： 12345function mapWith(unaryFn) &#123; return function(list) &#123; return map(list, unaryFn); &#125;;&#125; 所以當我們把參數傳進去： 12345mapWith(square)([2, 3, 5]); // =&gt; [4, 9, 25]var squareAll = mapWith(square);squareAll([2, 3, 5]); // =&gt; [4, 9, 25]squareAll([1, 4, 7, 6]); // =&gt; [1, 16, 49, 36] 如此可以減少傳遞 square 函式，隨時抽取變換陣列。 Curry 柯里化概念：只傳遞一個參數給函式並呼叫，回傳另一個函式來處理剩下的參數。 1234567var add = x =&gt; y =&gt; x + y;var add2 = add(2);var add200 = add(200);add2(2); // =&gt;4add200(50); // =&gt;250 Compose 組合函式概念：將兩個簡短的函式，當作堆樂高一樣組成一個比較複雜的函式。 12345678var add10 = value =&gt; value + 10;var mult5 = value =&gt; value * 5;//兩個簡短的函式var mult5AfterAdd10 = value =&gt; 5 * (value + 10);//重寫一個新的var mult5AfterAdd10 = value =&gt; mult5(add10(value));//但我們不想寫新的，所以把它組合起來。 1234567891011121314151617var compose = function(f, g) &#123; return function(x) &#123; return f(g(x)); &#125;;&#125;;//或者var compose = (f, g) =&gt; x =&gt; f(g(x));var add1 = x =&gt; x + 1;var mul5 = x =&gt; x * 5;compose( mul5, add1,)(2);// =&gt;15 Point Free概念：減少不必要的命名變數。 12345678910111213//這不 Piont freevar f = str =&gt; str.toUpperCase().split(' ');var toUpperCase = word =&gt; word.toUpperCase();var split = x =&gt; str =&gt; str.split(x);var f = compose( split(' '), toUpperCase,);f('abcd efgh');// =&gt;[\"ABCD\", \"EFGH\"] High-order function 高階函式要點 高階函式一定是一級函式 以一個函式當參數傳遞 同時回傳一個函式當作是回傳值 12345678910function makeAdder(constantValue) &#123; return function adder(value) &#123; return constantValue + value; &#125;;&#125;var add10 = makeAdder(10);console.log(add10(20)); // prints 30console.log(add10(30)); // prints 40console.log(add10(40)); // prints 50 參考資料30 天精通 RxJS (02)： Functional Programming 基本觀念 &gt; 想学函数式编程？ - 收藏集 - 掘金 &gt; JS 函数式编程指南 &gt; JavaScript 函数式编程（一） &gt; SegmentFault 技术周刊 Vol.16 - 浅入浅出 JavaScript 函数式编程 &gt; 函数式编程中局部应用（Partial Application）和局部套用（Currying）的区别","link":"/javascript-functional-programming/"},{"title":"【JS】原型繼承 Prototype","text":"當我們每次在 console 會看到 javascript 物件底下有個 __proto__，那到底是什麼呢？ 先淺談一下建構式這是一個點的建構式，有 x、y 的座標，以及一個 position 的 function，我們用建構式先建立兩個 instance。 function Point() &#123; this.x = 100; this.y = 99; this.position = function() &#123; console.log(this.x, this.y); &#125;;&#125;const redPoint = new Point();const bluePoint = new Point(); 接下來我們來對其中一個物件做改變。 redPoint.x++;console.log(redPoint);// Point &#123;x: 101, y: 99, position: ƒ&#125;console.log(bluePoint);// Point &#123;x: 100, y: 99, position: ƒ&#125; 從上述可以證實兩個物件是獨立的，互不影響，因此他們的狀態可以圖解為上。 試看看替建構式加上 prototype我們把建構式的 function 移除，把他改成 prototype。 function Point() &#123; this.x = 100; this.y = 99; // this.position = function ()&#123; // console.log(this.x,this.y); // &#125;&#125;Point.prototype.position = function() &#123; console.log(this.x, this.y);&#125;;const redPoint = new Point();const bluePoint = new Point();console.log(redPoint);console.log(bluePoint); omg，會發現我們的 function 不見了，打開 console。 會發現他在 __proto__ 裡面，這中間到底發生什麼事了。 我們可以知道，當我們要建立 instance 的時候，他的屬性等等 blabla 會參照建構式，所以 instance 的 __proto__ 也會參照建構式的 prototype。 那既然會參照建構式，那 function 還可以正常執行嗎？ redPoint.position();// 100 99 可以正常執行，我現在想知道 redPosition 這個物件是不是真的有這些屬性。 redPoint.hasOwnProperty('x');redPoint.hasOwnProperty('y');redPoint.hasOwnProperty('position');//true//true//false 為什麼 position 是 false ！？ 他明明就可以執行。 \b\b 原來 js 在呼叫屬性的時候，先在屬性找，找不到，就向上找 __proto__ ，__proto__是連結到建構式的 prototype，就找到 position 執行。 但是我們在 __proto__ 裡面還看到一個 __proto__，打開來看看： 會發現裡面都是我們平時在操縱物件的原生方法，原來我們平常操縱物件的方法都在裡面，因此我們可以理解成這樣。 wowww，一切都說得通了，為什麼我們建立 javascript 物件會有 __proto__ ，原來那是 javascript 的原型練，所有物件的方法都在裡面，而且物件的 prototype 永遠都保持在最上層。 建構式的繼承function Tire() &#123;&#125;Tire.prototype = &#123; print() &#123; return '我是輪胎'; &#125;,&#125;;function Car() &#123;&#125;Car.prototype = Object.create(Tire.prototype);Car.prototype.print = function() &#123; return '我是車';&#125;;function RedCar() &#123;&#125;RedCar.prototype = Object.create(Car.prototype);RedCar.prototype.print = function() &#123; return '我是紅色的車';&#125;;const michilin = new Tire();const honda = new Car();const redHonda = new RedCar();console.log(michilin.print());// 我是輪胎console.log(honda.print());// 我是車console.log(redHonda.print());// 我是紅車 現在有三個建構式，輪胎、車，跟紅車，輪胎繼承在車上，車繼承在紅色車子上，上面各自有可以印出他是什麼的 function，他們再分別建構出了：米其林、宏打、紅宏打。 function Tire() &#123;&#125;Tire.prototype = &#123; print() &#123; return '我是輪胎'; &#125;,&#125;;function Car() &#123;&#125;Car.prototype = Object.create(Tire.prototype);Car.prototype.print = function() &#123; return '我是車';&#125;;function RedCar() &#123;&#125;RedCar.prototype = Object.create(Car.prototype);// RedCar.prototype.print = function()&#123;// return '我是紅色的車'// &#125;const michilin = new Tire();const honda = new Car();const redHonda = new RedCar();// console.log(michilin.print())// console.log(honda.print())console.log(redHonda.print()); 今天我把紅宏打的 function 註解掉，他現在應該印不出東西來了。 console.log(redHonda.print());// 我是車 但是他最後還是有執行，印出了我是車，代表他繼承了車的 function。 \b\b 物件的繼承let water = &#123; printName() &#123; return '我是水'; &#125;,&#125;;let bottle = &#123; printMaterial() &#123; return '塑膠'; &#125;,&#125;;console.dir(bottle); console.dir 可以印出物件的屬性。 let water = &#123; printName() &#123; return '我是水'; &#125;,&#125;;let bottle = &#123; printMaterial() &#123; return '塑膠'; &#125;,&#125;;Object.setPrototypeOf(bottle, water);console.dir(bottle);console.dir(bottle.printName()); \b\b 這邊我們可以看到水瓶繼承了水的屬性，所以水瓶可以用水的 function，印出來是我是水。 let water = &#123; printName() &#123; return '我是水'; &#125;,&#125;;let bottle = &#123; printName() &#123; return '我是水瓶'; &#125;,&#125;;Object.setPrototypeOf(bottle, water);console.dir(bottle.printName()); 如果我們把printMaterial改成printName，它理所當然印出我是水瓶。 let water = &#123; printName() &#123; return '我是水'; &#125;,&#125;;let bottle = &#123; printName() &#123; return `$&#123;super.printName()&#125; ---水瓶`; &#125;,&#125;;Object.setPrototypeOf(bottle, water);console.dir(bottle.printName()); 但是我們在 bottle 裡面使用 super ，他可以繼承原型的屬性，所以他印出了我是水，但也印出了---水瓶，證明他呼叫的是 bottle 的 printName。 javascript ES6 有出 class 的建構式語法糖，有興趣的可以再去看看，感謝大家。","link":"/javascript-prototype/"},{"title":"【Hexo】hackMD 功能","text":"測試 hackmd 語法此頁是用來測試到底支援了多少 hackmd 原本的寫法不過，確實有許多功能不需要照本宣科的移植過來，畢竟身為 hackmd 的愛用者，只要夠用，而不是取代呀所以，下面列出目前支援的語法與功能到什麼程度，標示 danger 區塊的則是不支援或沒有這功能的意思。 測試開始功能介紹English version中文版日本語版 請不要修改這份筆記 非常謝謝您 :smile:如果要說 嗨 或是 玩些東西，請至 遊樂場 特賣會歡迎來自 Front-End Developers Taiwan 的各位！:100:歡迎來自 g0v 的各位！:+1:歡迎來自 程式人雜誌 的各位！:smiley: 簡介 ** hackmd ** 是個跨平台的 Markdown 即時協作筆記所以您可以在電腦、平板甚至是手機與其他人做筆記！同時也可以在 首頁 透過 Facebook、Twitter、GitHub、Dropbox 登入 目前這個服務還在初步階段，所以可能會有點問題或是壞掉如有任何狀況，請至 [GitHub](https://github.com/ hackmd io/ hackmd ) 回報問題如果需要即時支援，請使用 Facebook Message謝謝您！ 工作區模式電腦 &amp; 平板 編輯：只看到編輯器 檢視：只看到結果 同時：同時看到兩邊 手機 檢視：只看到結果 編輯：只看到編輯器 上傳圖片只要按下這個按鈕 或是 拖放 圖片到編輯器，甚至 貼上 圖片也可以喔！這會自動上傳圖片至 imgur，啥都不必煩惱了 :tada: 分享筆記如果您想分享 可編輯的 筆記，複製這份文件的網址就好如果您想分享 只可讀的 筆記，按下這個按鈕 然後複製網址 儲存目前可以儲存至 Dropbox 或是存放 .md 到您的本機 匯入就像上面的儲存功能，您可以從 Dropbox 匯入 .md 或是從 剪貼簿 匯入，而且這可以轉換 html 喔 :smiley: 權限檢視右上方有個小按鈕，您可以透過以下選項來更改權限： 隨意：任何人都可以更改這份筆記 可編輯：已登入使用者可以更改這份筆記 鎖定：只有擁有者可以更改這份筆記 私有：只有擁有者可以更改與檢視這份筆記 只有筆記的擁有者可以更改權限 嵌入&lt;iframe width=\"100%\" height=\"500\" src=\"https:// hackmd .io/features\" frameborder=\"0\"&gt;&lt;/iframe&gt; 簡報模式您可以使用一些語法將您的筆記分成投影片然後用 簡報模式 來展示，詳細請至上連結 檢視目錄在右下角有個目錄的小按鈕 按下它會顯示目前的目錄，而且會標明你所在的區塊支援到第三階段的標頭 永久連結每個標頭都會在右側自動加上永久連結您可以在滑到上面並且按 去移到那個錨點 編輯快速鍵跟又快又方便的 Sublime text 很像 更多訊息請至 這裡 自動完成提供完整的 Markdown 自動完成與提示 表情符號：輸入 : 顯示提示 程式碼區塊：:::danger(這一段顯示錯誤)輸入 加上一個字元 顯示提示 ::: 標頭：輸入 # 顯示提示 參考：輸入 [] 顯示提示 外部：輸入 {} 顯示提示 圖片：輸入 ! 顯示提示 標題會使用 第一個第一級標頭 作為筆記標題 標籤:::danger(這個語法的功能不同)如同以下方式來使用標籤，它們會顯示在您的 歷史紀錄 ####### tags: 功能 酷 更新 ::: YAML metadata提供描述筆記的資訊，以進階設定瀏覽行為，詳細請至上連結 robots: 設定網路機器人 meta lang: 設定瀏覽器顯示語言 dir: 設定文字方向 breaks: 設定是否使用分行 mathjax: 設定是否使用 mathjax 表情符號您可以像是這樣使用表情符號 :smile: :smiley: :cry: :wink: 完整的表情符號列表 在這裡 待辦清單 待辦 - [x] 買些沙拉 刷牙 - [ ] 喝水 程式碼區塊我們支援非常多程式語言，使用自動完成來看看有些什麼 123456789101112var s = 'JavaScript syntax highlighting';alert(s);function $initHighlight(block, cls) &#123; try &#123; if (cls.search(/\\bno\\-highlight\\b/) != -1) return process(block, true, 0x0f) + ' class=\"\"'; &#125; catch (e) &#123; /* handle exception */ &#125; for (var i = 0 / 2; i &lt; classes.length; i++) &#123; if (checkCondition(classes[i]) === undefined) return /\\d+[\\s/]/g; &#125;&#125; 如果想要 行號，在表明程式語言之後輸入 =您也可以指定開始行號，如下所示，行號從 101 開始 101102103104105106107108109110111112var s = 'JavaScript syntax highlighting';alert(s);function $initHighlight(block, cls) &#123; try &#123; if (cls.search(/\\bno\\-highlight\\b/) != -1) return process(block, true, 0x0f) + ' class=\"\"'; &#125; catch (e) &#123; /* handle exception */ &#125; for (var i = 0 / 2; i &lt; classes.length; i++) &#123; if (checkCondition(classes[i]) === undefined) return /\\d+[\\s/]/g; &#125;&#125; :::danger(這一段語法不吃，行號判定是+變 NaN) 或是可以接續上一個程式碼區塊的行號，使用 =+ 12var s = 'JavaScript syntax highlighting';alert(s); ::: :::danger(這一段語法不吃) 引用區塊標籤 您可以使用以下語法，表明自己的 姓名、時間與顏色 並與其他的引用區塊做區別[name=ChengHan Wu][time=sun, jun 28, 2015 9:59 pm] [color=#907bf7] 也支援巢狀引用區塊喔！[name=ChengHan Wu][time=sun, jun 28, 2015 10:00 pm] [color=red]::: 外部Youtube Vimeo Gist :::danger(這一段語法不吃) #### SlideShare&#123;%slideshare briansolis/26-disruptive-technology-trends-2016-2018-56796196 %&#125;#### Speakerdeck&#123;%speakerdeck sugarenia/xxlCSS-how-to-scale-CSS-and-keep-your-sanity %&#125;#### PDF**注意：請使用 https 的網址，否則可能會被您的瀏覽器阻擋載入**&#123;%pdf https://papers.nips.cc/paper/5346-sequence-to-sequence-learning-with-neural-networks.pdf %&#125; ::: MathJax您可以使用 MathJax 語法 來產生 LaTeX 數學表達式，如同 math.stackexchange.com： The Gamma function satisfying $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ is via the Euler integral $$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.$$ $$\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt,.$$ 更多關於 LaTeX 數學表達式 請至這裡 UML 圖表循序圖您可以像是以下使用循序圖： 流程圖您可以像是以下使用流程圖： :::danger(這一段語法不吃) Graphvizdigraph hierarchy &#123; nodesep=1.0 // increases the separation between nodes node [color=Red,fontname=Courier,shape=box] //All nodes will this shape and colour edge [color=Blue, style=dashed] //All the lines look like this Headteacher-&gt;&#123;Deputy1 Deputy2 BusinessManager&#125; Deputy1-&gt;&#123;Teacher1 Teacher2&#125; BusinessManager-&gt;ITManager &#123;rank=same;ITManager Teacher1 Teacher2&#125; // Put them on the same level&#125; Mermaidgantt title A Gantt Diagram section Section A task :a1, 2014-01-01, 30d Another task :after a1 , 20d section Another Task in sec :2014-01-12 , 12d anther task : 24d 更多關於 循序圖 語法 在這裡.更多關於 流程圖 語法 在這裡.更多關於 Graphviz 語法 在這裡更多關於 Mermaid 語法 在這裡::: 警告區塊:::success耶 :tada:::: :::info這是訊息 :mega:::: :::warning注意 :zap:::: :::danger喔不 :fire:::: 排版標頭## h1 標頭### h2 標頭#### h3 標頭##### h4 標頭###### h5 標頭####### h6 標頭 水平分隔線 字形替換(c) (C) (r) (R) (tm) (TM) (p) (P) +- 測試.. 測試… 測試….. 測試?….. 測試!…. !!!!!! ???? ,, Remarkable – awesome “Smartypants, 雙引號” ‘Smartypants, 單引號’ 強調這是粗體文字 這是粗體文字 這是斜體文字 這是斜體文字 這是刪除文字 上標： 19^th^ 下標： H2O ++這是底線文字++ ==這是標記文字== 引用區塊 引用區塊也可以是巢狀的喔… …可以多層次的使用… …或是用空白隔開 清單項目 在行開頭使用 + - 或是 * 來建立清單 空兩個空白就可以產生子清單 當清單標記使用的字元不同，會強制建立新的清單 Ac tristique libero volutpat at Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit 非常簡單！ 編號 Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa 1) 您可以逐次增加項目數字… 1) …或是全部都使用 1. 1) feafw 1) 332 1) 242 1) 2552 1) e2 從其他範圍開始編號清單 foo bar 程式碼行內 程式碼 縮排程式碼 // Some comments line 1 of code line 2 of code line 3 of code程式碼區塊 Sample text here... 語法標色 var foo = function(bar) &#123; return bar++;&#125;;console.log(foo(5)); 表格 選項 描述 data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 向右對齊 選項 描述 data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 向左對齊 選項 描述 data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 置中對齊 選項 描述 data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 連結連結文字加上標題的連結文字自動轉換連結 https://github.com/nodeca/pica 圖片如同連結一般，圖片也可以用註腳語法使用參考，可以在稍後的文件中再定義圖片網址 ![Minion](https://octodex.github.com/images/minion.png =200x200)使用指定的大小顯示圖片 註腳註腳 1 連結[^first].註腳 2 連結[^second].行內註腳^[行內註腳的文字] 定義重複的註腳參考[^second]. [^first]: 註腳 也可以標記 還可以有很多段落 [^second]: 註腳 文字 定義清單名詞 1 : 定義 1 快速連續項目 名詞 2 加上 行內標記 : 定義 2 { 這些程式碼屬於 定義 2 的一部分 } 定義 2 的第三段落緊密樣式： 名詞 1~ 定義 1 名詞 2~ 定義 2a~ 定義 2b 縮寫這是 HTML 的縮寫範例它會轉換 ‘HTML’，但是縮寫旁邊其他的部分，例如：”xxxHTMLyyy”，不受影響 *[HTML]: Hyper Text Markup Language st=>start: 開始 e=>end: 結束 op=>operation: 我的操作 op2=>operation: 啦啦啦 cond=>condition: 是或否？ st->op->op2->cond cond(yes)->e cond(no)->op2{\"theme\":\"simple\",\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);艾莉絲->包柏: 哈摟，你好嗎？ Note right of 包柏: 包柏思考中 包柏-->艾莉絲: 我很好，謝謝！ Note left of 艾莉絲: 艾莉絲回應 艾莉絲->包柏: 最近過得怎樣？{\"theme\":\"simple\",\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"sequence-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"sequence-0-options\").value)); var diagram = Diagram.parse(code); diagram.drawSVG(\"sequence-0\", options);","link":"/hackMD/"},{"title":"【筆記】 如何寫出好註解","text":"註解的目的是協助使用者了解程式碼作者的思想 了解不該註解的部份註解必須有價值 如何區分？ var cafeBean;//宣告 咖啡豆變數return cafeBean;//回傳 咖啡豆 function cafeFuc ()&#123; var cafe = 3; for(var i=0;i&lt;cafe.length;i++)&#123; var cafeNum += cafe[i] &#125;&#125; 這些註解並沒有提供額外的資訊，讓使用者更易閱讀程式碼，宣告與註解完全相同，應該刪除註解或改善內容。 不要註解不好的名稱，應修正名稱。var arr = [1, 2, 3, 4], deleteArr = [];for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &gt; 2) &#123; deleteArr.push(arr[i]); // 刪除arr1,2的結果 &#125;&#125;console.log(deleteArr); deleteArr 看起來像刪除 arr 裡的數值，但 arr 的內容並不會被更動，此時應該更正命名如下。 var arr = [1, 2, 3, 4], rebuildArr = [];for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &gt; 2) &#123; rebuildArr.push(arr[i]); // 刪除arr1,2 重組後的結果 &#125;&#125;console.log(rebuildArr); 利用註解補救程式碼不佳的可讀性 紀錄自己的想法記下寫程式時的重要想法 //後端回傳的json相當雜亂，但因重組資料耗費的時間成本太高，先將就使用。 讓讀者知道來龍去脈，省去時間做沒有效果的最佳化 //公車離站及末班車駛離的即時資料數值回傳皆為11，alert一律顯示'無公車進站' 少這段註解，避免讀者浪費時間測試或直接下手修正程式碼。 註解程式碼缺陷以下是許多程式設計師採用的標記 標記 意義 TODO: 作者還沒處理的部份 FIXME: 已知的問題 HACK: 承認解決方法不夠優雅 xxx: 危險！重要問題 每個團隊對於標計有各自的規範及使用時機，例如 TODO 被保留受到注意的問題，那麼大多數的小問題可以使用 todo:(小寫)。 常數的註解常數只是單純的數值，但加上註解仍有幫助。 var cafeBeanMaxmum = 200;//加上合理的上限——咖啡豆進貨上限 var zoom = 12;//zoom12為檢視googleMap的最佳比例 makeAcafe(inputValue);//執行製作一杯咖啡的時間，特別注意太糟的輸入值 全局註解詳述檔案 // 這隻sass主要為儲存變數、RWD斷點規劃.. switch (status) &#123; case 'go': // 去程顯示畫面 $('.choose').hide(); $('.showMap-go').show(); $('.showMap-back').hide(); //顯示google Map var map; initMap(); break; case 'back': // 回程顯示畫面 $('.showMap-go').hide(); $('.showMap-back').show(); $('.choose').hide(); var map; initMap(); break; case 'choose': default: // 選擇路線顯示畫面 $('.choose').show(); $('.showMap-go').show(); $('.showMap-back').hide(); break;&#125; 維持註解的簡潔 避免模擬兩可的代名詞（它、這個、那個） 修整草率的語句","link":"/how-to-write-annotation/"},{"title":"【Vue】如何優雅產生動態表單元件","text":"最近重構一下上個月趕的專案，還有很多地方可以加強優化，現在遇到第一個困難是如何減少 template 的重複性，簡單啊，用一下 v-for 就好了，但是遇到不同表單有各種形式的表現方式（selector、checkbox⋯⋯），我們勢必要使用不同種型態的子元件，但因為型態不同，資料結構就不同，那在這樣的狀況下，我們要如何去使用 v-for 呢？ 參考文章[译]如何优雅地用 Vue 创建数据驱动的用户界面 &gt; vue-dynamic-components(codesandbox) 強者我朋友花王就貼給我一篇文章，不看還好，看了一下一鳴驚人，完全沒看過這種寫法，接下來根據上面 codesandbox 的連結來討論動態表單元件的運行過程，以 Demo4 為例。 我們先看一下 DemoFour.vue ， 他在父元件裡面訂了一個 schema 的陣列。 schema: [ ... &#123; fieldType: \"TextInput\", placeholder: \"First Name\", label: \"First Name\", name: \"firstName\" &#125;, ...] &lt;component v-for=\"(field, index) in schema\" :key=\"index\" :is=\"field.fieldType\" v-model=\"formData[field.name]\" v-bind=\"field\"&gt;&lt;/component&gt; 判斷輸入類型 裡面有不同的物件型態，必要的物件屬性為 fieldType、label及name。fieldType 就是不同 input 的型態判別，例如 selector、 checkbox⋯⋯ 我們使用 v-for 來跑 schema 的物件 現在遇到的第一個問題，明明沒有在 component 定義，那這個 component tag 是從哪出來的，根據 Vue 動態元件的官方說明，我們可以知道那是搭配 is 屬性所使用，is 根據 schema 的 fieldType 來判斷要產生哪個形態的子元件。 解構賦值繫結至子元件 這邊的 v-bind 使用了解構賦值，被 v-bind 的 component 會以 props 的方式傳值傳進子元件，接下來我們來看看子元件。 接收 props 及 v-model 的 value export default &#123; name: 'TextInput', props: ['placeholder', 'label', 'name', 'value'],&#125;; 我們傳進了placeholder、label、name、value，疑？value？我們什麼時候傳進了 value ？\b\b 因為我們的父元件有 v-model，v-model 不外乎就是 v-on:input 和 v-bind:value，所以也是 v-bind 解構賦值到子元件，如果綁到空的屬性，value 就會是 undefined，接下來我們看一下 template 。 &lt;template&gt; &lt;div&gt; ... &lt;input type=\"text\" :name=\"name\" :value=\"value\" @input=\"$emit('input',$event.target.value)\" :placeholder=\"placeholder \" /&gt; &lt;/div&gt;&lt;/template&gt; 使用者行為修改值把 props 傳進來的資料依序綁在 input 上，而我們在父元件 v-model 的資料可以讓 value 變成 input 的預設的輸入文字，當使用者修改文字時，被 v-bind:value 會被修改，且同時 v-on:input 和 emit 通知父元件使用者已經修改資料，但是在父元件裡面我們並沒有接收到任何從 emit 自定義的變數來的事件，那他是如何接收？ newValue 覆蓋舊 value 其實就是 v-model ，因為 v-model 其實就是 v-bind:value，自然而然 $event.target.value 覆蓋了原本v-model的舊值，而 v-model 又跟 formData綁定。 另外需要注意，formData 的 屬性值要和 schema 物件的 name 相同，否則沒辦法綁定在一起。","link":"/vue-dynamic-components/"},{"title":"【Vue】Vue-cli 安裝","text":"版本：vue-cli 2.9.3 安裝$ npm install -g vue-cli // 全域安裝 vue-cli ，必須在 node.js 下安裝，安裝完之後，可以用vue -v檢查版本。 $ vue list vue-cli 官方提供多種樣版結構，可使用vue list查看樣板種類。 $ vue init &lt;template-name&gt; &lt;project-name&gt; 這邊我們選擇webpack版。 Generate project in current directory? Yes? Project name vuecli-demo? Project description A Vue.js project? Author // 預設? Vue build standalone // 預設? Install vue-router? // 是否安裝 vue-router? Use ESLint to lint your code? // 是否使用 eslint 檢測js? Set up unit tests // 使否單元測試? Setup e2e tests with Nightwatch? //是否使用 e2e 測試? Should we run `npm install` for you after the project has been created? Yes, use NPM//在專案創建好，是否跑 npm install 這邊會有像建置package.json一樣的選項讓你填寫，這邊我先選預設，並不安裝其他項目。 To get started: cd vuecli-demo npm run dev 接下來根據指令到專案資料夾跑 server ，便完成這次安裝。 產出的專案資料夾結構.├── build // 與 webpack 相關├── config // 與 webpack 相關├── node_modules // node npm 模組├── src // 主要開發環境 source code| ├── assets // 圖片等靜態檔| ├── router // vue 路由器| ├── app.vue // 主要的樣板檔| ├── main.js // 主要的 js 檔，套件 import 的入口文件| └── components // vue 元件檔├── static // 放置第三方 plugin 位置├── index.html // 靜態 html檔├── package.json└── package-lock.json","link":"/vue-cli-2-install/"},{"title":"【Vue】Vue 常用套件環境設定","text":"vue-loader bootstrap / jQuery axios 版本：vue-cli 2.9.3 Vue-router安裝 Vue-router$ npm install vue-router 在專案下使用 npm 安裝，如果你是使用 webpack 樣板，你在設定pakage.json就可以選擇要不要安裝。 註冊import router from './router';new Vue(&#123; el: '#app', router, components: &#123; App &#125;, template: '&lt;App/&gt;',&#125;); 在main.js裡面會發現他已經幫你 import 進去，接著看app.vue，會發現有個&lt;router-view/&gt;的標籤，這意思是路由顯示的畫面會在那個區塊做顯示，接著看router/index.js import Vue from 'vue';import VueRouter from 'vue-router';Vue.use(VueRouter);// init// page importimport Hello from './pages/Hello.vue';import Hello2 from './pages/Hello2.vue';const router = new VueRouter(&#123; mode: 'history', base: __dirname, // router 列表 routes: [ &#123; path: '/hello', name: 'hello', component: Hello, &#125;, &#123; path: '/hello2', name: 'hello2', component: Hello2, &#125;, // router 轉址 &#123; path: '/*', redirect: '/hello' &#125;, ],&#125;); 如果使用webpack-simple模板，需要按照官方的方式 import，也不會有router資料夾，必須直接在裡面設置 router。 import HelloWorld from '@/components/HelloWorld';export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', component: HelloWorld, &#125;, ],&#125;); 這段的意思是說，是 router 根據用戶的 url 來判斷要顯示哪個元件，所有要依據路由轉換的元件都要在router/index.js上註冊。 &lt;router-link :to=\"page01url\"&gt;page01&lt;/router-link&gt; &lt;router-link :to=\"page02url\"&gt;page02&lt;/router-link&gt; 在選用觸發切換路由，絕大部分人都會直接反應用 a 連結下去切換，但官方並不建議這樣寫，官方建議用&lt;router-link&gt;。 bootstrap安裝 bootstrap$ npm install bootstrap sass-loader postcss-loader node-sass --save 上面指令是官方建議的安裝方法，但如果要引用 bootstrap 的 sass 仍然會報錯，因為 webpack 無法解析，所以要安裝sass-loader、post-loader，以及讓sass-loader相依的node-sass，讓 bootstrap 可以正常解析。 $ npm install -D vue-style-loader css-loader 但是為了在預覽 vue 的時候可以即時顯示，所以我們必須還要再下載vue-style-loader，這和之前用的style-loader有 87 分像。 &#123; test: /\\.vue$/, loader: 'vue-loader', options: &#123; loaders: &#123; 'scss': [ 'vue-style-loader', 'css-loader', 'post-loader', 'sass-loader', ] &#125; &#125;&#125; 因為 webpack loader 的運作機制順序是由後往前、內往外，因此在webpack.base.config.js的配置如上，這讓 bootstrap 的 sass 有全局的設定。 $ npm install sass-resources-loader 此時發現，只要在子元件想要使用 bootstrap sass 的程式庫 \b（mixin、extend……）及變數，並無法正確載入，為了不要在子元件裡面一直重複 import ，這時候需要加載sass-resources-loader。 &#123; test: /\\.vue$/, loader: 'vue-loader', options: &#123; loaders: &#123; 'scss': [ 'vue-style-loader', 'css-loader', 'sass-loader', &#123; loader: 'sass-resources-loader', options: &#123; resources: path.resolve(__dirname, './src/assets/styles/global.scss'), &#125;, &#125; ] &#125; &#125;&#125; 這個 loader 主要是讓 sass 在被編譯解析前，把我們要設為全域環境的 sass 檔案路徑放到resources中。 @import '~bootstrap/scss/bootstrap'; 再到./src/assets/styles/global.scss的檔案裡面匯入 bootstrap 。 import './assets/styles/global.scss'; 最後別忘了要再app.vue的檔案中 import 才算完成。此外在global.scss中，你也可以放置你想要設為全域的 sass ，例如 RWD 斷點、變數之類的，因為這個 sass 是全域，所以也要考慮專案的加載量。 jQuery$ npm install --save jquery popper.js 處理完 sass 的部分，接下來處理互動。為了能正常使用 bootstrap 元件的部分，因此要再多下載 jQuery 和 popper.js，popper.js 的副檔名一定要加，不然 popper 是另外一個套件。 const webpack = require('webpack')... plugins: [ new webpack.ProvidePlugin(&#123; '$': \"jquery\", 'jQuery': \"jquery\", 'Popper': 'popper.js' &#125;) ], 在webpack.base.config.js的設定。 axios介紹 Promise based HTTP client for the browser and node.js 基於 promise 用於 瀏覽器和 node.js 的 HTTP 客戶端。 特色 在瀏覽器創建 XMLHttpRequest 從 node.js 發出 http 請求 支援 Promise API 攔截請求跟回應 轉換請求與回應資料 取消請求 自動轉換 JSON 資料 客戶端防止 CSRF/XSRF $ npm install axios 一樣使用 npm 安裝。 import Axios from 'Axios';......Vue.prototype.$axios = Axios;// 為了讓其他元件也能使用 axios，需改成 vue 的原型屬性。 安裝完之後，把他 import 進main.js。 post 範例執行方法created()&#123; this.$axios.post('/user', &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);&#125; 這個方法是在元件被創造完後，立即調用，利用 axios 執行 post 請求，要看更多方法請看axios github，生命週期的部分，詳細可以看Vue 生命週期。","link":"/vue-cli-2-plugin/"},{"title":"【Vue】Vue 與 webpack","text":"版本：vue-cli 2.9.3 產出的專案資料夾結構.├── build // 與 webpack 相關├── config // 與 webpack 相關├── node_modules // node npm 模組├── src // 主要開發環境 source code| ├── assets // 圖片等靜態檔| ├── router // vue 路由器| ├── app.vue // 主要的樣板檔| ├── main.js // 主要的 js 檔，套件 import 的入口文件| └── components // vue 元件檔├── static // 放置第三方 plugin 位置├── index.html // 靜態 html檔├── package.json└── package-lock.json 當我們使用npm run dev啟用 vue-cli 的專案，打開 chrome 的 network 會發現當中除了載入index.html，還有一隻app.js檔，可是你會發現專案裡面根本就沒有app.js檔，而且index.html根本也沒有引入任何的 js 文件。 我們從npm run dev開始追根究底，打開package.json會發現其中一行 script 指令。 &#123; ... \"dev\": \"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js\", ...&#125; 看起來我們運作的和build/webpack.dev.conf.js非常有關。 const utils = require('./utils');const webpack = require('webpack'); // webpack 核心編譯工具const config = require('../config'); // config/index.jsconst merge = require('webpack-merge'); // 合併 configconst path = require('path'); // node API 處理文件路徑const baseWebpackConfig = require('./webpack.base.conf'); //base.configconst CopyWebpackPlugin = require('copy-webpack-plugin');const HtmlWebpackPlugin = require('html-webpack-plugin');const FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin');const portfinder = require('portfinder'); 打開來會發現裡面有導入很多模組，我們主要看幾個文件，config/index.js，仔細看內容。 module.exports = &#123; dev: &#123; ... // Various Dev Server settings host: 'localhost', // can be overwritten by process.env.HOST port: 8080, // can be overwritten by process.env.PORT, if port is in use, a free one will be determined ... &#125;, build: &#123; // Template for index.html index: path.resolve(__dirname, '../dist/index.html'), ... &#125;&#125; 裡面分別有dev開發版本的基本設定，例如在本地端運行的 port 號 ，或是build生產版本的設定，例如首頁的導入設定，回去看build資料夾，裡面有三個 config 檔在不同狀況下讀取不同的檔案，分別是dev開發版本、build生產版本和base共用版本，當中最重要的是base，當中有一些 webpack 的基本設定。 ...context: path.resolve(__dirname, '../'), entry: &#123; app: './src/main.js' // 主要導入的 js &#125;, output: &#123; path: config.build.assetsRoot, // 編譯導出的文件路徑 config/index.js filename: '[name].js', // 導出文件名稱 [name].js =&gt; app.js publicPath: process.env.NODE_ENV === 'production' ? config.build.assetsPublicPath : config.dev.assetsPublicPath // 靜態文件的絕對路徑 &#125;, resolve: &#123; // import 元件時的設定 extensions: ['.js', '.vue', '.json'], alias: &#123; 'vue$': 'vue/dist/vue.esm.js', '@': resolve('src'), // 編寫路徑時 @ 可代替src &#125; &#125;, ...// webpack 編譯時，文件處理的相關 loader ... &#123; // 圖片處理（多媒體及字體以此類推） test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000,// 小於10kb會被編譯成 base64 字串打包編譯到 js 文件中 name: utils.assetsPath('img/[name].[hash:7].[ext]')// 超過大小會被放到/static/img/[圖片名稱].[hash值].副檔名 &#125;&#125;, ... 至於為什麼在static裡面，可以根據路徑轉向到utils.js裡面的assetsPath，發現文件又導向webpack.config.dev/build.js的assetsSubDirectory，發現 template 將路徑設定在static。 那剩下關於 webpack plugin/loader 的詳細設定，可以參考日安初探 webpack 系列文章。","link":"/vue-cli-2-webpack/"},{"title":"【Webpack】認識 webpack","text":"新手從無到有，初探 webpack 的心得，webpack 的基本介紹、比較，以及如何運用相關套件簡單運行。 版本：webpack 4.1.1 定義 At its core, webpack is a static module bundler for modern JavaScript applications. When webpack processes your application, it recursively builds a dependency graph that includes every module your application needs, then packages all of those modules into one or more bundles. webpack ，\b 簡單來說就是一個模組打包工具，可以將開發中的資料，如 html 文件、sass、圖片等資料，模組化，利用loader、plugin轉換成瀏覽器可以閱讀的資料並打包。 比較有些人會拿 webpack 跟 gulp 之類的工具做比較，讓我們先看看 gulp 官網的解釋。 gulp is a toolkit for automating painful or time-consuming tasks in your development workflow, so you can stop messing around and build something. gulp ，用於在開發流程中，自動執行較耗時或較痛苦的任務，意思是 gulp 為任務執行工具，可以通過定義task自動化來執行處理任務。 gulp 為任務執行工具，注重的是開發流程； webpack 強調模組化開發，處理壓縮文件、圖片等。 安裝webpack 必須運行在 node.js 的環境下。 $ npm install -g webpack 全域安裝 webpack。 webpack -v 安裝完後檢測版本，確認是否已經安裝。 npm 初始化先進到你要存放的目錄 $ mkdir webpack-demo$ cd webpack-demo$ npm init 接下來會出現package.json配置，可以全部 enter 跑預設。 name: (webpack-demo)version: (1.0.0)description:entry point: (index.js)test command:git repository: 接下來在webpack-demo下面出現package.json。 &#123; \"name\": \"webpack-demo\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"\", \"license\": \"ISC\"&#125; 這些都是關於這個專案的內容，可以根據專案狀況更改。 $ npm install --save-dev webpack 接下來在專案上安裝 webpack 。 \"devDependencies\": &#123; \"webpack\": \"^4.1.1\" &#125; package.json就會出現 webpack 的安裝資料。 運行 webpack現在來試著運作 webpack ，在目錄下新增src/app.js，內容如下。 console.log('hello webpack'); 在 terminal 輸入指令。 $ webpack ./src/app.js --output ./dist/app.bundle.js 目錄資料結構就變成這樣 .├── dist| └── app.bundle.js├── node_modules├── package.json└── src └── app.js app.bundle.js webpack 指令watchwebpack --watch ./src/app.js ./dist/app.bundle.js watch指令可以監聽檔案狀況做變更。 $ webpack -p ./src/app.js ./dist/app.bundle.js -p指令可以產出生產版壓縮過的檔案。 如果想看其他指令可以在 terminal 輸入 $ webpack --help 假設你只有在專案上面安裝 webpack，則輸入 $ npx webpack --help 配置 webpack在根目錄創建webpack.config.js的檔案，內容如下。 module.exports = &#123; entry: './src/app.js', output: &#123; filename: './app.bundle.js', &#125;,&#125;; entry為 source code，output是輸出的目標文件，配置完後，在 terminal 輸入 webpack 即可運行。 快速下 webpack 指令$ npm install webpack-cli -d 安裝webpack-cli，再改寫目前的package.json。 &#123; \"name\": \"wepback-demo\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"build\": \"webpack -d --watch\", \"prod\": \"webpack -p\" &#125;, \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": &#123; \"webpack\": \"^3.8.1\" &#125;&#125; 改寫之後，在 terminal 輸入指令。 $ npm run build 則會運行webpack -d --watch。 $ npm run prod 則會運行webpack -p。 使用script指令的好處是把所有命令集中在一起，方便維護查看，其他開發者只要看package.json就可以知道大概運行的開發指令是什麼。","link":"/webpack-4-first-try/"},{"title":"【Webpack】plugin 與 loader","text":"新手從無到有，初探 webpack 的心得。 此篇介紹 plugin 及 loader 簡單的使用方法，承襲上一篇的內容，逐步實作做下去。介紹的 plgin / loader 如下。 利用 template 產出 html 載入 css / sass 並另外產出 css 檔並引入 在本地端運行伺服器 自動清除殘餘檔案 babel 及 pug 轉譯 HMR 版本：webpack 4.1.1 Plugin 與 loader 介紹 Plugin 為外掛程式，普遍常用，在這邊不多作介紹。 Loaders are transformations that are applied on the source code of a module. They allow you to pre-process files as you import or “load” them. Thus, loaders are kind of like “tasks” in other build tools, and provide a powerful way to handle front-end build steps. Loaders can transform files from a different language (like TypeScript) to JavaScript, or inline images as data URLs. Loaders even allow you to do things like import CSS files directly from your JavaScript modules! 官方網站表明，loader 就像其他前端開發任務建構工具一樣，他可以將 typescript 轉換成 js ，或是將圖片轉換成內嵌 url ，或是直接在 js 模組中導入 css 文件。 使用 html-webpack-plugin$ npm install --save-dev html-webpack-plugin 在專案資料夾執行命令安裝，安裝完成後，會在package.json檔案下發現 \"devDependencies\": &#123; \"html-webpack-plugin\": \"^3.0.6\", \"webpack\": \"^4.1.1\" &#125; 產生 html 檔將webpack.config.js更改如下。 var HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: './src/app.js', output: &#123; path: __dirname + '/dist', filename: 'app.bundle.js', &#125;, plugins: [new HtmlWebpackPlugin()],&#125;; 執行npm run build，就會產生index.html，並自動載入 js 檔。 自動載入 titlevar HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: './src/app.js', output: &#123; path: __dirname + '/dist', filename: 'app.bundle.js', &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: 'hello world', &#125;), ],&#125;; 更改webpack.config後，標題則會自己更換，但為了不要一個個文件標題都要自行更改，必須使用到 template 。 templatevar HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: './src/app.js', output: &#123; path: __dirname + '/dist', filename: 'app.bundle.js', &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: 'hello world', template: './src/index.html', filename: 'index.html', minify: &#123; collapseWhitespace: true, &#125;, &#125;), ],&#125;; 更改webpack.config後，新增src/index.html的 template 樣板。 &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 執行npm run build，因為minify: {collapseWhitespace: true,},，所以輸出的 html 為壓縮形式沒有空格。 &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;hi&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\" src=\"app.bundle.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; css-loader / style-loader新增src/app.css body &#123; background: pink;&#125; 變更src/app.js import css from './app.css';console.log('hello world'); 在一般沒有加裝 loader 的狀況下，webpack 沒有辦法處理 css 文件，此時執行npm run build則會出現錯誤。 $ npm install --save-dev css-loader style-loader 因此加裝css-loader及style-loader。 var HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: './src/app.js', output: &#123; path: __dirname + '/dist', filename: 'app.bundle.js', &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: './src/index.html', filename: 'index.html', minify: &#123; collapseWhitespace: true, &#125;, hash: true, &#125;), ], module: &#123; rules: [ &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'], &#125;, ], &#125;,&#125;; 然後變更webpack.config.js，運行npm run build，再用瀏覽器打開dist/index.html，則會發現 css 已經載進 html 頁面。 test: /\\.css$/表示他是處理 css 文件，在處理 css 文件時，則是由陣列右邊執行到陣列左邊（裝飾模式）。css-loader先解析處理，再由style-loader則會將 css 嵌入 html。 sass-loaderbody &#123; background: pink; p &#123; color: red; &#125;&#125; 將app.css更改為app.scss，並修改為巢狀。 import css from './app.scss';console.log('hello world'); 更改app.js。 &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;hello world&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; src/index.html輸入p段落文字。 var HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: './src/app.js', output: &#123; path: __dirname + '/dist', filename: 'app.bundle.js', &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: './src/index.html', filename: 'index.html', minify: &#123; collapseWhitespace: true, &#125;, hash: true, &#125;), ], module: &#123; rules: [ &#123; test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'], &#125;, ], &#125;,&#125;; 更改webpack.config.js，則可運行 sass ，打開 source code 會發現裡面只有載入app.bundle.js，但有時候需要將 css 和 js 分離，則使用extract-text-webpack-plugin。 extract-text-webpack-plugin$ npm i -d extract-text-webpack-plugin@next 安裝套件。 var HtmlWebpackPlugin = require('html-webpack-plugin');const ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = &#123; entry: './src/app.js', output: &#123; path: __dirname + '/dist', filename: 'app.bundle.js', &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: './src/index.html', filename: 'index.html', minify: &#123; collapseWhitespace: true, &#125;, hash: true, &#125;), new ExtractTextPlugin('style.css'), ], module: &#123; rules: [ &#123; test: /\\.scss$/, use: ExtractTextPlugin.extract(&#123; fallback: 'style-loader', //resolve-url-loader may be chained before sass-loader if necessary use: ['css-loader', 'sass-loader'], &#125;), &#125;, ], &#125;,&#125;; 更改webpack.config.js後，執行npm run build，則會發現index.html另外載入style.css。 webpack-dev-server之前使用的webpack -d --watch適合運作在靜態文件上，但在開發狀態webpack-dev-server是更好的選擇。 $ npm install -g webpack-dev-server // 全域安裝$ npm install --save-dev webpack-dev-server // 區域安裝 接著執行。 $ webpack-dev-server server 執行成功，port 號為 8080。 我們也可以到webpack.config.js改 port 號，設定open:true，自動打開瀏覽器。 proxywebpack-dev-server 有提供代理伺服器的功能。 module.exports = &#123; entry: './src/app.js', ... devServer: &#123; port: 9000, open: true, proxy: &#123; \"/api\": &#123; target: \"https://other-server.example.com\" &#125; &#125; &#125; ...&#125;; 為了避免跨域的狀況，當請求 api 的時候，便會呼叫 target。 babel loaderbabel-loader就是一個轉譯器，將一些瀏覽器不支援的 js 寫法或檔案，轉譯成瀏覽器可以讀取的檔案。 $ npm install --save-dev babel-loader 在專案下安裝babel-loader。 rules: [ ..., &#123; test: /\\.js$/, loader: 'babel-loader', exclude: /node_modules/ &#125; ] 便可執行轉譯。 clean webpack plugin主要運用在產出檔案前，將原資料夾檔案清空，一開始我們先更改原本的設定。 webpack.config.js ...entry: &#123; 'app.bundle': './src/app.js'&#125;,output: &#123; path: __dirname + '/dist', filename: '[name].[chunkhash].js'&#125;,... 將產出的 js 檔名更改為 hash 值，避免檔名重複出現錯誤。 這時只要修改src/app.js，webpack就會重新產生一個 js 檔，因此需要clean webpack plugin將原本的舊的檔案清除，如此一來就不會累積過多的舊檔案。 $ npm i clean-webpack-plugin --save-dev 在專案資料夾，使用 npm 指令安裝。 ...const CleanWebpackPlugin = require('clean-webpack-plugin');......plugins: [ new CleanWebpackPlugin(['dist']), ... ], 呼叫套件，並指定清空檔案的資料夾，這時候再使用npm run build觀察，此時發現dist資料夾下只剩下一隻 js 檔。 pug-html-loaderpug(jade) 是 html 的樣板語言，猶如 sass 和 css 之間的關係，這邊先不多作解釋。 $ npm install --save-dev pug pug-html-loader raw-loader 先安裝 pug 、 pug-html-loader 和 raw-loader。加裝 raw-loader 是因為 pug-html-loader 必須依附在這個 loader 下，google 未果，我不知道為什麼，如果有人知道，歡迎在下方留言告訴我。 doctype htmlhtml(lang=&quot;en&quot;) head title= pageTitle script(type=&apos;text/javascript&apos;). if (foo) bar(1 + 5) body h1 Pug - node template engine #root #container.col if youAreUsingPug p You are amazing else p Get on it! p. Pug is a terse and simple templating language with a strong focus on performance and powerful features. 為了測試是否能正確將 pug 編譯出來，先將src/index.html改為src/index.pug，並將內容更改為 pug 的格式，內容如上。 plugins: [ ... new HtmlWebpackPlugin(&#123; template: './src/index.pug', ... &#125;), ... ], module: &#123; rules: [ ... &#123; test: /\\.pug$/, loader: ['raw-loader', 'pug-html-loader'] &#125; ] &#125; 再將webpack.config.js進行修改，並下指令運行，便可成功轉譯。 使用 HMR 監看修改的 CSSwebpack --watch及webpack-dev-server 是監聽文件的變化自動刷新瀏覽器，而 HMR \b 不是刷新整個瀏覽器，只會讓已經修改的部分，出現修改後的變化。 先將剛剛修改的 pug template 改回 html template。 const webpack = require('webpack');......devServer: &#123; port: 9000, open: true, hot: true &#125;......plugins: [ new webpack.NamedModulesPlugin(), new webpack.HotModuleReplacementPlugin() ], 修改webpack.config.js，並運行。 ERROR in chunk app.bundle [entry][name].[chunkhash].jsCannot use [chunkhash] for chunk in &apos;[name].[chunkhash].js&apos; (use [hash] instead) 接下來就會爆出錯誤訊息，需要將chunkhash改成hash。chunkhash是根據 Entry 文件內容，編譯出對應的 hash 值。hash是只要文件內容有更改，當次被編譯出來的相關文件 hash 都會變更，而且相同。 另外提一個叫contenthash，假設index.css被index.js引用，但更改的文件只有index.js時，會產生index.css也會被重新編譯，如此會產生重複內容的檔案，這時候輸入contenthash只要該文件內容不改變，也不會重新編譯。 output: &#123; path: __dirname + '/dist', filename: '[name].[hash].js'&#125;, 接下來將 output 的檔名進行更改，此時運行時你會發現頁面完全不會改變。 new ExtractTextPlugin(&#123; filename: 'style.css', disable: true&#125;), 只要將ExtractTextPlugin修改，便可以自動更新頁面，這意味著產出 css 和 HMR，只能二選一，我們可以將開發環境和生產環境分離，便可以解決。","link":"/webpack-4-plugin-loade/"},{"title":"【Webpack】打包圖片與壓縮","text":"新手從無到有，初探 webpack 的心得。 打包圖片與壓縮的介紹。 版本：webpack 4.1.1 新增src/img/logo.png，並在 src/app.scss 裡面載入背景圖片background: url(&#39;./img/logo.png&#39;) 0 0 no-repeat;，執行之後會報錯，因此我們要加裝file-loader。 Sass 載入圖片file-loader$ npm install --save-dev file-loader 在專案下安裝。 module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: 'file-loader', options: &#123;&#125;, &#125;, ], &#125;, ], &#125;,&#125;; 更改webpack.config.js，執行後有效，但發現圖檔名為 hash 值，因此我們更改option。 test: /\\.(gif|png|jpe?g|svg)$/i,use: [ &#123; loader: 'file-loader', options: &#123; name: '[name].[ext]', outputPath: 'images/' &#125; &#125;, name：採用 source 檔名 ext：副檔名 outputPath：輸出檔案資料夾 Html 載入圖片$ npm install --save-dev html-loader 這時候又發現沒有辦法在 html 載入圖片，因為缺少一個在 html 中處理圖片的 loader，因此用上述指令安裝。 &#123; test: /\\.html$/, use: [ &#123; loader: 'html-loader', options: &#123; minimize: true &#125; &#125;],&#125; 新增一個 loader，更改webpack.config.js設定。 壓縮圖片$ npm install image-webpack-loader --save-dev 安裝image-webpack-loader。 &#123; test: /\\.(gif|png|jpe?g|svg)$/i, use: [&#123; loader: 'file-loader', options: &#123; name: '[name].[ext]', outputPath: './img/' &#125; &#125;, &#123; loader: 'image-webpack-loader', options: &#123; bypassOnDebug: true, &#125; &#125; ]&#125; 更改webpack.config.js裡面file-loader的設定。 $ ls -lh src/img$ ls -lh dist/img 輸入指令可以查看圖片大小的落差，有些圖片太小會比較沒有感覺。 另外如果要在 js 檔使用圖片，則須在 js 內引入import img from &#39;./img/logo.png&#39;;。","link":"/webpack-4-image-compression/"},{"title":"【Webpack】source-map","text":"新手從無到有，初探 webpack 的心得。 有時候看到別人的webpack.config.js會看到一段devtool: &#39;source-map&#39;，不太了解這是什麼，也不太了解那有什麼用處，現在就來看看。 版本：webpack 4.1.1 因為有時候要檢查出錯的程式碼，但是從 webpack 產出的檔案都是已經被編譯過的，就算找到 bug 位置，可是不知道具體 source code 位置，還是沒辦法做即時修正。 一、在 js 中使用module.exports = &#123; entry: &#123; ... &#125;, devtool: 'source-map'&#125; 修改webpack.config.js，開發者工具會連結到src/app.js 有 bug 的位置。 二、在 css 中使用&#123; test: /\\.scss$/, use: ExtractTextPlugin.extract(&#123; fallback: 'style-loader', //resolve-url-loader may be chained before sass-loader if necessary use: ['css-loader?sourceMap', 'sass-loader?sourceMap'] &#125;)&#125; 一樣修改webpack.config.js，就會在開發者工具 css 的部份看到 app.scss。","link":"/webpack-4-source-map/"},{"title":"【ES6】陣列麻吉罵上篇：ForEach、Filter、Map、Reduce","text":"在我們初學 Javascript ，最常用到的就是for迴圈，但當案子的複雜度增加，我們常常都要在迴圈外面先建立一個空陣列，而且迴圈都不知道迴到哪去（？）因此 ES6 中，有新增幾個陣列的方法，在這邊介紹幾個陣列的麻吉罵。 此篇文章的資料及範例程式碼皆擷取自MDN。 ForEach、Filter、Map、Reduce forEachforEach 循環陣列的每個元素。 filter()filter 遍歷陣列的每個元素，回傳 true 時，目前的值會保留在原本的陣列，這會回傳一個新陣列，而不是修改原本陣列的值。 map()map 會給你一組一樣長度的新陣列，雖然filter也是產生一個新的陣列，但filter僅會把有符合function檢驗的元素回傳到新陣列（陣列長度不一定相同）。 reduce()使用 reduce 把陣列內的內容組合並最終回傳一個結果。 forEacharr.forEach(function callback(currentValue[, index[, array]]) &#123;&#125;[, thisArg]); callback將把array的子元素當作參數，各別帶進這個function。 currentValue目前被處理中的元素。 index 選填目前被處理中元素的索引值。 array 選填呼叫forEach的 array 本身。 thisArg 選填執行function的this。 const items = ['item1', 'item2', 'item3'];const copy = [];for (let i = 0; i &lt; items.length; i++) &#123; copy.push(items[i]);&#125; 使用 for 迴圈。 const items = ['item1', 'item2', 'item3'];const copy = [];items.forEach(function(item) &#123; copy.push(item);&#125;); 使用 forEach。 比較下來，forEach 跟 for 迴圈是有同樣效果，但 forEach 省略一長串的寫法。 filtervar newArray = arr.filter(callback[, thisArg]) callback測試陣列中的每個元素，回傳值為true的元素值，則保留在新陣列中可帶入三個傳入參數。 currentValue目前被處理中的元素。 index 選填目前被處理中元素的索引值。 array 選填呼叫forEach的 array 本身。 thisArg 選填執行function的this。 var newArray = arr.filter(callback[, thisArg]) filter 會將陣列中通過 function 檢驗的元素組成一組新陣列。 var words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];const result = [];for (let i = 0; i &lt; words.length; i++) &#123; if (words[i].length &gt; 6) &#123; result.push(words[i]); &#125;&#125;console.log(result);// expected output: Array [\"exuberant\", \"destruction\", \"present\"] 使用 for 迴圈。 var words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];const result = words.filter(word =&gt; word.length &gt; 6);console.log(result);// expected output: Array [\"exuberant\", \"destruction\", \"present\"] 使用 filter，跟原 for 比較，省略使用 if、push 的方法，且程式碼更為乾淨簡潔。 mapvar new_array = arr.map(function callback(currentValue[, index[, array]]) &#123; // Return element for new_array&#125;[, thisArg]) callback為產生新陣列的回呼函式。 currentValue目前被處理中的元素。 index 選填目前被處理中元素的索引值。 array 選填呼叫map的陣列。 thisArg 選填執行function的this。 var kvArray = [&#123; key: 1, value: 10 &#125;, &#123; key: 2, value: 20 &#125;, &#123; key: 3, value: 30 &#125;];var reformattedArray = kvArray.map(obj =&gt; &#123; var rObj = &#123;&#125;; rObj[obj.key] = obj.value; return rObj;&#125;);// reformattedArray：[&#123;1: 10&#125;, &#123;2: 20&#125;, &#123;3: 30&#125;],// kvArray is still:// [&#123;key: 1, value: 10&#125;,// &#123;key: 2, value: 20&#125;,// &#123;key: 3, value: 30&#125;] 使用 map，map 會給你一組一樣長度的新陣列，filter 同樣產生一個新陣列，但因新陣列僅有符合 function 檢驗的元素（陣列長度不一定相同）。 reducearr.reduce(callbackFn[(accumlator, currentValue, currentIndex, array)], initialValue); reduce 將組合的初始數值及陣列中的各個值，傳入函數，化為單一值。 callbackFn -accumlator用來組合累積回呼函式回傳值的組合器。組合器是上一次呼叫後，所回傳的累算數值。 -currentValue當次欲組合的元素數值。 -currentIndex選填原陣列所處理中的元素索引。 -array 選填呼叫reduce()方法的陣列。 initialValue 選填組合傳入的初始值，為額外的陣列的初始加值。 當回呼函式第一次被呼叫時，accumulator 與 currentValue 的值可能為兩種不同的狀況： 若在呼叫reduce()時有提供initialValue（也就是初始值），則accumulator（組合器）將會等於initialValue，且 currentValue會等於陣列中的第一個元素值。 若沒有提供 initialValue（初始值），則 accumulator（組合器）會等於陣列的第一個元素值，且 currentValue將會等於陣列的第二個元素值。 [0, 1, 2, 3, 4].reduce(function(accumulator, currentValue, currentIndex, array) &#123; return accumulator + currentValue;&#125;);// output:10 callback accumulator currentValue currentIndex array return value first call 1 2 1 [1, 2, 3, 4 ,5] 3 second call 3 3 2 [1, 2, 3, 4 ,5] 6 third call 6 4 3 [1, 2, 3, 4 ,5] 10 fourth call 10 5 4 [1, 2, 3, 4 ,5] 15","link":"/javascript-es6-array-part01/"},{"title":"【ES6】陣列麻吉罵下篇：Sort、Every、Find、Some","text":"在我們初學 Javascript ，最常用到的就是for迴圈，但當案子的複雜度增加，我們常常都要在迴圈外面先建立一個空陣列，而且迴圈都不知道迴到哪去（？）因此 ES6 中，有新增幾個陣列的方法，在這邊介紹幾個陣列的麻吉罵。 此篇文章的資料及範例程式碼皆擷取自MDN。 Sort、Every、Find、Some Sort使用 sort 將陣列中的元素排列至其應當的位置上並返回此陣列。 Every使用 every 遍歷陣列的每個元素，當陣列的元素只要有一個不符合函式條件，即回傳false，全部的元素都通過條件，即返回true。 Findfind 遍歷陣列的每個元素，回傳陣列第一個符合函式條件的元素，callback 隨即結束，若都不符合，則回傳undefined。 Some使用 some 遍歷陣列的每個元素，當陣列的元素只要有一個符合函式條件，即回傳true，陣列中全部的元素都不符合條件，即返回false。 sortarr.sort([compareFunction]); compareFunction：指定函數來定義排序順序。 var items = [ &#123; name: 'Edward', value: 21 &#125;, &#123; name: 'Sharpe', value: 37 &#125;, &#123; name: 'And', value: 45 &#125;, &#123; name: 'The', value: -12 &#125;, &#123; name: 'Magnetic' &#125;, &#123; name: 'Zeros', value: 37 &#125;,];items.sort(function(a, b) &#123; if (a.name &gt; b.name) &#123; return 1; &#125; if (a.name &lt; b.name) &#123; return -1; &#125; // a must be equal to b return 0;&#125;); 比較 a , b 元素 結果 compareFunction(a, b) &gt;0 將 b 排在比 a index 還小處 compareFunction(a, b) =0 互相不改變順序 compareFunction(a, b) &lt;0 將 a 排在比 b index 還小處 everyarr.every(callback[, thisArg]) callback測試元素的函式，可帶入三個傳入參數。 element目前被處理中的元素。 index 選填目前被處理中元素的索引值。 array 選填呼叫every的陣列本身。 thisArg 選填執行function的this。 function isBigEnough(element, index, array) &#123; return element &gt;= 10;&#125;[12, 5, 8, 130, 44].every(isBigEnough); // false[12, 54, 18, 130, 44].every(isBigEnough); // true 因為第一個isBigEnough陣列的5不符合函式條件，因為every回傳false，第二個isBigEnough的陣列元素，全部都符合函式條件，回傳true。 findarr.find(callback[, thisArg]) callback測試元素的函式，可帶入三個傳入參數。 element目前被處理中的元素。 index 選填目前被處理中元素的索引值。 array 選填呼叫find的陣列本身。 thisArg 選填執行function的this。 var array1 = [5, 12, 8, 130, 44];var found = array1.find(function(element) &#123; return element &gt; 10;&#125;);console.log(found);// expected output: 12 find執行後，第一個符合element &gt; 10條件的數值為12，則found的變數值為12，且傳入變數found為數值，而非陣列。 somearr.some(callback[, thisArg]) callback測試元素的函式，可帶入三個傳入參數。 element目前被處理中的元素。 index 選填目前被處理中元素的索引值。 array 選填呼叫some的陣列本身。 thisArg 選填執行function的this。 function isBiggerThan10(element, index, array) &#123; return element &gt; 10;&#125;[2, 5, 8, 1, 4].some(isBiggerThan10); // false[12, 5, 8, 1, 4].some(isBiggerThan10); // true 因為第一個isBiggerThan10陣列全部不符合函式條件，所以回傳false，第二個isBiggerThan10的第一個元素12，符合函式條件，則回傳true。","link":"/javascript-es6-array-part02/"},{"title":"【ES6】 let、const","text":"之前其實就有發過相關的文章，可是因為 github 沒有上傳 source code 結果被我弄爆了，這次挑精簡的寫重點，詳細的可以 google ，很多大神都有寫相關的文章。 變數宣告在 javascript 裡面命令宣告不外乎就是var、let、const。 var 函式作用域 變數提升 函式作用域var為函式作用域，就是以函式當作變數是否有效的界線，這樣無疑會造成許多全域變數的產生。 for (var i = 0; i &lt; 3; i++) &#123; console.log('hi');&#125;console.log(i);// hi// hi// hi// 10 會得到這種迴圈體外可以存取得到變數i的現象，因為函式作用域的關係，導致i變成全域變數。 var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function() &#123; console.log(i); &#125;;&#125;a[6](); // 10 承上範例，因為i為全域變數，導致不管在迴圈體內輸入的i值為多少，輸出的console.log仍然為10。 變數提升console.log(abc); // undefinedvar abc = 10; var會發生變數提升的現象，在變數宣告前使用變數，輸出值為undefined。 let、const 區塊作用域 變數提升 不可重複宣告 減少 IIFE 的應用 區塊作用域if (true) &#123; let a = 0;&#125;console.log(a);// ReferenceError: a is not defined 區塊作用域顧名思義變數僅在區塊內有效。 變數提升console.log(b);let b = 10;// ReferenceError: b is not defined 因為報錯的關係，許多人以為let和const不會做變數提升，事實上仍然會，只是因為 ES6 為了避免執行錯誤，將變數移至暫時性死區。暫時性死區的定義是，在變數宣告前使用變數，所使用的變數仍然存在，但是不可使用，只有等到宣告變數後，才可以使用該變數。 不可重複宣告&#123; let a = 10; let a = 1;&#125;// Uncaught SyntaxError: Identifier 'a' has already been declared 不允許在相同作用域裡面，重複宣告同一個變數。 減少 IIFE 的應用IIFE (function() &#123; var tmp = 1; console.log(tmp);&#125;)();// 1 區塊作用域 &#123; let tmp = 2; console.log(2);&#125;// 2 let 變數宣告 迴圈循環重新綁定 變數宣告let a = 10;a = a + 1;console.log(a);// 11 let為變數宣告，可重複指定，用法類似於var。 迴圈循環重新綁定var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function() &#123; console.log(i); &#125;;&#125;a[6](); // 6 因為區塊作用域的關係，i只在迴圈體內有效，每次遍歷都是重新綁定的變數，javascript 引擎內部會記住上一輪迴圈的數值，基於上一輪的計算，初始化本輪的變數i。 const 常數宣告 不可重複指定 常數宣告const a;// Uncaught SyntaxError: Missing initializer in const declaration const是針對常數做的定義，在常數做宣告時，必定要賦予值。 不可重新指定const a = 10;a = 11;// Uncaught TypeError: Assignment to constant variable. 不可重新指定的意思是不可用等號運算子做指定運算，如上所示，但宣告一個常數，不表示為不可改變。 const b = &#123;&#125;;b.obj = 123;console.log(b);//&#123;obj: 123&#125; 如果宣告的常數像是物件、陣列，都是屬於by reference，因此不會產生錯誤。","link":"/javascript-es6-let-const/"},{"title":"【JS30】Day01：JavaScript Drum Kit","text":"javascript 30day 目標：按鍵盤按鍵，使畫面有動態效果及聲音。一、按下鍵盤事件window.addEventListener('keydown', playSound);//利用 window 監聽 keydown 事件來偵測使用者按下的按鈕。 二、連結聲音function playSound(e) &#123; const audio = document.querySelector(`audio[data-key=\"$&#123;e.keyCode&#125;\"]`); // 利用 template literals 加入變數，選擇音檔。 const key = document.querySelector(`.key[data-key=\"$&#123;e.keyCode&#125;\"]`); // 選擇按鍵 if (!audio) return; audio.currentTime = 0; // 每次按鍵重新播放聲音 key.classList.add('playing'); // 加入 css 效果&#125; 三、事件動畫效果keys.forEach(key =&gt; key.addEventListener('transitionend', removeTransition));// function 傳入 forEach 遍輪 key ， 使每個按鍵監聽 transitionend 事件。function removeTransition(e) &#123; if (e.propertyName !== 'transform') return; // 跳過 CSS transform 屬性 this.classList.remove('playing'); // 移除 css 效果&#125; 使用技巧 forEach template literals arrow function transitionend","link":"/javascript-30-day01/"},{"title":"【JS30】Day02：CSS + JS Clock","text":"javascript 30day 目標：使畫面指針依照電腦時間進行動態效果。一、 調整畫面指針設定指針的 CSS 下屬性。 transform-origin: 100%;// 改變位置水平垂直位置transform: rotate(90deg);// 改變角度，使指針以 12 點鐘方向為起始transition-timing-function: cubic-bezier(0.1, 2.7, 0.25, 1);// 利用貝茲曲線製造出指針動態的彈出效果 二、取得當下時間function setDate() &#123; const now = new Date(); const seconds = now.getSeconds(); // 取得秒數 const secondsDegree = (seconds / 60) * 360 + 90; // 計算角度 secondsHand.style.transform = `rotate($&#123;secondsDegree&#125;deg)`; // 使用style transform 動態改變角度 const mins = now.getMinutes(); const minsDegree = (mins / 60) * 360 + 90; minsHand.style.transform = `rotate($&#123;minsDegree&#125;deg)`; const hour = now.getHours(); const hourDegree = (mins / 12) * 360 + 90; hourHand.style.transform = `rotate($&#123;hourDegree&#125;deg)`;&#125;setInterval(setDate, 1000);// 每秒執行一次 setDate function 使用技巧 newDate transform el.style.styleAttribute","link":"/javascript-30-day02/"},{"title":"【JS30】Day03：JS Playing with CSS Variables","text":"javascript 30day 目標：讓使用者可調整邊距顏色、寬度，及模糊度JS Playing with CSS Variables and JS Day03一、將欲改變的屬性命名 css 變數:root &#123; –base: #ffc600; –spacing: 50px; –blur: 10px;&#125;// 變數命名img &#123; padding: var(–spacing); background-color: var(–base); filter: blur(var(–blur));&#125;// 呼叫變數 二、監聽 inputconst inputs = document.querySelectorAll('.controls input');function handleUpdate() &#123; const suffix = this.dataset.sizing || ''; document.documentElement.style.setProperty(`--$&#123;this.name&#125;`, this.value + suffix); // 使用 document.documentElement.style.setProperty('變數名稱', '數值');&#125;inputs.forEach(input =&gt; input.addEventListener('change', handleUpdate));inputs.forEach(input =&gt; input.addEventListener('mousemove', handleUpdate)); 使用技巧 css variables data-attribute forEach","link":"/javascript-30-day03/"},{"title":"【JS30】Day04：Array Cardio Day 1","text":"javascript 30day 目標：說明並練習這些在 JS 中常用的幾個陣列方法使用技巧 Array.prototype.filter() Array.prototype.map() Array.prototype.reduce() Array.prototype.sort() 補充 Array.prototype.forEach() 參考文章：【 ES6 】陣列麻吉罵上篇：ForEach、Filter、Map、Reduce Array.prototype.filter() 一. 使用 filter 挑選出生在 15 世紀的發明家。const fifteen = inventors.filter(function(inventor) &#123; if (inventor.year &gt;= 1500 &amp;&amp; inventor.year &lt; 1600) &#123; return true; //keep it!! &#125;&#125;);console.table(fifteen); 或改寫成 arrow function const fifteen = inventors.filter(inventor =&gt; inventor.year &gt;= 1500 &amp;&amp; inventor.year &lt; 1600); Array.prototype.map() ###二. 給予一組擁有 first 與 last 屬性的陣列。 const fullNames = inventors.map(inventor =&gt; $&#123;inventor.first&#125; $&#123;inventor.last&#125;);console.log(fullNames); Array.prototype.sort() 三. 將發明家陣列從年老到年輕排序。const ordered = inventors.sort(function(a, b) &#123; if (a.year &gt; b.year) &#123; return 1; &#125; else &#123; return -1; &#125;&#125;); const ordered = inventors.sort((a, b) =&gt; (a.year &gt; b.year ? 1 : -1));console.table(ordered); Array.prototype.reduce() 四. 發明家們總共活了多少年？const totalYears = inventors.reduce((total, inventor) =&gt; &#123; return total + (inventor.passed - inventor.year);&#125;, 0);console.log(totalYears); 五. 排序活最久到活最少的發明家const oldest = inventors.sort(function(a, b) &#123; const lastGuy = a.passed - a.year; const nextGuy = b.passed - b.year; return lastGuy &gt; nextGuy ? -1 : 1;&#125;);console.table(oldest); 六. 建立一個名字裡有包含’de’的清單https://en.wikipedia.org/wiki/Category:Boulevards_in_Paris const category = document.querySelector('.mw-category');const links = Array.from(category.querySelectorAll('a'));// 選取所有a連結，並組成陣列const de = links.map(link =&gt; link.textContent).filter(streetName =&gt; streetName.includes('de')); 七. 按字母排序名字const alpha = people.sort((lastOne, nextOne) =&gt; &#123; const [aLast, aFirst] = lastOne.split(', '); const [bLast, bFirst] = nextOne.split(', '); return aLast &gt; bLast ? 1 : -1;&#125;);console.log(alpha); people字串陣列以Beck, Glenn結構所組成的，使用split方法分割姓名，拆解為[aLast, aFirst] = [Beck, Glenn]的模式，使用sort排序後，再傳回alpha。 stringObj.split([separator[, limit]]) 回傳為字串分割成的字串陣列。 stringObj 必要項。要分割的 String 物件或字串常值。 split 方法不會修改這個物件。 separator 選擇項。字串或規則運算式物件，可識別用來分隔字串的一個或多個字元。如果省略，則會傳回包含整個字串的單一元素陣列。 limit 選擇項。用來限制陣列中所傳回元素個數的值。 八. 總結各項例子const data = [ 'car', 'car', 'truck', 'truck', 'bike', 'walk', 'car', 'van', 'bike', 'walk', 'car', 'van', 'car', 'truck', 'pogostick',];&#123; car: 1; truck: 2;&#125;const transportation = data.reduce(function(obj, item) &#123; if (!obj[item]) &#123; obj[item] = 0; &#125; obj[item]++; return obj;&#125;, &#123;&#125;);console.log(transportation); 初始先予給一個空物件，假設物件沒有item的屬性，則新增一個item屬性，數值為 0，若有相同的 item 屬性，則做累加，結束後回傳物件。","link":"/javascript-30-day04/"},{"title":"【JS30】Day05：Flex Panel Gallery","text":"javascript 30day 目標：利用 flex 做面板特效一、將主畫面排版首先將主畫面排版完成，在各畫面（ panel ）的父層（ panels ）下display:flex，並在各畫面下flex:1，意思為平均分配多餘的空間。 二、處理字體效果再來處理畫面中字體的特效，將畫面中的子元素下垂直水平置中，且為垂直排序。 使用技巧 transitionend Event flexbox","link":"/javascript-30-day05/"},{"title":"【JS30】Day06：Ajax Type Ahead","text":"javascript 30day 目標：完成搜尋功能，並在搜尋關鍵字加上顏色辨識。一、首先將目標 json 指定為變數，使用fetch方法取得資料，塞進空陣列。fetch('目標url', HeadersObject) .then(function(response) &#123; //處理 response &#125;) .catch(function(err) &#123; // Error :( &#125;); 二、建立一個RegExp，使用match方法進行比對。function numberWithCommas(x) &#123; return x.toString().replace(/\\B(?=(\\d&#123;3&#125;)+(?!\\d))/g, ',');&#125;// 利用正規表示法，在人口數量增加逗點function displayMatches() &#123; const matchArray = findMatches(this.value, cities); //輸入值 const html = matchArray .map(place =&gt; &#123; const regex = new RegExp(this.value, 'gi'); // 呼叫 RegExp 物件的建構函式 const cityName = place.city.replace(regex, `&lt;span class=\"hl\"&gt;$&#123;this.value&#125;`); const stateName = place.state.replace(regex, `&lt;span class=\"hl\"&gt;$&#123;this.value&#125;`); return `&lt;li&gt;&lt;span class=\"name\"&gt;$&#123;cityName&#125;, $&#123;stateName&#125; &lt;span class=\"population\"&gt;$&#123;numberWithCommas(place.population)&#125;&lt;/li&gt;`; &#125;) .join(''); suggestions.innerHTML = html;&#125; 三、監聽change及keyup事件，讓鍵盤在輸入時觸發比對。searchInput.addEventListener('change', displayMatches);searchInput.addEventListener('keyup', displayMatches); 使用技巧 fetch / then / catch / blob spread 展開運算子 （ es6 ） regExp （ 正規表達式 ） match replace","link":"/javascript-30-day06/"},{"title":"【JS30】Day07：Array Cardio Day 2","text":"javascript 30day 目標：說明並練習這些在 JS 中常用的幾個陣列方法使用技巧 Array.prototype.some() Array.prototype.find() Array.prototype.findIndex() 參考文章：【 ES6 】陣列麻吉罵下篇：Sort、Every、Find、Some Array.prototype.some() 一. 使用 some 確認陣列是否有元素 &gt;=19 。const isAdult = people.some(function(person) &#123; const currentYear = new Date().getFullYear(); if (currentYear - person.year &gt;= 19) &#123; return true; &#125;&#125;);//Output:true 或改寫成 arrow function const isAdult = people.some(person =&gt; new Date().getFullYear() - person.year &gt;= 19);console.log(&#123; isAdult &#125;); some會遍歷整個陣列的元素傳進function，確認元素是否符合條件，假設其中一個元素符合條件，即返回true，假設整個陣列都沒有元素符合條件，返回false。 Array.prototype.every() 二. 使用 every 確認陣列是否有元素 &gt;=19。const allAdults = people.every(person =&gt; new Date().getFullYear() - person.year &gt;= 19);console.log(&#123; allAdults &#125;); every會遍歷整個陣列的元素傳進function，檢查陣列中所有元素是否符合條件，符合條件即回傳true，只要有一個元素不符合，則回傳false。 Array.prototype.find() 三. 尋找 id 是 823424 的留言。const comment = comments.find(function(comment) &#123; if (comment.id == '823423') &#123; return true; &#125;&#125;);console.log(comment);//Output:&#123;text: \"Super good\", id: 823423&#125; 試著自己改寫arrow function。 const comment = comments.find(comment =&gt; comment.id == '823423');console.log(comment); find會遍歷整個陣列，假使有元素符合條件，及返回元素值為true的元素，和filter不同的差別為，find只會回傳第一個符合條件的元素值。 Array.prototype.findIndex() 四.刪除 id 為 823434 的留言const index = comments.findIndex(comment =&gt; comment.id === 823423);console.log(index);//Output:1comments.splice(index, 1); 或是將comments.splice(index, 1);改寫成 const newComments = [...comments.slice(0, index), ...comments.slice(index + 1)];","link":"/javascript-30-day07/"},{"title":"【JS30】Day08：Fun with HTML5 Canvas","text":"javascript 30day 目標：使用滑鼠做拖拉繪圖，顏色及筆劃粗細能在繪畫時能產生不同變化。const canvas = document.querySelector('#draw');// 指定canvas畫布const ctx = canvas.getContext('2d');// 渲染環境為2D繪圖canvas.width = window.innerWidth;canvas.height = window.innerHeight;// 指定畫布寬高ctx.strokeStyle = '#BADA55';//指定筆刷顏色ctx.lineJoin = 'round';// 筆劃轉角形狀ctx.lineCap = 'round';// 筆劃形狀ctx.lineWidth = 100;// 筆劃寬度// ctx.globalCompositeOperation = 'multiply';// 圖形相疊時的模式 上述參數設定皆為 Canvas 的基本環境設定，比較特別是 globalCompositeOperation ，圖形相疊模式有點像 photoshop 的混合模式。 let isDrawing = false;// 判斷是否為繪圖狀態的參數let lastX = 0;let lastY = 0;// 設定要繪畫的位置參數。let hue = 0;// 色相值let direction = true;// 判斷繪圖粗細增減function draw(e) &#123; if (!isDrawing) return; // 如果繪畫參數為false，則不執行函數 console.log(e); ctx.strokeStyle = `hsl($&#123;hue&#125;, 100%, 50%)`; // 繪畫時的筆刷顏色為色相變數 ctx.beginPath(); // 啟動 canvas 繪畫路徑 ctx.moveTo(lastX, lastY); // canvas路徑位置移動到 X、Y 變數。 ctx.lineTo(e.offsetX, e.offsetY); // 連結點與點之間的座標 ctx.stroke(); [lastX, lastY] = [e.offsetX, e.offsetY]; //利用解構賦值，使繪畫位置為目前滑鼠位置 hue++; //色相漸增 if (hue &gt;= 360) &#123; hue = 0; &#125; //但因色相只有360度，只要大於等於360度，色相就再從零開始 if (ctx.lineWidth &gt;= 100 || ctx.lineWidth &lt;= 1) &#123; direction = !direction; &#125; //當筆劃寬度大於等於100或小於等於1，則轉換判斷變數 if (direction) &#123; ctx.lineWidth++; &#125; else &#123; ctx.lineWidth--; &#125; // 轉換判斷變數&#125;canvas.addEventListener('mousedown', e =&gt; &#123; isDrawing = true; [lastX, lastY] = [e.offsetX, e.offsetY];&#125;);// 當滑鼠按下時，讓滑鼠當下的位置就是繪畫位置，並讓isDrawing為true為繪畫狀態。canvas.addEventListener('mousemove', draw);// 滑鼠移動時，仍然執行繪畫函數canvas.addEventListener('mouseup', () =&gt; (isDrawing = false));canvas.addEventListener('mouseout', () =&gt; (isDrawing = false));// 放開滑鼠時和滑鼠移出時，使繪畫參數為false，不執行繪畫函數。 使用技巧 Canvas","link":"/javascript-30-day08/"},{"title":"【JS30】Day09：Dev Tools Domination","text":"javascript 30day 目標：了解開發者工具使用方法一、對 DOM 元素按右鍵下中斷點 subtree modifications: 當子元素發生變化時 arrtibute modifications: 當元素發生變化時 node removal: 當元素被移除時 二、console.log 各種用法 console.log(‘’); 一邊的 console.log console.log(‘%s’); console.log(‘%c’); console.wran(‘’); 出現警告圖示 console.error(‘’); 出現錯誤圖示 console.info(‘’); 出現資訊圖示 console.assert(Condition Expression,’’); 判斷是否為真，false 則回傳錯誤。 ```8. console.clear(); 清除所有訊息9. console.dir(); 顯示所有屬性10. console.groupCollapsed、console.groupEnd 群組化訊息```jsdogs.forEach(dog =&gt; &#123; console.groupCollapsed(`$&#123;dog.name&#125;`); console.log(`This is $&#123;dog.name&#125;`); console.log(`$&#123;dog.name&#125; is $&#123;dog.age&#125; years old`); console.log(`$&#123;dog.name&#125; is $&#123;dog.age * 7&#125; dog years old`); console.groupEnd(`$&#123;dog.name&#125;`);&#125;); console.count(); 累加計數 console.count(a);console.count(a);console.count(b);a: 1;a: 2;b: 1; console.time()、 console.timeEnd() 計算區域範圍執行時間區間 console.table()","link":"/javascript-30-day09/"},{"title":"【JS30】Day10：Hold Shift and Check Checkboxes","text":"javascript 30day 目標：單點滑鼠選取，加按 shift 區域選取。const checkboxes = document.querySelectorAll('.inbox input[type=\"checkbox\"]');// 選擇多選框checkboxes.forEach(checkbox =&gt; checkbox.addEventListener('click', handleCheck));// 點擊多選框觸發函數let lastChecked;function handleCheck(e) &#123; // 判斷是否同時按下shift和選擇多選框的參數 let inBetween = false; if (e.shiftKey &amp;&amp; this.checked) &#123; // 遍歷所有 checkbox checkboxes.forEach(checkbox =&gt; &#123; console.log(checkbox); if (checkbox === this || checkbox === lastChecked) &#123; inBetween = !inBetween; console.log('Starting to check them inbetween!'); &#125; // 勾選區間內為true的checkbox if (inBetween) &#123; checkbox.checked = true; &#125; &#125;); &#125; lastChecked = this;&#125;","link":"/javascript-30-day10/"},{"title":"【JS30】Day11：Custom Video Player","text":"javascript 30day 目標：使用 html5 video tag 控制影片一、先抓取 html5 video tag DOM 元素// 取得元素const player = document.querySelector('.player');const video = player.querySelector('.viewer');const progress = player.querySelector('.progress');const progressBar = player.querySelector('.progress__filled');const toggle = player.querySelector('.toggle');const skipButtons = player.querySelectorAll('[data-skip]');const ranges = player.querySelectorAll('.player__slider'); 二、建立 functionfunction togglePlay() &#123; const method = video.paused ? 'play' : 'pause'; // 三元運算子 true:play ; false:pause video[method](); //抓出video的 play / pause 屬性執行&#125;function updateButton() &#123; const icon = this.paused ? '►' : '❚ ❚'; console.log(icon); toggle.textContent = icon;&#125;function skip() &#123; video.currentTime += parseFloat(this.dataset.skip); // parseFloat 解析字串並返回數字&#125;function handleRangeUpdate() &#123; video[this.name] = this.value; // volume/playbackRate&#125;function handleProgress() &#123; const percent = (video.currentTime / video.duration) * 100; progressBar.style.flexBasis = `$&#123;percent&#125;%`;&#125;function scrub(e) &#123; const scrubTime = (e.offsetX / progress.offsetWidth) * video.duration; video.currentTime = scrubTime;&#125; 三、監聽並執行video.addEventListener('click', togglePlay); //點擊影片控制開關toggle.addEventListener('click', togglePlay); //播放鍵控制開關video.addEventListener('play', updateButton);video.addEventListener('pause', updateButton); //控制播放鍵開關狀態video.addEventListener('timeupdate', handleProgress); //播放直接更新進度條skipButtons.forEach(button =&gt; button.addEventListener('click', skip)); // forEach是因為有前後跳轉ranges.forEach(range =&gt; range.addEventListener('change', handleRangeUpdate));ranges.forEach(range =&gt; range.addEventListener('mousemove', handleRangeUpdate)); //控制調整音量跟播放速度let mousedown = false;//因為拖拉進度條，影片感覺像無法跟上，因此再監聽mouseup和mousedown，讓影片進度條更即時progress.addEventListener('click', scrub); //點擊改變進度條progress.addEventListener('mousemove', () =&gt; mousedown &amp;&amp; scrub(e));//拖拉改變進度條，如果mousedown是true，就往後執行scrub(e)，如果false就中斷。progress.addEventListener('mousedown', () =&gt; (mousedown = true)); //拖拉改變進度條progress.addEventListener('mouseup', () =&gt; (mousedown = false)); //拖拉改變進度條","link":"/javascript-30-day11/"},{"title":"【JS30】Day12：Key Sequence Detection","text":"javascript 30day 目標：只有輸入某段特別密碼，才會出現特效。const pressed = []; //保存已輸入值的陣列const secretCode = 'wesbos'; //密碼window.addEventListener('keyup', e =&gt; &#123; console.log(e.key); pressed.push(e.key); pressed.splice(-secretCode.length - 1, pressed.length - secretCode.length); if (pressed.join('').includes(secretCode)) &#123; console.log('DING DING!'); cornify_add(); &#125; console.log(pressed);&#125;); 使用keyup監聽按鍵行為，觸發時利用陣列的push塞入已經按下按鍵的內容，利用splice來控制陣列的長度，使陣列為最後輸入的五個字元，再以join、includes來驗證輸入值是否和密碼相同，若相同則出現特效。 使用技巧 splice include join splice 刪除array.splice(start[, deleteCount[, item1[, item2[, …]]]]) start索引位置（從 0 開始），如果索引大於陣列長度，則索引值會被設為陣列長度；如果索引為負值（從 -1 開始），則會從陣列最後一個元素往前更動，且若此負數的絕對值大於陣列長度，則會被設置為 0 。 deleteCount，選擇性。表示要刪除原本陣列數量的整數。 item1,item2…，選擇性。從start位置起始，要加入到陣列的元素。 回傳：一個被包含刪除的元素陣列，如果只有一個元素被刪除，依舊是回傳包含一個元素的陣列，倘若沒有元素被刪除，則會回傳空陣列。 include 包含arr.includes(searchElement[, fromIndex]) searchElement要搜尋的元素 fromIndex，選擇性。預設值為 0 ，要在此陣列搜尋searchElement的位置。如果是負數，則自array.length - fromIndex開始搜尋，預設值為 0 。 回傳：布林值 join 合併字串arr.join([separator]) separator，選擇性。用來隔開陣列中每個元素的字串。 如果必要的話，separator 會自動被轉成字串型態，未傳入參數，陣列中的元素將預設用英文逗號（「,」）隔開。如果 separator 是空字串，合併後，元素間不會有任何字元。 回傳：一個合併所有陣列元素的字串。假如arr.length為 0，將回傳空字串。","link":"/javascript-30-day12/"},{"title":"【JS30】Day13：Slide In on Scroll","text":"javascript 30day 目標：滾動捲軸，使圖片滑動顯示。一、設定 transition 設定彈跳動畫效果作者已經在 css 上設定好transition。 二、監聽及觸發const sliderImages = document.querySelectorAll('.slide-in');window.addEventListener('scroll', debounce(checkSlide)); 因為滑動必須用windows選定scroll事件，但因效能上的需求，所以作者多寫一個debounce的function，讓scroll觸發事件間隔 20 秒。 三、了解視窗高度function checkSlide(e) &#123; sliderImages.forEach(sliderImage =&gt; &#123; const slideInAt = window.scrollY + window.innerHeight - sliderImage.height / 2; //圖片1/2的定位點 = 捲軸垂直位移量 + 視窗高度 - 圖片1/2的高度 const imageBottom = sliderImage.offsetTop + sliderImage.height; //圖片底部 = 圖片離視窗頂部的距離 + 圖片高度 const isHalfShown = slideInAt &gt; sliderImage.offsetTop; //判斷視窗是否超過圖片的一半，超過顯示 const isNotScrolledPast = window.scrollY &lt; imageBottom; //判斷滾動範圍是否超過圖片底部，超過則不顯示 if (isHalfShown &amp;&amp; isNotScrolledPast) &#123; sliderImage.classList.add('active'); &#125; else &#123; sliderImage.classList.remove('active'); &#125; //判斷是否顯示圖片 &#125;);&#125; window.scrollY window.innerHeight sliderImage.offsetTop slideInAt 捲軸垂直的位移量（不含視窗） 視窗高度 圖片離視窗頂部的高度 圖片 1/2 的定位點 使用技巧 window.scrollY：瀏覽器 Y 軸滾動的位移量。 window.innerHeight：瀏覽器的可視高度。 offsetTop：傳回當前元素對於offsetParent元素頂部距離的位置。","link":"/javascript-30-day13/"},{"title":"【JS30】Day14： JavaScript References VS Copying","text":"javascript 30day 目標：理解 javascript reference 與 copy原始型別let age = 100;let age2 = age;console.log(age, age2);//100,100age = 200;console.log(age, age2);//200,100 原始型別都是 Call by value，所以複製時不影響，當age = 200，因為age2已經被定義過，則age的改變不會影響age2。 陣列const players = ['Wes', 'Sarah', 'Ryan', 'Poppy'];const team = players;team[3] = 'Lux';console.log(team, players);//['Wes', 'Sarah', 'Ryan', 'Lux']//['Wes', 'Sarah', 'Ryan', 'Lux'] 陣列為 Call by reference ，因為我們更新team，但team本身沒有陣列可以更改，team本身參照player的原始陣列，所以如果你修改原始陣列，或當你更新任何陣列，他就會被修改，陣列參照不同於數字、布林及字串。 假設你是想複製且更新一份陣列。 const team2 = players.slice();const team3 = [].concat(players);const team4 = [...players];const team5 = Array.from(players); 物件const person = &#123; name: 'Wes Bos', age: 80,&#125;;const captain = person;captain.number = 99; 物件和陣列相同，屬於 call by reference ，因此為了不要污染到person。 const cap3 = &#123; ...person &#125;; 或 const cap2 = Object.assign(&#123;&#125;, person, &#123; number: 99, age: 12,&#125;);console.log(cap2); 如此，可覆寫原本屬性與值的配對，且person則不會被污染到，但有例外的是。 const wes = &#123; name: 'Wes', age: 100, social: &#123; twitter: '@wesbos', facebook: 'wesbos.developer', &#125;,&#125;;const dev = Object.assign(&#123;&#125;, wes);dev.social.twitter = '@coolman';console.log(dev.social);// Object &#123; twitter: '@coolman' , facebook: 'wesbos.developer'&#125;console.log(wes.social);// Object &#123; twitter: '@coolman' , facebook: 'wesbos.developer'&#125; Object.assign僅能做一層複製。 const dev2 = JSON.parse(JSON.stringify(wes)); 可使用以上做破解。因為使用JSON.stringify，將原本物件的內容，全部轉換成字串，回到原始型別，在用JSON.parse轉成物件，則全部內容都能被複製成功。 使用技巧 slice() concat() es6 Spread Array.from() Object.assign()","link":"/javascript-30-day14/"},{"title":"【JS30】Day15：LocalStorage","text":"javascript 30day 目標：使用 LocalStorage 做 todolistconst addItems = document.querySelector('.add-items');const itemsList = document.querySelector('.plates');const items = []; 一開始進入 start 作者已經命名好變數。 一、送出輸入項目addItems.addEventListener('submit', addItem); 在input輸入完，送出項目。 function addItem(e) &#123; e.preventDefault(); // 取消送出資料後的自動刷新頁面 const text = this.querySelector('[name=item]').value; // item 的輸入值為 text 的 key / value，放入 json 中 const item = &#123; text, //es6:text:text done: false, &#125;; items.push(item); //塞入陣列存取 populateList(items, itemsList); //建html localStorage.setItem('items', JSON.stringify(items)); //因為重新整理之後，輸入的資料會消失，則必須將資料輸入到瀏覽器的localStorage this.reset(); //清除輸入框（form的方法）&#125; 二、新建後新增 htmlfunction populateList(plates = [], platesList) &#123; platesList.innerHTML = plates .map((plate, i) =&gt; &#123; return ` &lt;li&gt; &lt;input type=\"checkbox\" data-index=$&#123;i&#125; id=\"item$&#123;i&#125;\" $&#123;plate.done ? 'checked' : ''&#125; /&gt; &lt;label for=\"item$&#123;i&#125;\"&gt;$&#123;plate.text&#125;&lt;/label&gt; &lt;/li&gt; `; &#125;) .join('');&#125; 新增 \b\b html 的li項目。 const items = JSON.parse(localStorage.getItem('items')) || []; 此時items必須更改為以上，假設localStorage有資料則取用，若沒有資料items為空陣列。 三、儲存 checkbox 狀態itemsList.addEventListener('click', toggleDone); ul被點擊後，執行。 function toggleDone(e) &#123; if (!e.target.matches('input')) return; // input （checkbox）才執行動作 const el = e.target; const index = el.dataset.index; items[index].done = !items[index].done; //true / false 切換 localStorage.setItem('items', JSON.stringify(items)); //存入localStorage populateList(items, itemsList); //更新 html&#125; 四、進入頁面populateList(items, itemsList); 假設進入頁面時localStorage有資料，在最底下執行populateList，以刷新 html 。 使用技巧 localStorage dateset","link":"/javascript-30-day15/"},{"title":"【JS30】Day16：Mouse Move Shadow","text":"javascript 30day 目標：滑鼠移動時，CSS 的陰影跟著移動。一、設立目標區域const hero = document.querySelector('.hero');const text = hero.querySelector('h1'); function shadow(e) &#123; const &#123; offsetWidth: width, offsetHeight: height &#125; = hero; // 利用解構賦值取得目標寬高 let &#123; offsetX: x, offsetY: y &#125; = e; // 取得滑鼠位置 if (this !== e.target) &#123; x = x + e.target.offsetLeft; y = y + e.target.offsetTop; &#125; // 如果在目標區域外 則加入目標座標值 二、設定偏移量const walk = 100;const xWalk = Math.round((x / width * walk) - (walk / 2));const yWalk = Math.round((y / height * walk) - (walk / 2));// 並四捨五入偏移值text.style.textShadow = ` $&#123;xWalk&#125;px $&#123;yWalk&#125;px 0 rgba(255,0,255,0.7), $&#123;xWalk * -1&#125;px $&#123;yWalk&#125;px 0 rgba(0,255,255,0.7), $&#123;yWalk&#125;px $&#123;xWalk * -1&#125;px 0 rgba(0,255,0,0.7), $&#123;yWalk * -1&#125;px $&#123;xWalk&#125;px 0 rgba(0,0,255,0.7)`;&#125;// 加入 textShadowhero.addEventListener('mousemove', shadow); 使用技巧 解構賦值","link":"/javascript-30-day16/"},{"title":"【JS30】Day17：Sort Without Articles","text":"javascript 30day 目標：排除某些文字下進行陣列排序一、排序陣列const sortedBands = band.sort(function(a, b) &#123; if (a &gt; b) &#123; return 1; &#125; else &#123; return -1; &#125;&#125;); 將原本的陣列做排序，但因為有a、an、the等冠詞，造成無法正確依照字母順序做排序。 二、使用正規表示法過濾冠詞function strip(bandName) &#123; return bandName.replace(/^(a |the |an )/i, '').trim(); 三、排序過濾好的陣列const sortedBands = bans.sort((a,b)=&gt; strip(a):strip(b) ? 1:-1); 這邊使用三元運算子及箭頭函式。 四、渲染 DOMdocument.querySelector('#bands').innerHTML = sortedBands.map(band =&gt; `&lt;li&gt;$&#123;band&#125;&lt;/li&gt;`).join(''); 這邊加上join();是因為在陣列裡面，字串的區隔是逗號，如果不寫入join，則會把逗號一起渲染。 使用技巧 正規表示法 map \bjoin sort","link":"/javascript-30-day17/"},{"title":"【JS30】Day18：Adding Up Times with Reduce","text":"javascript 30day 目標：使用 reduce 總和所有播放影片的時間一、抓 DOMconst timeNodes = Array.from(document.querySelectorAll('[data-time]'));const seconds = timeNodes.map(node =&gt; node.dataset.time); 使用[...]或Array.from()先將取用到的dataset的 nodelist 轉換成陣列。 二、加總計算const seconds = timeNodes .map(node =&gt; node.dataset.time) .map(timeCode =&gt; &#123; const [mins, secs] = timeCode.split(':').map(parseFloat); return mins * 60 + secs; console.log(mins, secs); &#125;) .reduce((total, vidSecondes) =&gt; total + vidSecondes); 使用map轉換成新陣列，取用dataset的數值，使用split刪除:符號分割，並從字串轉換為數字，\b 分鐘轉換秒數加總，再使用reduce做陣列加總。 三、計算小時let secondsLeft = seconds;const hours = Math.floor(secondsLeft / 3600);secondsLeft = secondsLeft % 3600;const mins = Math.floor(secondsLeft / 60);secondsLeft = secondsLeft % 60;console.log(hours, mins, secondsLeft); 計算小時，將秒數轉換成小時後，使用Math.floor()取用整數，再使用%計算剩餘的秒數，再以同樣的方法轉換分鐘，便可以計算出所有影片的小時/分鐘/秒數。 三、計算分鐘使用技巧","link":"/javascript-30-day18/"},{"title":"【JS30】Day19：Unreal Webcam Fun","text":"javascript 30day 目標：取用攝影機，預覽截圖存檔。const video = document.querySelector('.player');const canvas = document.querySelector('.photo');const ctx = canvas.getContext('2d');const strip = document.querySelector('.strip');const snap = document.querySelector('.snap'); 練習檔案已經先取用 DOM，開始練習前，要先啟用本地端 server。必須加裝 node.js ，並在練習資料夾的 terminal 輸入以下指令。npm installnpm start 一、取用攝影機function getVideo() &#123; navigator.mediaDevices .getUserMedia(&#123; video: true, audio: false &#125;) // 取得使用者攝影機裝置，並利用 promise 回傳 .then(localMediaStream =&gt; &#123; console.log(localMediaStream); video.src = window.URL.createObjectURL(localMediaStream); video.play(); // 如果回傳成功，將回傳的 localMediaStream 寫入 html video tag 並播放。 &#125;) .catch(err =&gt; &#123; console.log('no', err); // 如果回傳失敗，送出錯誤訊息 &#125;);&#125;getVideo(); video.addEventListener('canplay', paintToCanvas); 二、將資料，寫進 canvas function paintToCanvas() &#123; const width = video.videoWidth; const height = video.videoHeight; // 取用影像寬高 canvas.width = width; canvas.height = height; // 使影像寬高等於 canvas 寬高 return setInterval(() =&gt; &#123; // 每16毫秒 取用一次影像 ctx.drawImage(video, 0, 0, width, height); // 讓影像為繪圖來源，寬、高、XY軸位置與 video 相同。 let pixels = ctx.getImageData(0, 0, width, height); // 取用 canvas 圖像數據資料 pixels = rgbSplit(pixels); // 將資料傳進 rgbSplit，增加濾鏡效果，再重新寫入 pixels ctx.globalAlpha = 0.1; // 調節 canvas 透明度 ctx.putImageData(pixels, 0, 0); // 將圖像數據指定到 canvas 上 &#125;, 16);&#125; console.log(pixels)會發現，canvas 圖像數據資料都是數個陣列所組成，數據為數字，順序皆為 RGBA 輪迴。 function rgbSplit(pixels) &#123; for (let i = 0; i &lt; pixels.data.length; i += 4) &#123; pixels.data[i - 150] = pixels.data[i + 0] + 100; pixels.data[i + 500] = pixels.data[i + 1] - 50; pixels.data[i - 550] = pixels.data[i + 2] * 0.5; &#125; return pixels;&#125; 因此增加濾鏡效果，四個數值為一個輪迴，巡迴data陣列 RGB 的數值，並作修改。 三、拍照效果 function takePhoto() &#123; snap.currentTime = 0; // 音效轉回第 0 秒 snap.play(); // 播放 const data = canvas.toDataURL('image/jpeg'); // 將資料轉為 base64 的文字資料 const link = document.createElement('a'); // 建立一個 a 連結 link.href = data; // 連結位置設置為 base64 位置 link.setAttribute('download', 'pretty'); // 設為連結提供下載 link.innerHTML = `&lt;img src=\"$&#123;data&#125;\" alt=\"pretty\" /&gt;`; // 將圖片預覽 strip.insertBefore(link, strip.firstChild); // 在圖片區域放入新的圖片，並使新圖片新增在第一個位置&#125; 使用技巧 MediaDevices.getUserMedia() CanvasRenderingContext2D.drawImage() HTMLCanvasElement.toDataURL() Node.insert Before() CanvasRenderingContext2D.getImageData() putImageData()","link":"/javascript-30-day19/"},{"title":"【JS30】Day20：Native Speech Recognition","text":"javascript 30day 目標：在頁面上啟用語音辨識並輸入文字。window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition; 作業一開始已經先將全域語音辨識指定好，這次練習也要啟用本地端 server 。 一、建立語音辨識物件const recognition = new SpeechRecognition();// 建立一個變數為語音辨識recognition.interimResults = true;// 允許語音辨識回傳識別後的資料 二、新增輸入區域文字段落let p = document.createElement('p');// 建立段落const words = document.querySelector('.words');// 選取輸入區域words.appendChild(p);// 使段落新增到輸入區域中 三、整合語音資訊到輸入區域 recognition.addEventListener('result', e =&gt; &#123; // 監聽識別後的結果回傳資料 const transcript = Array.from(e.results) // 因為得到的是 nodelist ，所以先轉為陣列 .map(result =&gt; result[0]) // 透過陣列取得資料中的第一筆 .map(result =&gt; result.transcript) // 再取出第一筆中的 transcript 資料 .join(''); // 使用 join 取消連結符號 p.textContent = transcript; // 將回傳的文字內容放入段落中 if (e.results[0].isFinal) &#123; // 假設回傳內容結束 則放入一個新段落到輸入區域中 p = document.createElement('p'); words.appendChild(p); &#125;&#125;);recognition.addEventListener('end', recognition.start);// 如果語音辨識結束，則重新打開語音辨識。recognition.start();// 開始語音辨識 使用技巧 SpeechRecognition.interimResults","link":"/javascript-30-day20/"},{"title":"【JS30】Day21：Geolocation based Speedometer and Compass","text":"javascript 30day 目標：取得裝置地理位置和速度一、使用 npm 啟動 server因為練習是取用定位，所以 mac 可以用 Xcode 模擬，或是用 npm start 啟動內網 ip，連線啟動 server 。 二、Codingconst arrow = document.querySelector('.arrow');const speed = document.querySelector('.speed-value');// 抓取 DOMnavigator.geolocation.watchPosition( data =&gt; &#123; // 使用 watchPosition 取得裝置資料，若成功就回傳 console.log(data); // data.coords.speed 取得速度 speed.textContent = data.coords.speed; // data.coords.heading 取得角度 arrow.style.transform = `rotate($&#123;data.coords.heading&#125;deg)`; &#125;, err =&gt; &#123; console.error(err); &#125;,); 使用技巧 Geolocation.watchPosition()","link":"/javascript-30-day21/"},{"title":"【JS30】Day22：Follow Along Link Highlighter","text":"javascript 30day 目標：根據滑鼠游標移動 highlight 位置一、取得 DOMconst triggers = document.querySelectorAll('a');// 取得 a 連結const highlight = document.createElement('span');// 建立highlighthighlight.classList.add('highlight');// 新增節點document.body.append(highlight);// 加到頁面中 二、更改狀態function highlightLink() &#123; const linkCoords = this.getBoundingClientRect(); // 取得 a 本身距離瀏覽器窗口的位置 const coords = &#123; width: linkCoords.width, height: linkCoords.height, top: linkCoords.top + window.scrollY, left: linkCoords.left + window.scrollX, &#125;; // 建立物件，以便存放位置訊息，因為根據 window 捲軸滑動的關係，必須加上scroll移動值。 highlight.style.width = `$&#123;coords.width&#125;px`; highlight.style.height = `$&#123;coords.height&#125;px`; highlight.style.transform = `translate($&#123;coords.left&#125;px, $&#123;coords.top&#125;px)`; // 設定效果的寬高及定位&#125;triggers.forEach(a =&gt; a.addEventListener('mouseenter', highlightLink));// 監聽所有 a 連結的滑鼠移入，觸發 highlightLink 使用技巧 getBoundingClientRect","link":"/javascript-30-day22/"},{"title":"【JS30】Day23：Speech Synthesis","text":"javascript 30day 目標：使文字轉語音，並變換音調及速率const msg = new SpeechSynthesisUtterance();let voices = [];const voicesDropdown = document.querySelector('[name=\"voice\"]');const options = document.querySelectorAll('[type=\"range\"], [name=\"text\"]');const speakButton = document.querySelector('#speak');const stopButton = document.querySelector('#stop'); 作業一開始已經先取用好 DOM。 一、取用語音要播放的文字msg.text = document.querySelector('[name=\"text\"]').value;// 使輸入欄位成為要使用的值 二、取用語系function populateVoices() &#123; voices = this.getVoices(); // 取得播放聲音的語系資訊 voicesDropdown.innerHTML = voices .map(voice =&gt; `&lt;option value=\"$&#123;voice.name&#125;\"&gt;$&#123;voice.name&#125;($&#123;voice.lang&#125;)&lt;/option&gt;`) // 取用語系資料塞進下拉選單 .join(''); // 使用 join 取消逗號&#125;speechSynthesis.addEventListener('voiceschanged', populateVoices); 三、更換選單，更換播放語系function setVoice(startOver = true) &#123; msg.voice = voices.find(voice =&gt; voice.name === this.value); // 設定輸入欄位的語音是選擇發音的語系 toggle(); // 播放&#125;function toggle(startOver = true) &#123; // 播放暫停切換 speechSynthesis.cancel(); // 停用原本的語音 if (startOver) &#123; speechSynthesis.speak(msg); &#125; // 重新播放新的語系。&#125;voicesDropdown.addEventListener('change', setVoice);// 監聽 change 事件 四、調整速度與音準，以及設定其餘監聽function setOption() &#123; msg[this.name] = this.value; // 傳入的變數與SpeechSynthesisUtterance本身的物件相同，可以直接取用 toggle();&#125;options.forEach(option =&gt; option.addEventListener('change', setOption));// 監聽音準和速率的change事件speakButton.addEventListener('click', toggle);// 監聽播放鍵stopButton.addEventListener('click', () =&gt; toggle(false));// 監聽暫停鍵 五、取用部分語系...function populateVoices() &#123; voices = this.getVoices(); // 取得播放聲音的語系資訊 voicesDropdown.innerHTML = voices .filter(voice=&gt;voice.includes('en')) .map(voice =&gt; `&lt;option value=\"$&#123;voice.name&#125;\"&gt;$&#123;voice.name&#125;($&#123;voice.lang&#125;)&lt;/option&gt;`) // 取用語系資料塞進下拉選單 .join(''); // 使用 join 取消逗號&#125;... 使用技巧 SpeechSynthesisUtterance speechSynthesis","link":"/javascript-30-day23/"},{"title":"【JS30】Day24：Sticky Nav","text":"javascript 30day 目標：偵測頁面高度固定導覽列一、取得頁面元素及偵測高度const nav = document.querySelector('#main');// 導覽列const topOfNav = nav.offsetTop;// 導覽列頂部到 top 的距離 二、新增 class 及判斷function fixNav() &#123; if (window.scrollY &gt;= topOfNav) &#123; // 假設頁面高度超過距離 document.body.classList.add('fixed-nav'); // body就增加 class &#125; else &#123; document.body.classList.remove('fixed-nav'); // 若沒有就移除 class &#125;&#125;window.addEventListener('scroll', fixNav);// 監聽滾動事件 三、新增 fixed 樣式.fixed-nav .site-wrap &#123; transform: scale(1);&#125;/* 當出現 fixed-nav ，site-wrap 縮放比改為 1 */.fixed-nav nav &#123; position: fixed; box-shadow: 0 5px rgba(0, 0, 0, 0.1);&#125;/* 當出現 fixed-nav ，把 nav 固定，並加上陰影*/.fixed-nav li.logo &#123; max-width: 500px;&#125;/* 當出現 fixed-nav ，顯示並增加 logo 寬度*/ 四、debugfunction fixNav() &#123; if (window.scrollY &gt;= topOfNav) &#123; // 假設頁面高度超過距離 document.body.paddingTop = nav.offsetHeight + 'px'; // 當 position 被設定為 fixed ，物件便會浮動固定在畫面上，所以需要動態增加 offsetHeight 的高度，避免彈跳現象。 document.body.classList.add('fixed-nav'); // body就增加 class &#125; else &#123; document.body.style.paddingTop = 0; // 若沒有就還原頁面。 document.body.classList.remove('fixed-nav'); // 若沒有就移除 class &#125;&#125; 使用技巧","link":"/javascript-30-day24/"},{"title":"【JS30】Day25：Event Capture, Propagation, Bubbling and Once","text":"javascript 30day 目標：理解事件捕捉、傳遞、氣泡，和單次執行一、事件模型&lt;div class=\"one\"&gt; 紫色 &lt;div class=\"two\"&gt; 粉色 &lt;div class=\"three\"&gt; 橘色 &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 二、建立事件點擊const divs = document.querySelectorAll('div');function logText(e) &#123; console.log(this.classList.value);&#125;divs.forEach(div =&gt; div.addEventListener('click', logText)); 當你做事件點擊的監聽，點擊到three，而two和one會被console.log出來，因為事件氣泡的關係，會不斷向外觸發所有的div元素，點擊three就會觸發two、one，點擊two，就觸發one， 事件氣泡為目標元素被監聽，點擊元素會不斷向外尋找，直到找到目標元素為止，假設監聽元素是body，那點擊three，監聽就會向外尋找，觸發順序就為three、two、one、body。 事件捕捉為不斷向內觸發，那他就會向內觸發，以此類推。 三、監聽事件的第三個參數，capture 屬性divs.forEach(div =&gt; div.addEventListener('click', logText, &#123; capture: false, // 預設為false &#125;),); 監聽事件有第三個參數，假設不輸入，預設值就為false，該監聽事件就為事件氣泡，如果輸入true，該事件就為事件捕捉。 四、stopPropagationfunction logText(e) &#123; console.log(this.classList.value); e.stopPropagation();&#125;divs.forEach(div =&gt; div.addEventListener('click', logText)); 使用stopPropagation();，就不會向外觸發父元素。 function logText(e) &#123; console.log(this.classList.value); e.stopPropagation();&#125;divs.forEach(div =&gt; div.addEventListener('click', logText, &#123; capture: true, &#125;),); 假設在事件捕捉的時候，使用stopPropagation，點擊three，會觸發one，因為事件捕捉是由外向內觸發，他會向內尋找目標元素，但因為stopPropagation的關係，觸發到最外層的one元素，便會停止事件捕捉的監聽。 三、第三個參數，once 屬性button.addEventListener( 'click', () =&gt; &#123; console.log('Click!!!'); &#125;, &#123; once: true, &#125;,); 監聽的once屬性，是監聽一次點擊事件後，就會解除對自己本身的事件綁定，所以再點擊第二次、第三次，他不會被監聽，因為在監聽第一次的時候，已經解除監聽狀態。 使用技巧 addEventListener stopPropagation","link":"/javascript-30-day25/"},{"title":"【JS30】Day26：Stripe Follow Along Nav","text":"javascript 30day 目標：滑動的次導覽列一、抓取頁面元素及建立事件const triggers = document.querySelectorAll('.cool &gt; li');// 抓取各別的選單const background = document.querySelector('.dropdownBackground');// 抓取白底部分const nav = document.querySelector('.top');// 抓取主導覽列function handleEnter() &#123; this.classList.add('trigger-enter'); // 新增 class setTimeout(() =&gt; this.classList.add('trigger-enter-active'), 150); // 0.15毫秒後新增 class background.classList.add('open'); // 新增白底樣式的 class&#125;function handleLeave() &#123; this.classList.remove('trigger-enter', 'trigger-enter-active'); background.classList.remove('open'); // 移除相關class&#125;triggers.forEach(trigger =&gt; trigger.addEventListener('mouseenter', handleEnter));triggers.forEach(trigger =&gt; trigger.addEventListener('mouseleave', handleLeave)); 事件僅有滑鼠滑入及滑出的效果， 二、新增動態效果function handleEnter() &#123; this.classList.add('trigger-enter'); // 新增 class setTimeout(() =&gt; this.classList.add('trigger-enter-active'), 150); // 0.15毫秒後新增 class background.classList.add('open'); // 新增白底樣式的 class const dropdown = this.querySelector('.dropdown'); // 取得導覽底下的下拉導覽 const dropdownCoords = dropdown.getBoundingClientRect(); // 取得下拉導覽的資訊 const navCoords = nav.getBoundingClientRect(); // 取得導覽列的資訊 const coords = &#123; height: dropdownCoords.height, width: dropdownCoords.width, top: dropdownCoords.top, left: dropdownCoords.left, &#125;; // 取得下拉導覽座標 background.style.setProperty('width', `$&#123;coords.width&#125;px`); background.style.setProperty('height', `$&#123;coords.height&#125;px`); background.style.setProperty('transform', `translate($&#123;coords.left&#125;px,$&#123;coords.top&#125;px)`); // 設定白底樣式滑入的寬高及定位&#125; 三、Debug 錯位與快速滑動function handleEnter() &#123;...... const coords = &#123; height: dropdownCoords.height, width: dropdownCoords.width, top: dropdownCoords.top - navCoords.top, left: dropdownCoords.left - navCoords.left // 減去主導覽列的定位 &#125;......&#125; 假設主導覽列上方有新增元素，則下拉導覽列會錯位，為了避免錯位，因此必須扣除掉主導覽列的定位。 setTimeout(() =&gt; this.classList.contains('trigger-enter') &amp;&amp; this.classList.add('trigger-enter-active'), 150); 為了避免快速滑動導覽列產生錯亂，因此在setTimeout上增加判斷，假設前者導覽有trigger-enter的 class，便增加trigger-enter-active，假設沒有，則會一直顯示白色導覽列的部分，內容不會被顯示出來。","link":"/javascript-30-day26/"},{"title":"【JS30】Day27：Click and Drag to Scroll","text":"javascript 30day 目標：點擊及拖曳使畫面滑動一、命名變數const slider = document.querySelector('.items');// 頁面元素let isDown = false;// 狀態變數let startX;let scrollLeft; 二、監聽事件slider.addEventListener('mousedown', () =&gt; &#123;&#125;);slider.addEventListener('mouseleave', () =&gt; &#123;&#125;);slider.addEventListener('mouseup', () =&gt; &#123;&#125;);slider.addEventListener('mousemove', () =&gt; &#123;&#125;); 分別有滑鼠按下、滑鼠離開、滑鼠放開，及滑鼠拖曳的動作。 三、滑鼠按下事件slider.addEventListener('mousedown', e =&gt; &#123; isDown = true; // 狀態變數啟用 slider.classList.add('active'); // 增加樣式 startX = e.pageX - slider.offsetLeft; // 按下的起始位置 = 頁面位置 - 目前 item 的左邊距離 scrollLeft = slider.scrollLeft; // 紀錄移動的距離量&#125;); 四、滑鼠滑動事件slider.addEventListener('mousemove', e =&gt; &#123; if (!isDown) return; // 假設非按下滑動，就不執行 e.preventDefault(); // 取消預設行為，如反白文字之類的 const x = e.pageX - slider.offsetLeft; // 紀錄目前位置 = 頁面位置 - 目前 item 的左邊距離 const walk = (x - startX) * 3; // 紀錄游標距離原本起始值的滑動距離 = (目前位置 - 起始位置)*3 slider.scrollLeft = scrollLeft - walk; // 設定水平的偏移量&#125;); 、滑鼠離開、滑鼠放開事件slider.addEventListener('mouseleave', () =&gt; &#123; isDown = false; slider.classList.remove('active'); // 取消狀態及樣式&#125;);slider.addEventListener('mouseup', () =&gt; &#123; isDown = false; slider.classList.remove('active'); // 取消狀態及樣式&#125;);","link":"/javascript-30-day27/"},{"title":"【JS30】Day28：Video Speed Controller","text":"javascript 30day 目標：滑鼠事件監聽調整速度與第 11 天的練習類似。 一、命名變數const speed = document.querySelector('.speed');const bar = document.querySelector('.speed-bar');const video = document.querySelector('.flex'); 二、監聽事件speed.addEventListener('mousemove', function(e) &#123; // 滑鼠移動事件 const y = e.pageY - this.offsetTop; // 觸發位置 = 滑鼠距離整頁頂端的 y 軸位置 - 速率條到整個頁面頂端的距離 const percent = y / this.offsetHeight; // 百分比 = 觸發位置 / 速率條的高度 const min = 0.4; const max = 4; const height = Math.round(percent * 100) + '%'; // 四捨五入百分百 const playbackRate = percent * (max - min) + min; // 計算播放速率比例 bar.textContent = playbackRate.toFixed(2) + 'x'; // 使用 toFixed 顯示小數點後兩位的速率文字 bar.style.height = height; // 顯示樣式 video.playbackRate = playbackRate; // 更改影片速率&#125;); 使用技巧","link":"/javascript-30-day28/"},{"title":"【JS30】Day29：Countdown Timer","text":"javascript 30day 目標：點擊及輸入數值倒數計時一、命名變數let countdown;// 計數器const timerDisplay = document.querySelector('.display__time-left');// 頁面元素：顯示倒數const endTime = document.querySelector('.display__end-time');// 頁面元素：顯示計數後的時間const buttons = document.querySelectorAll('[data-time]');// 計數時間按鈕 二、設定計數器function timer(seconds) &#123; clearInterval(countdown); // 重啟計數器，清除原本計數的設定 const now = Date.now(); const then = now + seconds * 1000; // 取得時間 displayTimeLeft(seconds); displayEndTime(then); // 秀出開始倒數計時的時間與結束倒數後的時間 countdown = setInterval(() =&gt; &#123; // 每秒更新一次計數器 const secondsLeft = Math.round((then - Date.now()) / 1000); // 要倒數的總時 if (secondsLeft &lt; 0) &#123; clearInterval(countdown); return; &#125; // 時間小於零，結束 setInterval displayTimeLeft(secondsLeft); // 更新秀出時間 &#125;, 1000);&#125;function displayTimeLeft(seconds) &#123; const minutes = Math.floor(seconds / 60); // 轉換分鐘數 const remainderSeconds = seconds % 60; // 用 % 取得扣除分鐘數的秒數 const display = `$&#123;minutes&#125;:$&#123;remainderSeconds &lt; 10 ? '0' : ''&#125;$&#123;remainderSeconds&#125;`; // 顯示秒數，若秒數小於10，在個位數前面補零 document.title = display; timerDisplay.textContent = display; // 顯示對應時間&#125;function displayEndTime(timestamp) &#123; // 顯示結束時間 const end = new Date(timestamp); // 取得結束的時間 const hour = end.getHours(); // 轉換成小時 const adjustedHour = hour &gt; 12 ? hour - 12 : hour; // 將24小時制轉換成12小時制 const minutes = end.getMinutes(); // 取得分鐘 endTime.textContent = `Be Back At $&#123;adjustedHour&#125;:$&#123;minutes &lt; 10 ? '0' : ''&#125;$&#123;minutes&#125;`; // 顯示結束的時間&#125; 三、設定固定倒數時間的按鈕及設定輸入倒數時間function startTimer() &#123; const seconds = parseInt(this.dataset.time); // 取得 data-time 的數值 timer(seconds); // 傳入計數器&#125;buttons.forEach(button =&gt; button.addEventListener('click', startTimer));// 遍歷按鈕並加上監聽事件document.customForm.addEventListener('submit', function(e) &#123; e.preventDefault(); // 取消 submit 跳頁的預設 const mins = this.minutes.value; // 取得 input 的分鐘數值 timer(mins * 60); // 轉換成秒數傳回計數器 this.reset(); // 傳回後清空 input&#125;);","link":"/javascript-30-day29/"},{"title":"【JS30】Day30：Whack A Mole Game","text":"javascript 30day 目標：做一個打地鼠的小遊戲一、抓取頁面元素及命名變數const holes = document.querySelectorAll('.hole');// 洞const scoreBoard = document.querySelector('.score');// 分數顯示const moles = document.querySelectorAll('.mole');// 地鼠let lastHole;// 最後一次出現的地洞let timeUP = false;// 結束遊戲時間let score = 0;// 分數 二、亂數選擇地鼠出沒的洞function randomTime(min, max) &#123; return Math.round(Math.random() * (max - min) + min); // 產生一個小數點後四捨五入的亂數時間區間&#125;function randomHole(holes) &#123; // 亂數產生地洞 const idx = Math.floor(Math.random() * holes.length); // 亂數取得地洞 const hole = holes[idx]; // 賦予 DOM if (hole === lastHole) &#123; // 避免亂數重複 return randomHole(holes); &#125; lastHole = hole; // 紀錄最後出現的地洞 return hole;&#125; 三、地鼠出沒function peep() &#123; // 地鼠出現 const time = randomTime(200, 1000); // 取得出現的時間 const hole = randomHole(holes); // 取得出現的地洞 hole.classList.add('up'); // 加上 class 出現 css 動畫效果 setTimeout(() =&gt; &#123; hole.classList.remove('up'); // 時間到移除 css 動畫 if (!timeUp) peep(); // 遊戲時間未結束 跑出下一隻地鼠 &#125;, time);&#125; 四、遊戲開始及打擊地鼠function startGame() &#123; timeUp = false; // 時間重置 scoreBoard.textContent = 0; score = 0; // 分數表初始化 peep(); // 執行地鼠出現 setTimeout(() =&gt; (timeUp = true), 10000); // 十秒後時間結束&#125;function bonk(e) &#123; if (!e.isTrusted) return; // 防止腳本操作 score++; // 加分 this.classList.remove('up'); // 移除 css 動畫 scoreBoard.textContent = score; // 更新分數&#125;moles.forEach(mole =&gt; mole.addEventListener('click', bonk));//監聽每隻地鼠綁定 bonk 函式","link":"/javascript-30-day30/"},{"title":"【讀書筆記】圖解 HTTP Chapter 01 了解 Web 及網路基礎","text":"當在網頁瀏覽器輸入網址之後，瀏覽器會向伺服器請求該網址的資源，並顯示網頁。發送請求取得伺服器資料的網頁瀏覽器，都可以稱為客戶端。 網頁是透過 HTTP 協議完成傳送資料的流程。 使用 HTTP 協議訪問 Web當在網頁瀏覽器輸入網址之後，瀏覽器會向伺服器請求該網址的資源，並顯示網頁。發送請求取得伺服器資料的網頁瀏覽器，都可以稱為客戶端。 網頁是透過 HTTP 協議完成傳送資料的流程。 HTTP 的誕生 HTTP / 1.0：初期標準，現在仍然被廣泛使用。 HTTP / 1.1：目前主流的 HTTP 協議版本，主要是要解決文字傳輸的困難。 TCP / IP目前所使用的網路都是在 TCP / IP 協議的基礎上運作，而 HTTP 是屬於內部的一個子集。 TCP / IP 協議什麼是協議：電腦與網路要互相連接，必須要在連接前確定一些規則才能達成，像是使用哪種語言、如何偵測連結、如何結束等等，而這些規則就稱為協議。 TCP / IP 就是跟網路連接有關的所有協議的統稱。 有人認為 TCP / IP 是在說 TCP 協議與 IP 協議，也有人認為 TCP / IP 是在 IP 協議的連結過程中，所使用到的協議統稱。 TCP / IP 分層管理TCP / IP 分為四層： 應用層：提供為應用軟體而設的埠，以設定與另一應用軟體之間的通訊。例如：HTTP、FTP、DNS 等等 傳輸層：提供兩台有網路連接的電腦之間的資料傳輸。當中有 TCP 和 UDP。 網路層：定義網路路由和地址，讓資料可以在網路之間傳遞，資料在傳輸時，協議會把 IP 地址加到傳輸資料內組成封包，又稱「IP 層」。 資料連結層：處理網路連接硬體的部分（MAC 地址也處於這層）。 TCP / IP 通訊傳輸流兩台電腦在進行網路連接時，會通過分層的順序連接。發送端會從應用層逐步走到資料連結層，而接收端會從資料連結層向回走到應用層。 發送端在各層傳輸資料時，經過一層就會在該層增加一個 header 資料，接收端接受後每經過一層，就會消除一層，這樣分層的好處是當協議需要改變時，只要將有變動的那層替換就可以了。 與 HTTP 關係密切的協議：IP、TCP 和 DNS負責傳輸的 IP 協議有些人會把 IP 跟 IP 位址搞錯。 IP 協議的作用是把封包傳送給對方，這需要很多條件，其中重要的兩個條件是 IP 位置和 MAC 。 IP 位置是指節點被分配到的位置，而 MAC 是指網卡上獨特的序號，IP 位置可以跟 MAC 配對，IP 是不固定的，而 MAC 是網卡獨特的序號，是不會改變的。 IP 之間的連接是依賴 MAC 。 網路上兩台電腦的連接通常是藉由多台電腦和網路設備轉接，才連接到對方，而在連接時會利用下一站轉接設備的 MAC 來找到這個轉接的目標，這時候會使用 ARP 協議，ARP 協議是一種解析位置的協議，他會根據連接那端的 IP 位置來反查對應的 MAC。 在到達最後要連結到的目標之前，這中間過程的轉運站，通常叫做路由。 確保可靠性的 TCP 協議為了方便管理，TCP 的功能是把資料流分割成適當長度的訊息段落，並且確認是否有把資料成功傳給對方。 TCP 協議採用了三向交握（three-way handshaking）策略，意思就是三次訊息的交換，當中會使用 TCP 的註記標誌——SYN、ACK。發送端會先送一個帶有 SYN 標記的封包給對方，接收端收到之後會發送一個帶有 SYN、ACK 標記的封包回去，最後發送端再送一個帶有 ACK 標記的封包，這樣表示訊息傳送完成。 負責域名解析的 DNS 服務DNS 跟 HTTP 一樣在應用層，提供了域名到 IP 之間的解析服務。電腦既然可以有 IP 位置，也可以有主機名稱和域名。例如：www.codingwife.com。 一般人在訪問別人的主機通常都是用域名，而不是 IP 位置，因為 IP 比較不符合一般人能記憶的模式。DNS 協議提供通過域名來查找 IP 位置，或是反向從 IP 位置來找域名。 各協議與 HTTP 協議的關係 客戶端：訪問 www.codingwife.com。 DNS：查找對應的 IP 位置 發送到伺服器端 HTTP：生對目標伺服器的 HTTP 請求訊息 TCP：把訊息分割成封包，確認每個封包都傳送給對方 IP：查找對方的位置，一邊轉運、一邊傳送。（路由器） TCP：從對方那裡接收到封包並重組。 HTTP：對請求的內容進行處理。 請求的處理結果也是透過 TCP / IP 通訊協定回傳。 URI 與 URLURI（Uniform Resource Identifier）統一資源標識符。 以https://codingwife.com/2018/10/16/2018ithome/day01/為例： https://：協議名稱，Identifier 來表示定位標示符。codingwife.com：域名。/2018/10/16/2018ithome/day01/：路徑。 資料來源：《圖解 HTTP》 上野宣 人民郵電出版社筆記純屬推廣及分享，如有侵權，請告知。Please advise to remove immediately if any infringement caused.","link":"/graphic-http-chapter01/"},{"title":"【讀書筆記】圖解 HTTP Chapter 02 簡單的 HTTP 協議","text":"請求訪問文字或圖像等資料一端稱為客戶端；提供資料的一端稱為伺服器端。 HTTP 協議用於客戶端和伺服端之間的通訊請求訪問文字或圖像等資料一端稱為客戶端；提供資料的一端稱為伺服器端。 通過請求和回應的交換達成通訊請求必定為客戶端發出，最後伺服器端回應資料，換言之，請求一定是客戶端率先發起，在那之前伺服器端不會有動作。 請求訊息的構成： 請求方法：訪問伺服器的類型 請求 URI 字串：請求訪問的相關資料 HTTP/1.1：客戶端使用的 HTTP 協議。 請求 header 請求 body 伺服器端的回應： 協議版本 HTTP 狀態碼 狀態碼原因 回應 header 回應 body HTTP 是無狀態協議HTTP 是無狀態協議，意思就是 HTTP 本身對於不對請求和回應的狀態做保留，也不做持久連接。 使用 HTTP 協議，每次有新的請求發送，就會有對應的回應，這樣是為了能更快速大量的處理資料，但如今也遇到了問題，假設我們在一個購物網站登入，我們會希望他在這個網站的其他頁面也保持登錄的狀態，因此引入了 Cookie 的技術。 請求 URI 定位資源當客戶端使用 URI 發送請求，HTTP 也將請求的 URI 放入請求訊息中。如果不是特別請求一個特定的資料，可以用 * 來替代請求 URI 。 告知伺服器意圖的 HTTP 方法HTTP / 1.1 可使用的方法：GET：獲取資料。請求展示指定資源，僅有請求資源。POST：提交指定資源實體，通常會改變伺服器的狀態或副作用。PUT：傳輸文件，文件存在請求訊息的 Body 中，傳送到指定的 URI 的位置。DELETE：刪除文件，請求 URI 刪除特定的資源。HEAD：與 GET 相同，但不回傳訊息 Body 的部分。OPTION：查詢該 URI 支援的資料溝通方法。TRACE：指定資源標明的伺服器之間，執行迴路返回測試。 發送請求時：會在 Max-Forwards 填入數值，每經過一個代理伺服器數值就-1，而剛好到 0 的時候就停止傳輸，最後接收到請求的伺服器就回傳 200 的 http code。CONNECT：會利用請求資源與代理伺服器啟動一個雙向通訊。 使用方法下達命令客戶端向 URI 發送請求，採用稱為方法的命令。 持久連接節省通訊量在 HTTP 協議的初始版本中，每進行一次通訊就要斷開一次 TCP 連接，當時都是容量小的資料，但如今的狀況，這樣做十分消耗通訊成本。 持久連接為了解決上述問題，HTTP / 1.1 和部分 HTTP / 1.0 想出了持久連接（HTTP persistent connection）的辦法，只要任何一端沒有提出要斷開連接，就保持 TCP 狀態。 如此減少了 TCP 重複建立和斷開的成本，減輕伺服器端的負擔，頁面的顯示也更加快速。 管線化以前的技術是每發出一個請求，需要接受到回應後，才能進行下一個請求，而管線化是將多個 HTTP 請求整批送出的技術，而在傳送過程中不需先等待伺服端的回應，可以在等待的過程中發出下一個請求。 使用 Cookie 的狀態管理在提到 HTTP 是無狀態協議的時候有講到 Cookie ，Cookie 就是在請求和回應的訊息中寫入 Cookie 的訊息來控制客戶端的狀態。 客戶端請求 伺服端會在發送回應訊息中 Header 的 Set-Cookie 欄位填入 Cookie 的訊息通知客戶端保存 Cookie 值。 客戶端再發送請求的時候會自動在請求訊息中的 Header 加入 Cookie 值。 伺服端發現客戶端送來的 Cookie 值，比對伺服器的紀錄，最後得到之前的狀態紀錄。 資料來源：《圖解 HTTP》 上野宣 人民郵電出版社筆記純屬推廣及分享，如有侵權，請告知。Please advise to remove immediately if any infringement caused.","link":"/graphic-http-chapter02/"},{"title":"【讀書筆記】圖解 HTTP Chapter 03 HTTP 訊息內的 HTTP 訊息","text":"訊息分為兩部分，Header 跟 Body。 HTTP 訊息訊息分為兩部分，Header 跟 Body。 HTTP 請求訊息與回應訊息結構客戶端發送為請求訊息，伺服端有回應訊息。 請求訊息的 Header： 請求列：包含請求方法，請求 URI 和 HTTP 協議版本。 請求 Header 回應訊息的 Header： 狀態列：回應結果的狀態碼，原因字串和 HTTP 協議版本。 回應 Header 共同部分： 通用 Header 實體 Header 編碼提升傳輸速率HTTP 在傳輸資料可以直接傳輸或透過編碼來提升速率，透過編碼可以大量處理請求訪問，但編碼需要電腦來完成，因此會消耗更多效能。 訊息主體和實體主體的差異 訊息：HTTP 通訊的基本單位，以八位元組成。 實體：請求或回應的補充數據，內容是有 Header 和 Body 組成。 壓縮傳輸的內容編碼在發 email 需要夾帶檔案，我們會將其檔案壓縮。HTTP 協議中有一種被稱為內容編碼的功能，指名應用在實體內容的編碼格式，保持訊息原本的壓縮，伺服端內容編碼後，由客戶端接收並解碼。 常用的內容編碼： gzip compress deflate identity 分割發送的分塊傳輸編碼HTTP 協議在傳訊息的過程中，請求的資料還沒全部被傳送完，瀏覽器沒辦法顯示請求頁面。在傳送大容量資料的時候會把資料分割成多塊，這樣才能讓瀏覽器逐步顯示，稱之為分塊傳輸編碼。 分塊傳輸編碼會將 Body 分割成多塊，並以十六進制來標記大小，一樣由客戶端進行解碼恢復到原本檔案的樣子。 發送多種資料的多物件集合發送郵件可以在郵件裡面寫文字和夾帶多個檔案，因為採用了 MIME 機制，允許郵件處理多個不同類型的檔案。比如圖片是使用 ASCII 碼的字串編碼標示，利用 MIME 來描述資料類型，而 MIME 會用一種多部分物件集合（multipart） 方法來容納不同類型的資料。 multipart / form-data：在網頁表單文件上傳時使用。 multipart / byteranges：狀態碼 206，回應訊息的 Body 包含請求資料的數據區間。 獲取部分內容的範圍請求以前如果下載一個大容量的圖片，只要被中斷了就要重新載入，為了解決這個問題需要一個可以恢復的機制，這種恢復機制是從上次的中斷點再開始恢復下載。 要實作這個需要指定下載的範圍，指定範圍發送的請求叫做範圍請求。 內容協商回傳最適合的內容一個網站可能存在很多相同內容的頁面，例如中英文版網站，以瀏覽器默認語言為主，訪問 URI 的網頁會顯示對應語言的頁面，這樣稱之為內容協商。 內容協商機制指客戶端和伺服端就回應的內容進行交涉，然後給客戶端最適合的資料，內容協商會以回應資源的語言、字串等等為判斷基準。 內容協商的技術有三種： 伺服器驅動協商：以請求 header 為參考，篩選最好的內容。 客戶端驅動協商：從瀏覽器顯示的可選項中手動選擇。 透明協商：結合體。 資料來源：《圖解 HTTP》 上野宣 人民郵電出版社筆記純屬推廣及分享，如有侵權，請告知。Please advise to remove immediately if any infringement caused.","link":"/graphic-http-chapter03/"},{"title":"【讀書筆記】圖解 HTTP Chapter 04 返回結果的 HTTP 狀態碼","text":"狀態碼是當客戶端對伺服端發送請求後，伺服端敘述回傳請求結果的狀態，狀態碼為三位數字組成。 狀態碼告知伺服端返回的請求結果狀態碼是當客戶端對伺服端發送請求後，伺服端敘述回傳請求結果的狀態，狀態碼為三位數字組成。 1XX 訊息狀態：正在處理請求 2XX 成功狀態：請求正常處理完成 3XX 重新導向狀態：需要進行其他行為來完成請求動作 4XX 客戶端錯誤狀態：伺服器無法處理請求 5XX 伺服端錯誤狀態：伺服器處理請求中錯誤 2XX 成功200 OK請求被正常處理。回傳的詳細訊息會根據方法不同而改變。 204 No Content請求成功，但無資料回傳。在回應的訊息內沒有 Body 的部分。 206 Partial Content表示客戶端做範圍請求，而伺服端成功回傳 GET 請求。回傳訊息包含 Content-Range 指定範圍 Body 部分。 3XX 重新導向301 Moved Permanently永久重新導向，表示請求的資料已經被分配到新的 URI ，應該重新儲存新的 URI。 302 Found臨時重新導向，表示已經被分配到新的 URI，希望這次能使用新的 URI 訪問。如果不為 GET 或 HEAD 請求，瀏覽器禁止重新導向，必須和客戶端確認是否重發請求。 303 See Other請求對應的資料存在另一個 URI，明確指明應該使用 GET 方法請求資料。 304 Not Modified表示客戶端發送附有條件的請求，伺服端允許被訪問，但沒被滿足條件。 307 Temporary Redirect臨時重新導向，表示已經被分配到新的 URI，和 302 的差異是當收到狀態碼後，客戶端應保持請求方法不變向新的地址發出請求。 4XX 客戶端錯誤400 Bad Request請求訊息有語法錯誤，需修正完後重新請求。 401 Unauthorized發送的請求需要有 HTTP 認證，伺服器驗證已被拒絕。 當網站（通常是網站域名）禁止 IP 位址時，有些網站狀態碼顯示的 401，表示該特定位址被拒絕存取網站。—— wikipedia 403 Forbidden伺服器拒絕請求訪問。 404 Not Found無法找到請求資源。 5XX 伺服端錯誤500 Internal Server Error伺服器在執行請求發生錯誤。 503 Service Unavailable伺服器超過負載或正在進行停機維護，無法處理請求。 資料來源：《圖解 HTTP》 上野宣 人民郵電出版社筆記純屬推廣及分享，如有侵權，請告知。Please advise to remove immediately if any infringement caused.","link":"/graphic-http-chapter04/"},{"title":"【讀書筆記】圖解 HTTP Chapter 05 與 HTTP 協作的網頁伺服器","text":"HTTP / 1.1 開始允許一台伺服器可以建立多個網頁站點。例如：提供網頁寄存服務的公司可以用一台伺服器幫多個客戶服務，以每個客戶持有的域名運作各自的網站，這是利用虛擬主機的關係。 在網路上域名通過 DNS 來進行域名解析，關聯到 IP 地址再訪問目標網站。如果一台伺服器寄存了兩個域名，當收到請求的時候就要知道需要訪問哪個域名。 在一樣 IP 地址下，由於虛擬主機可以寄存不同主機名和域名的 URI，在發送請求時，必須在 host 首部內完整指定主機名稱與 URI。 用單台虛擬主機實作多個域名HTTP / 1.1 開始允許一台伺服器可以建立多個網頁站點。例如：提供網頁寄存服務的公司可以用一台伺服器幫多個客戶服務，以每個客戶持有的域名運作各自的網站，這是利用虛擬主機的關係。 在網路上域名通過 DNS 來進行域名解析，關聯到 IP 地址再訪問目標網站。如果一台伺服器寄存了兩個域名，當收到請求的時候就要知道需要訪問哪個域名。 在一樣 IP 地址下，由於虛擬主機可以寄存不同主機名和域名的 URI，在發送請求時，必須在 host 首部內完整指定主機名稱與 URI。 通訊資料轉發順序：代理、閘道、隧道HTTP 通訊，除了客戶端和伺服端外，還有一些用於通訊資料轉發的程式，例如：代理、閘道、隧道。他們可以將請求轉發給通訊線路上的下一站伺服器，並可以接收從那台伺服器發送的回應再轉發給客戶端。 代理代理是處理轉發的一種程式，他算是伺服端與客戶端的中介站，接收客戶端的請求再轉發給伺服端，也接收伺服端的回應給客戶端。 閘道轉發其他伺服器資料的伺服器，接收從客戶端發出的請求時，他就像擁有資料一樣對請求進行處理，有時候客戶端不會知道自己發出的對象是個閘道。 隧道隧道是在隔很遠的客戶端和伺服器兩者的中間進行中轉，以保持通訊連接。 代理代理在接收請求後轉發給其他的伺服器，代理不會改變請求的 URI，會直接轉發給前方持有資源的伺服器，而真正持有資源的伺服器叫做來源伺服器，再從來源伺服器回傳回應，經過代理伺服器再到客戶端。 每次經過代理伺服器轉發請求或回應，會追加 Via header 訊息來標示經過的主機訊息。在通訊的過程中，可以串連多台代理伺服器，請求和回應會像鍊子一樣被連接起來。 什麼時候要使用代理伺服器？利用緩存減少網路頻寬的流量，針對特定網站的請求控制等等。 代理有兩種方式，分為是否使用緩存跟是否修改訊息： 緩存代理：代理轉發回應時，緩存代理會預先將資料緩存在代理伺服器上，當再接收請求時，就可以不用再對來源伺服器那邊取得資料，而是使用保留在代理伺服器上的資料當作回應回傳。 透明代理：轉發請求或回覆時，不對訊息做任何加工處理稱為透明代理，反之稱為非透明代理。 閘道閘道和代理非常相似，而閘道可以提供通訊線路上非 HTTP 的服務，利用閘道可以提供通訊的安全性，因此可以在客戶端與閘道之間進行加密，例如閘道連接資料庫使用 SQL 語法來查詢資料，另外在購物網站上做信用卡結算時，閘道可以和信用卡系統做連動。 隧道隧道可以依照需求建立與其他伺服器的通訊線路，到時候可以用 SSL 加密進行通訊，隧道主要是能確保客戶端和伺服端進行安全的通訊，隧道不會去解析 HTTP 請求，也就是保持原本的請求中轉給伺服器，隧道會在雙方斷開連結的時候結束。 保存資訊的緩存緩存是指代理伺服器和客戶端本地硬碟保存的資料副本，利用緩存可以減少對來源伺服器的訪問，也就節省了流量和時間。 緩存伺服器是代理伺服器的一種，歸類在緩存代理中，意思就是說當代理轉發從伺服器的回應時，代理伺服器會保存一份資料的複製。 緩存伺服器可以利用緩存避免多次從來源伺服器轉發資料，因此客戶端可就近從緩存伺服器取得資料，而來源伺服器也不用多次處理相同請求。 緩存的有效期限即使緩存伺服器裡面有緩存，也不能保證每次都會返回一樣的資料的請求，因為這關係到緩存資料的有效性。當來源伺服器上的資料更新，如果緩存還是一樣，那就會演變成回傳到舊資料。 即使有緩存，也會因為客戶端的要求、緩存等因素像來源伺服器確認資料的有效性，如果判斷緩存失效，就會再次向來源伺服器取得新資料。 客戶端的緩存緩存可以存在伺服器，也可以存在客戶端的瀏覽器，如果瀏覽器有緩存就不需要再跟伺服器請求相同的資料，可以直接在本地端讀取，再來當判定緩存過期之後，會再跟來源伺服器確認資料的有效性，但判斷失效，瀏覽器會在請求資料。 在 HTTP 以前的協議 FTP NNTP Archie WAIS Gopher 資料來源：《圖解 HTTP》 上野宣 人民郵電出版社筆記純屬推廣及分享，如有侵權，請告知。Please advise to remove immediately if any infringement caused.","link":"/graphic-http-chapter05/"},{"title":"【讀書筆記】圖解 HTTP Chapter 06 HTTP 首部（上）","text":"HTTP 協議的請求和回應一定含有 http header，客戶端和伺服端的 header 內容，針對處理請求和回應有所不同。請求 header 大部分都不需要親自查看。 HTTP 訊息的 headerHTTP 協議的請求和回應一定含有 http header，客戶端和伺服端的 header 內容，針對處理請求和回應有所不同。請求 header 大部分都不需要親自查看。 請求 header 請求列 請求 header 通用 header 實體 header 回應 header 狀態列 回應 header 通用 header 實體 header HTTP 首部字段結構由字串和值來形成，例如： Content-type: text/html 也有可能一個字串配多個值，例如： Keep-Alive: timeout=15, max=100 字串類型 通用 header：請求訊息和回應訊息都會用的 header 請求 header：從客戶端對伺服端發出請求訊息所使用的，包含補充請求的附加內容、客戶端訊息等等 回應 header：從伺服器端回傳給客戶端所需要的，包含回應附加內容，也會要求客戶端附加額外的訊息內容 實體 header：針對請求和回應訊息的實體使用，包含要補充的資料內容、更新時間等等 HTTP/1.1 header 字串一覽HTTP/1.1 規範了 47 種字串。 通用 header Cache-Control：控制緩存行為 Connetion：逐跳 header、連接的管理 Date：創建日期 Pragma：訊息指令 Trailer：訊息尾端的 header 一覽 Transfer-Encoding：指定訊息主體的傳輸編碼方式 Upgrade：升級為其他協議 Via：代理伺服器相關訊息 Warning：錯誤通知 請求 header Accept：用戶代理可處理的媒體類型 Accept-Charset：優先的字串集 Accept-Encoding：優先的內容編碼 Accept-Language：優先的自然語言 Authorization：網頁認證訊息 Expect：期待伺服器的特定行為 Form：用戶的電子信箱地址 Host：請求資料的伺服器位置 If-Match：比較實體標記（ETag） If-Modified-Since：比較資料更新時間 If-None-Match：比較實體標記（與 If-Match 相反） If-Range：資料未更新時發送的實體 Byte 的範圍請求 If-Unmodified-Since：比較資料更新時間（與 If-Modified-Since 相反） Max-Forwards：最大傳輸逐格跳 Proxy-Authorization：代理伺服器要求客戶端的認證訊息 Range：實體的字串範圍請求 Referer：對請求的 URI 的原始獲得方 TE：傳輸編碼的優先級 User-Agent：HTTP 客戶端程式訊息 回應 header Accept-Range：是否接受字串範圍請求 Age：推算資料建立時間 Etag：資料匹配訊息 Location：讓客戶端重新導向的 URI Proxy-Authenticate：代理伺服器對客戶端的認證訊息 Retry-After：對再次發請求的時機要求 Server：HTTP 伺服器的安裝訊息 Vary：代理伺服器緩存的認證訊息 WWW-Authenticate：伺服器對客戶端的認證訊息 實體 header Allow：資料可支援的 HTTP 方式 Content-Encoding：實體適用的編碼方式 Content-Language：實體的自然語言 Content-Length：實體的大小（字元） Content-Location：代替對應資料的 URI Content-MD5：實體的訊息摘要 Content-Range：實體的位置範圍 Content-Type：實體的媒體類型 Expires：實體過期日期時間 Last-Modified：資料最後修改日期時間 非 HTTP/1.1 的首部字串HTTP 所使用的字串，不限於 RFC2616 定義的 47 種，還有 Cookie、Set-Cookie 和 Content-Desposition 等等。 End-to-end header 和 Hop-by-hop headerHTTP header 定義成緩存代理和非緩存代理兩種類型： End-to-end header：分在此類的 header 會轉發給請求 / 回應對應的最後接收目標，且必須保存由緩存所產生的回應中，另外規定他必須要被轉發。 Hop-by-hop header：分在此類的 header 只會對單次的轉發有效，會因為緩存或代理的關係而不再需要被轉發，HTTP/1.1 和之後的版本，如果要用此類型，需要提供 Connection header 字串。 以下除了這八個 header 字串之外，其他都算 End-to-end header 字串： Connection Keep-Alive Proxy-Authenticate Trailer TE Transfer-Encoding Upgrade 資料來源：《圖解 HTTP》 上野宣 人民郵電出版社筆記純屬推廣及分享，如有侵權，請告知。Please advise to remove immediately if any infringement caused.","link":"/graphic-http-chapter06-1/"},{"title":"【讀書筆記】圖解 HTTP Chapter 06 HTTP 首部（中）","text":"HTTP / 1.1 通用首部字串就是雙方都會用到的字串。 HTTP / 1.1 通用首部字串就是雙方都會用到的字串。 Cache-ControlCache-Control: private, max-age=0, no-cache 操作緩存的工作，多個指令可以透過逗點分隔。 客戶端：請求緩存伺服端：控制緩存資料 緩存請求指令表 no-cache：（無參數）強制跟來源伺服器再認證 no-store：（無參數）不緩存請求或回應任何內容 max-age = [ 秒]：（必須）回應的最大 age 值 max-stale(= [ 秒])：（可省略）接收已過期的回應 min-fresh：（必須）希望在限定時間內的回應能有效 no-transform：（無參數）代理不可更改的媒介類型 only-if-cached：（無參數）從緩存取得資料 cache-extension：新指令標記 緩存回應指令表 public：（無參數）可向任意一方提供任何緩存 private：（可省略）謹向特別用戶回傳回應資料 no-cache：（可省略）緩存前必須確認有效性 no-store：（無參數）不緩存請求或回應內容 no-transform：（無參數）代理不可以更改媒體類型 must-revalidate：（無參數）可緩存，但必須向來源伺服器再次確認 proxy-revalidate：（無參數）要求中間的緩存伺服器對緩存的回應有效性進行再次確認 max-age = [ 秒]：（必須）回傳最大的 age 值 s-maxage = [ 秒]：（必須）公共緩存伺服器最大的 age 值 cache-extension：新指令標記 public 指令表示其他用戶可以利用緩存。 Cache-Control: public private 指令與 public 相反，只回應資料給特定用戶，其他人則不會回傳資料。 Cache-Control: private no-cache 指令Cache-Control: no-cache 為了防止從緩存資料裡面回傳過期的資料。 如果客戶端有包含 no-cache 指令，則表示客戶端不會接受緩存過的回應，因此必須把客戶端的請求轉發到來源伺服器。 如果伺服端有包含 no-cache 指令，則緩存伺服器不能對資料進行緩存，瀏覽器以後也不能再對緩存伺服器請求中提出資料是否有效的確認，也禁止對回應資料做緩存。 Cache-Control: no-cache=Location 由伺服端回傳的回應中，訊息中的 header 的 Cache-Control 如果在 no-cache 字串指定參數，客戶端在接收這個被指定的參數值所對應的回應訊息後，就不能進行緩存，換句話說就是沒有參數值的 header 字串可以進行緩存。 控制可以進行緩存的物件的指令no-store 指令Cache-Control: no-store 當使用這個指令，暗示這段通訊（請求或回應）包含機密訊息。有些人以為no-cache是不緩存，但其實是不緩存過期資源，而no-store才是真的不緩存。 因此這個指令規定不能在本地儲存請求或回應中的任何一部份。 指定緩存期限和認證指令s-maxage 指令Cache-Control: s-maxage=604800(秒) 這個指令和等等要介紹的max-age指令一樣，差別在於s-maxage只適合給多個使用者使用的公共緩存伺服器，換句話說對於單一使用者重複回應的伺服器來說這個指令是沒用的。 另外使用這個指令會忽略Expires指令和max-age指令。 max-age 指令Cache-Control: max-age=604800(秒) 當客戶端發出的請求有這個指令，如果判定緩存資料的緩存時間比指定的時間數更小，那麼客戶端就會接收緩存的資源，如果指定數值是 0，那緩存伺服器就會把請求轉給來源伺服器。 當伺服器回傳的回應有這個指令，緩存就不會確認資料是否還具有有效性，而這個指令的數值是代表這個資料能夠緩存的最長時間。 HTTP / 1.1 版本的緩存服務遇到同時存在Expires指令的情快，會優先處理max-age指令，而忽略Expires指令，但 HTTP / 1.0 則完全相反。 min-fresh 指令Cache-Control: min-fresh=60(秒) 這個指定是指說當發出請求後，指定的時間過後的資料都沒辦法再進行回應。以上述來說min-fresh=60是指過超過了 60 秒的資料都沒辦法當作回應回傳。 max-stale 指令Cache-Control: max-stale=360(秒) 使用這個指令就算資料已經過期了，還是可以進行緩存。 如果指令中沒有參數，則表示不管資料過期多久，客戶端都會收到回應；如果有具體數字，那個即使過期，只要在這個指定的時間內，仍然會被客戶端所接收。 only-if-cached 指令Cache-Control: only-if-cached 使用這個指令意思是發生請求後，緩存伺服器會不斷載入來源伺服器的回應，也不會重複確認資料的有效性，如果發生請求緩存伺服器，而緩存伺服器的本地沒有來源伺服器給的資料，就會發出 504。 must-revalidate 指令使用這個指令，代理會向來源伺服器再驗證要回傳的回應緩存資料是否有效，如果代理無法透過來源伺服器再次拿到有效的資料，那麼代理就會回傳 504 給客戶端。 另外使用這個指令也會忽略max-stale的請求。 proxy-revalidate 指令這個指令意思是，如果客戶端傳出帶有這個指令的請求，那麼緩存伺服器在回傳回應資料前，要先再驗證資料的有效性。 no-transform 指令使用這個指令無論在請求或是回應，緩存都不能改變實體的媒體類型，這樣可以防止緩存或代理壓縮圖片等等。 Cache-Contorl 擴展cache-extension tokenCache-Control: private, community=&quot;UCI&quot; ConnectionConnection header 字串有兩個功能： 控制不再轉發給代理的 header：在客戶端發送請求和伺服器回傳回應，使用 Connection 可以控制不要再轉發給代理 header（hop-by-hop）。 管理持久連接：HTTP / 1.1 的默認連接都是持久，所以客戶端會在持久連結上持續發送請求，當伺服端要斷開連結時，就會指名 Connection 為 close。 Connection: Keep-Alive Http / 1.1 之前的版本默認連結都不是持久連結，所以需要指定 Connection 是 Keep-Alive。 Date建立 HTTP 訊息的時間和日期，1.1 的版本使用 RFC1123 規定的日期時間格式： Date: Tue, 03 Jul 2012 04:40:59 GMT PragmaPragma 是為了向後兼容而存在，它只支援 HTTP/1.0 的緩存伺服器，因為當時 HTTP / 1.1 的 Cache-Control 還沒有支援。雖然是通用 header ，但只用在客戶端發送的請求，客戶端會要求所有中介的伺服器不回傳緩存資料。 如果都使用 HTTP / 1.1 版本，那直接使用Cache-Control: no-cache 是最好，但仍有些無法版本沒有支援，所以發送的請求最好如下： Cache-Control: no-cachePragma: no-cache TrailerTrailer 的作用是讓發送端在分塊發送的訊息後面增加其他訊息。 Transfer-EncodingTransfer-Encoding 的作用是規定傳送的 HTTP 訊息是採用哪個編碼方式。 Upgrade這個字串是用來檢測 HTTP 協議與其他協議是否可以用更新的版本來通訊，參數可以用來指定不同的通訊版本。 Connection: UpgradeUpgrade: TLS/1.0 Connection 要設定為 Upgrade，才能使用 Upgrade 字串。 ViaVia 是為了要追蹤客戶端與伺服端之間的請求（回應）的 HTTP 訊息傳輸路徑而存在，另外還能避免回環的狀況。 當訊息經過代理或閘道，會加上 Via header，再進行轉發，這個和 traceroute 與 Received header 的工作模式很像。 通常使用 Via 會和 Trace 方法一起使用，例如代理伺服器收到 Trace 方法（Max-Forwards: 0）傳來的請求，代理就不能再轉發這個請求，如此代理會把自己的訊息加上 Via header 再回傳請求要求的回應。 Warning這個字串會告知使用者一些與緩存相關的問題警告，HTTP 1.1 制定了七種警告，警告具有擴展性，未來還有可能再新增。 110 - Response is stale：代理回傳的資料已經過期。 111 - Revalidate failed：代理再驗證後，資料有效性失效。 112 - Disconnection operation：代理與網路被蓄意切斷。 113 - Heuristic expiration：回應使用期間已經超過 24 小時。 199 - Miscellaneous warning：任何警告內容。 214 - Transformation applied：代理對內容編碼或媒體類型進行處理。 299 - Miscellaneous persistent warning：任意警告內容。 資料來源：《圖解 HTTP》 上野宣 人民郵電出版社筆記純屬推廣及分享，如有侵權，請告知。Please advise to remove immediately if any infringement caused.","link":"/graphic-http-chapter06-2/"},{"title":"【讀書筆記】圖解 HTTP Chapter 06 HTTP 首部（下）","text":"請求首部字段請求 header 就是客戶端發送 http 訊息給伺服端所要補充的附加訊息。 請求首部字段請求 header 就是客戶端發送 http 訊息給伺服端所要補充的附加訊息。 AcceptAccept: text/html, application/xhtml+xml... 這個字串可以告訴伺服器，客戶端需要能處理的媒體類型和相對的優先順序。使用的是 type/subtype 型式，可以一次指定多種媒體的方式。 文字文件 text/html, text/plain, text/css … 圖片文件 images/jpeg, image/gif … 影音文件 video/mpeg, video/quicktime … 應用程序所使用的二進制文件 application/zip … 如果需要優先順序，使用 q= 來表示權重，範圍是0~1，可細分至小數點後三位，並用分號分隔，默認權重是 q=1.0。 Accept-CharsetAccept-Charset: iso-8859-5, unicode1-1;q=0.8 這個字串用來通知伺服器客戶端所支援的字串集，及相對順序，一樣可以使用 q 值來表示優先順序。 Accept-EncodingAccept-Charset: gzip, deflate 這個字串用來通知伺服器客戶端所支援的編碼，及相對順序，可以一次指定多種編碼。 Accept-LanguageAccept-Language: zh-cn,zh;q=0.7 這個字串用來通知伺服器客戶端所支援的語言，及相對優先順序，一樣可以使用 q 值來表示優先順序。 AuthorizationAuthorization: Basic dWVde3fs.. 這個字串通常是還告訴伺服器，用戶代理的認證訊息。通常想要通過伺服器的用戶代理收到回傳的 401 狀態碼之後，會把Authorization 加入請求中。共用緩存在接收到 Authorization 的請求操作會有所差異。 ExpectExpect: 100-continue 用戶端用此字串來告訴伺服端，希望伺服端做出某種特別的行為，如果伺服端無法達成就會回傳 417 狀態碼。 FormForm: info@hacker.jp 這個字串用來告知伺服器用戶代理的用戶電子郵件地址。通常是為了顯示搜尋引擎等的用戶代理負責人的電子郵件聯繫方式，使用代理時盡量用這個字串，但可能因為代理不同而顯示在 User-Agent 中。 Host這個字串會告訴伺服器，請求的資料所在的網路主機名稱和埠號，在 Http/1.1 中是唯一一個必須要包含在內的字串部。 Host 對於單台伺服器分配多個域名的虛擬主機工作機制有很密切的關係。請求被發送到伺服器時，請求的主機名會用 IP 位置來替換處理，如果相同 IP 位置下部署多個域名，那個伺服器就會無法了解是哪個對應的域名做請求，因此就需要 host 來指出請求的主機名稱。 If-Match像是以If-開頭的請求字串，皆為條件請求，伺服器接收到附帶條件請求後，只有判斷的條件為真才會執行請求。 If-Match: &quot;12345&quot; 這個字串會先告訴伺服器 ETag 值，當值與伺服器的相同才會執行請求，如果不同就會回傳 412 狀態碼。 還可以使用星號(*) 指定 If-Match 字串，這時候就會忽略 ETag 值，只要有資料就會進行處理。 If-Modified-Since這個字串會告訴伺服器，如果 If-Modified-Since 的值早於資料更新的時間，就處理該請求，如果在此日期之後就回傳 304 狀態碼。 If-Modified-Since 是要確認代理與客戶端所有的本地資料的有效性，獲取資料更新的日期和時間可確認伺服端的 Last-Modified 字串。 If-None-Match這個字串和 If-Match 的作用相反，ETag 值不一致才會處理該請求，在 Get 或 HEAD 方法中使用此字串就可以取得最新的資料。 If-RangeIf-Range: &quot;132455&quot; 這個字串告訴伺服器如果指定的 If-Range 值（可能是 ETag 或時間）和請求資料的 ETag 或時間相同，就做範圍請求處理，此時伺服端會回傳 Content-Range 及 Content-Length 字串，如果不是的話就回傳全部資料。 如果不使用 If-Range 的話，伺服器的資料如果更新，那客戶端手上有一部份的資料可能就會無效，這時候伺服端會回傳 412 狀態，目的是催促客戶端再次發送請求。 比較下來不使用 If-Range ，需要耗費兩倍時間。 If-Modified-Since此字串和 If-Modified-Since 相反，他的作用是告訴伺服器，指定的請求資料只能在值指定的時間後，且沒發生更新的狀況才能處理請求，如果在指定時間後發生更新，就以狀態碼 412 回傳。 Max-ForwardsMax-Forwards: 10 藉由 Trace 或 option 方法，發送包含這個字串的請求時，這個字串以十進位整數的方式指定可經過伺服器最大數目，伺服器在轉發請求給下個伺服器前，會將 Max-Forwards 的值減一之後再重新賦值，當收到 Max-Forwards 的值為 0 後，就不再進行轉發請求。 需要這樣是因為當 HTTP 通訊的時候，請求可能會經過多台代理伺服器，如果這些代理伺服器因為某些原因而請求轉發失敗，客戶端就無從得知，所以必須通過此字串來追蹤請求。 Proxy-Authorization接到從代理伺服器的憑證，客戶端會發送此字串 Proxy-Authorization 的請求，以告知伺服器憑證所需要的資訊。 這個動作和客戶端與伺服器之間的 HTTP 訪問認證相似，但差別在這是發生在客戶端與代理之間。 Range對於要獲取部分資料的範圍請求，Range 可以告訴伺服器指定的範圍。 接收到 Range 字串請求的伺服器，會在處理請求後回傳 206 狀態碼，如果無法處理就會回傳所有資料及 200 狀態碼。 Referer這個字串是告訴伺服器原始資料的 URI。客戶端一般來說都會發送 Referer 字串，但直接在瀏覽器地址輸入 URI，基於安全也可以不發此字串。 因為原始資料的 URI 的查詢字串也可能含有 ID 和密碼等重要資訊，如果寫進 Referer 轉發給其他伺服器可能會造成保密訊息外洩。 TE這個字串主要告知伺服器，客戶端能夠處理回應的傳輸編碼方式及優先順序，他和 Accept-Encoding 的功能很像，但是用在傳輸編碼。 除了指定編碼外，他還可以指定伴隨的 trailer 分快傳輸編碼的方式，應用後者只需要把 trailer 賦值給該字串。 User-Agent用於傳達瀏覽器種類，User-Agent 會建立請求瀏覽器和用戶代理等等訊息給伺服端。 如果由網路爬蟲請求，可能會在這個字串被加上爬蟲作者的電子郵件，如果請求經過代理，那也可能會被加上代理伺服器的名稱。 響應首部字段回應 header 就是伺服端發送 http 訊息給客戶端所要補充的附加訊息。 Accept-RangesAccept-Ranges: byte 此字串是用來告知客戶端是用來告知客戶端是否能進行範圍請求，可處理的話，該值為 byte 不能處理的話該值為 none。 AgeAge: 600 這個字串可以告訴客戶端，來源伺服器在多久以前建立回應資料。如果建立資料的是緩存伺服器，那麼 Age 值就是指緩存後的回應資料再發出認證到認證完成的時間值，另外代理伺服器如果建立回應資料，一定要加上此字串值。單位為秒。 EtagEtag: &quot;82e24848424...&quot; 這個字串可以告訴客戶端實體標記。他是一種把資料已字串形式作為一標記的方式，伺服器會為了每一份資料分配對應的 Etag。 而當資料更新時，Etag 也必須要更新，產生 Etag 並沒有固定的計算方法，只是由伺服端分配。 比方說，同個網站可能有中文版和英文版的資料，那他們都是用同個 URI 資料，這時候伺服端就只能依照 Etag 值給客戶端對應的資料。 強 Etag 與弱 Tag而在 Etag 中，有分強 Etag 與弱 Tag。 E-tag: &quot;usagi-1234&quot; 強 Etag，無論實體發生多細微的變化都會更改值。 E-tag: &quot;W/usagi-1234&quot; 弱 tag，只用來提示資料是否相同，只有資料發生根本的改變而產生差異才會改變 E-tag 值，這時候就會在前面加上W/。 LocationLocation: http://codingwife.com Location 可以將回應接收方引導到某個 URL 位置上的不同資料，基本上該字串會配合 3xx: Redirection 的回應來重新導向 URI。 幾乎所有瀏覽器在接收此字串的回應後，都會強制性嘗試訪問重新導向資料。 Proxy-Authenticate這個字串會把代理伺服器所要求的認證訊息發送給客戶端。 這個和客戶端與伺服端之間在發送 HTTP 傳輸的模式類似，只不過這個對象換成客戶端與代理伺服器，而在認證時 WWW-Authenticatea 字串也會有一樣的作用。 Retry-AfterRetry-After: 120 這個字串告訴客戶端多久以後再次發送請求，主要是配合 503 或 3xx 狀態一起使用。值可以指定日期，或是建立回應資料後的秒數。 Server這個字串告訴客戶端目前伺服器上安裝的 HTTP 伺服器程式的訊息，除了軟體名稱外，還可能包括版本和安裝時的選項。 Vary這個字串可以對緩存進行控制，來源伺服器會向代理伺服器傳達關於本地緩存使用方法命令。 從代理伺服器接收到來源伺服器包含此字串的回應之後，如要再進行緩存，僅對請求含有相同 Vary 的請求回傳緩存。即使對相同資料發起請求，如果 Vary 值不相同，就要重新再從來源伺服器取得資料。 WWW-Authenticate此字串用於 HTTP 訪問，他會告訴客戶端適用於訪問請求 URI 指定資料的認證方案和帶參數提示的質詢。此字串會包含在回傳 401 狀態回應中。 實體首部字段這是包含請求和回應訊息的實體部分，所用來補充內容或相關訊息的字串。 AllowAllow: GET, HEAD 此字串通知客戶端能夠支援的 Request-URI 指定資料的所有 HTTP 方法。 當伺服器收到不支援的 HTTP 方法，會回傳 405 狀態碼，除此之外還會把所有支援的 HTTP 方法寫進此字段。 Content-EncodingContent-Encoding: gzip 此字串會告知客戶端伺服器對實體主體的部分選用的內容編碼，內容編碼就是在不遺失實體訊息的狀況下所做的壓縮。 主要採用以下四種編碼： gzip compress deflate identity Conten-Language此字串告訴客戶端，實體主體主要用的自然語言。 Content-Length此字串表明實體主體的大小（單位字節）。對實體主體進行內容編碼傳輸時，就不能再用此字段，因為主體大小的計算方式比較複雜，詳細可參考 RFC2616 的 4.4。 Content-Location此字段給訊息主體相對應的 URI，與 Location 不同的點在於，此字串表示的是訊息主體回傳資料對應的 URI。 假設使用 Accept-Language 的伺服器發送請求，而回傳的頁面和實際請求的對象不同時，此字串就會寫明對應的 URI。 Content-MD5此字串的值是由 MD5 算法生成的值，目的在用來檢查主體傳輸過程是否完整，以及再確認是否有傳送到。 對訊息主體執行 MD5 算法，得到會是 128 位元的二進制數字，再通過 Base 64 編碼後寫進此字段。因為 HTTP 字段沒辦法紀錄二進制值，所以需要通過 Base 64 編碼處理，而客戶端會再對訊息主體執行相同的 MD5 算法，比較過後就可以知道訊息的正確性。 這種做法的缺點是無法發現內容有偶發性的改變，或是否被惡意竄改。 Content-RangeContent-Range: bytes 5001-10000/10000 此字串為針對範圍請求，回傳回應所使用，可以告訴客戶端回傳的實體哪個部分符合範圍請求，以字節為單位，表示當前發送部分及整個實體的大小。 Content-Type此字串說明了實體內的媒體類型，與 Accept 相同使用 type/subtype 的形式。 Expires這個字段會告訴客戶端資料的失效日期，緩存伺服器在接收此字串的回應之後，會以緩存來回覆此請求。在此字串值的時間以前，回傳的資料副本會一直留存，而當超過指定的時間後，緩存伺服器會轉向跟來源伺服器來請求有效資料。 來源伺服器不希望緩存伺服器對資料進行緩存時，最好在此字串內寫和 header 的 Date 一樣的時間，但是當 Cache-Control 有指定 max-age 時，比起此字串，他會先處理 max-age 的指令。 Last-Modified此字串指定資料最後修改的時間，一般來說就是 Requst-URI 指定資料被修改的時間，但進行動態資料處理時，此字串可能會變成資料最後修改的時間。 為 Cookie 所服務的首部字段管理伺服器和客戶端之間狀態的 Cookie ，雖還沒有被 HTTP / 1.1 的 RFC2616 列為標準，但在一般網站已經有廣泛應用。 Cookie 的目的是為了用戶識別和狀態管理，網站為了管理客戶狀態，會透過瀏覽器把資料臨時寫到客戶端的電腦，而客戶端再訪問網站時，就可通過通訊方式取回之前發的 Cookie。 呼叫 Cookie 時，可以檢驗 Cookie 的有效期，以及發送端的網域、路徑等等訊息，所以標準的 Cookie 內的資料不會因來自其他網路和攻擊者的攻擊而洩漏。 Cookie 規格的標準文件有以下： 網景公司發布的規格標準 RFC2109 RFC2965 RFC6265 目前最常用的就是 RFC6265，所以接下來以此規格來說。 Cookie 有兩個字串： Set-Cookie：開始狀態管理所用的 Cookie 訊息。 Cookie：伺服端收到的 Cookie 訊息。 Set-Cookie當伺服器開始管理客戶端的狀態，會事先告知各種訊息：|屬性|說明||—|—||NAME=VALUE|賦予 Cookie 的名稱和值（必須）||expires=DATE|Cookie 的有效期（如果沒有指點，默認值就是以瀏覽器關閉為止）||path=PATH|伺服器上的文件目錄作為 Cookie 適用的物件（如果沒有指點，默認值就是以所在文件的文件目錄）||domain=域名|Cookie 適用物件的域名（如果沒有指點，默認值就是以創建 Cookie 的伺服器的域名）||Secure|僅在 HTTP 安全通訊才會發送 Cookie||HttpOnly|做限制，不能在 JavaScript 腳本訪問| expires 屬性 expires 可以發送 Cookie 的有效期 沒有指定，默認就是瀏覽器關閉之前 一旦 Cookie 從伺服器發送到客戶端，伺服器就不存在可以顯示刪除 Cookie 的方法，但可以通過覆蓋已經過期的 Cookie，一樣可以達到對於客戶端 Cookie 刪除的操作。 path 屬性可用於限制指定 Cookie 的發送範圍的文件目錄，不過另外有方法可以避開這個限制。 domain通過 Cookie 的 domain 屬性指定的域名可以做到結尾配對相同。比方說指定 codingwife.com ，www.codingwife.com 或 www2.codingwife.com 之類的都可以發送 Cookie。 除了指定多個域名發送 Cookie 之外，不指定 domain 更顯得安全。 secureSet-Cookie: name=value; secure Cookie 的 secure 僅在 HTTPS 或 SSL 安全連接時，才可會被發送到伺服器。 HttpOnly這個屬性主要防止 cookie 的擴展功能，它讓 JavaScript 腳本沒辦法取得 Cookie，主要為了防止 XSS 攻擊對 Cookie 的竊取。 Cookie此字串告訴伺服器，當客戶端想取得 HTTP 狀態管理支援時，就會從請求中包含從伺服器接收到的 Cookie。 其他首部字段HTTP header 可以自行擴展，所以在瀏覽器上會出現一些非標準的字串，以下就幾種最常用的來做說明。 X-Frame-OptionsX-Frame-Options: DENY 此字串是回應 header，控制網站內容在其他網站的 Frame 標籤的顯示問題，主要為了防止點擊劫持。 以下有兩個可以指定的值： DENY：拒絕 SAMEORIGIN：僅同源域名下的頁面配對許可。 舉例：如果指定 codingwife.com 頁面是 SAMEORIGIN，那麼 codingwife.com 下的 frame 都允許可載入該頁面，而其他域名就不行。 X-XSS-Protection此字串是回應 header，這是一個控制 XSS 對策的一個字串，用於控制瀏覽器 XSS 防護機制的開關。 0：將 XSS 過濾設置成無效狀態 1：將 XSS 過濾設置成有效狀態 DNT此字串是請求 header，意思是拒絕個人訊息被收集，表示拒絕被精準廣告追蹤的一種方法。 0：同意被追蹤。 1：拒絕被追蹤。 這個字串必須要有伺服端對應的支援。 P3P通過這個技術，可以讓網站上的個人隱私變成一種可以提供程式理解的形式，以保護用戶端隱私。 建立 P3P 隱私 建立對照文件後，保存命名在 w3c/p3p.xml 中。 從 P3P 隱私中建立 Compact policies，輸出到 HTTP 回應中。 資料來源：《圖解 HTTP》 上野宣 人民郵電出版社筆記純屬推廣及分享，如有侵權，請告知。Please advise to remove immediately if any infringement caused.","link":"/graphic-http-chapter06-3/"},{"title":"【讀書筆記】圖解 HTTP Chapter 07 確保 Web 安全的 HTTPS","text":"缺點 通訊使用不加密明文，內容可能會被竊聽 不驗證通訊方身放，可能遭到偽裝 無法證明訊息的完整性，可能會遭到竄改 以上缺點在其他未加密協定也會存在。 缺點 通訊使用不加密明文，內容可能會被竊聽 不驗證通訊方身放，可能遭到偽裝 無法證明訊息的完整性，可能會遭到竄改 以上缺點在其他未加密協定也會存在。 通訊使用不加密明文，內容可能會被竊聽 TCP / IP 是可能被竊聽 根據 TCP / IP 的工作機制，通訊不加密表示所有通訊線路上的資料都有可能被窺視。 網路是連接到全世界的網路組成，因此通訊線路上的電腦、光纖及其他網路上都不可能是個人所有，所以可能在某個環節上被遭到窺視。 即使經過加密處理，也會被窺視到通訊內容，跟未加密的訊息差別在於，加密的訊息有可能讓人無法理解 HTTP 訊息含義，但加密過後的訊息還是有可能被看到。 加密處理防止被竊聽在目前大家研究如何防止竊聽的對策，最普及的就是加密技術： - 通訊的加密：將通訊加密，HTTP 協議中沒有加密機制，但可以通過 SSL 或 TLS 的組合使用，加密 HTTP 通訊內容。用 SSL 建立安全通訊後，就可以在這條線路上進行 HTTP 通訊，稱之 HTTPS。 - 內容的加密：將 HTTP 訊息內容作加密，而客戶端和伺服端都要同時具備加密及解密機制。不同於 SSL 或 TLS ，內容仍然有被竄改的風險。 不驗證通訊方的身份就會遭到偽裝HTTP 協議中的請求與回應不會對通訊方進行確認，也就是可能會發生伺服端或客戶端的其中一方是偽造的狀況。 任何人都可發送請求在 HTTP 通訊中，由於不存在確認通訊方的處理步驟，在 IP 位置和埠號沒限制的狀況下，無論是誰發送請求，伺服端都會接收請求，所以可能有以下的隱患： - 無法確認發送請求的對象是否為目標伺服端。 - 無法確認接收請求的對象是否為目標客戶端。 - 無法確認正在進行通訊的那方是否有具備訪問權限。 查明對方的憑證雖然 HTTP 無法確認對方身份，可是 SSL 可以，而且使用了憑證的方法來確認。憑證由第三方機構頒發，來證明客戶端和伺服端是真實存在。因為偽造憑證很困難，所以確認對方的憑證就可以判斷，而且對使用者來說可以減少訊息洩漏的危險。 無法證明訊息完整性，可能已遭竄改這邊的完整性講的是訊息的準確度。 接收到的內容可能有誤由於無法證明 HTTP 訊息的完整性，因此在請求（或回應）後到對方接收的這段時間，如果內容被竄改也沒辦法知道。意思就是你送出的請求（回應）和另一端接收到的請求（回應），在傳輸過程中可能會遭人篡改，像這樣的模式叫做 MITM（Man-in-the-Middle attack）。 如何防止竄改雖然有使用 HTTP 協議確認 HTTP 訊息的完整性，但事實上並不可靠，比較常用的是 MD5 和 SHA-1 等散列值檢驗來確認文件的數位簽名。 HTTP + 加密 + 認證 + 完整性保護 = HTTPSHTTP 加上加密處理與認證等完整保護就是 HTTPS如果在傳輸過程中使用未加密明文，那麼在頁面上串金流就也可能會被竊聽，那一些金融資料就可能會被曝露，另外沒辦法確認對方身份也很麻煩，所以為了統一解決上述問題，就需要在 HTTP 上做加密處理，因此把加密及認證機制稱作 HTTPS。 https://... HTTPS 是身披 SSL 外殼的 HTTPHTTPS 不算是在應用層的新協議，只是通訊端用 SSL 和 TLS 協議替代，通常使用 HTTP 是直接和 TCP 層通訊，但 HTTPS 使用 SSL ，就變成 SSL 在跟 TCP 通訊，這樣的感覺就像在 TCP 和 HTTP 中間多了一層 SSL。 SSL 是獨立於 HTTP 協議，所以應用層的 SMTP 和 Telent 等等協議都可以配合。 相互交換密鑰的公開密鑰加密技術SSL 採用公開密鑰加密的加密處理方式，現在的加密方法是公開的，但是密鑰是保密的，加密和解密都會用到密鑰，換句話說有密鑰就可以解密。 共享密鑰加密的困境 加密和解密共用同個密鑰叫做共享密鑰加密，又稱為密鑰加密。 以共享密鑰加密的方式把密鑰傳送給對方，但在傳送的過程也可能會被遭到攻擊，如果密鑰被攻擊者知道就失去意義，那我們該如何安全傳輸密鑰呢？ 使用兩把密鑰的公開密鑰加密公開密鑰加密的方式解決了共享密鑰加密的困難。 公開密鑰加密：有一把非對稱的密鑰，一把叫做私有密鑰（私鑰），一把叫做公開密鑰（公鑰），意思就是私有密鑰不能給別人知道，公開密鑰可以讓任何人知道。 過程：發送密文的那方使用接收方的密鑰進行加密處理，對方收到加密的訊息再用自己的私鑰進行解密。 這樣的方式就不用擔心訊息被竊盜，另外如果想根據密文和公鑰來解密是非常困難的，因為解密的過程就是對離散數學求值，密碼還是有機會遭到破解，但就現在的技術而言是不太可能的。 HTTPS 採用混合加密機制HTTPS 採用共享密鑰加密和公開密鑰加密兩者並用的混合加密機制，如果密鑰能夠安全交換，那麼就有可能會用公開密鑰的方式來進行通訊，但公開密鑰比共享密鑰加密的方式還慢。 證明公開密鑰正確性的證書公開密鑰還是有問題，就是無法證明公開密鑰本身的真實性，舉例來說： 準備和某台主機建立公開密鑰加密的方式，來進行通訊傳輸，如何確認公開密鑰就是原本那台伺服器發送的公開密鑰，因為有可能在公開密鑰傳輸的過程中被攻擊者替換。 為了解決上述問題，可以使用數位憑證認證機構，與相關機關頒發的公開密鑰證書。 數位憑證認證機構：客戶端與伺服端雙方都可信任的第三方機構。 流程：伺服器的營運人員先向第三方申請公開密鑰的申請，數位憑證機構判明提出申請者的身份，在對已申請的公開密鑰做數字簽名，然後再分配這個已簽名的公開密鑰，並將公開密鑰放入公鑰證書後並綁定。 伺服端：伺服端會把這份數位憑證機構頒發的公鑰發送給客戶端，以做公鑰密鑰加密的方式通訊，公鑰憑證也可以叫做數位憑證。 客戶端：接收到數位憑證的客戶端，可以使用公鑰對數位憑證進行驗證，驗證通過即可證明認證伺服器的身份以及其公鑰是可以信賴。 數位憑證的公鑰要安全地交給客戶端是困難的事，因此瀏覽器商在發布版本的時候，會事先在內部植入常用的數位憑證機構的公鑰。 客戶端作業順序： 使用瀏覽器植入的公開密鑰 拿到伺服器的數位憑證後，用瀏覽器的公開密鑰做驗證 驗證過後使用公開密鑰對 HTTP 訊息做加密後傳輸 伺服端作業流程： 伺服器把自己的公開密鑰登錄到數位憑證機構 接收到請求方的請求後，伺服端用私鑰對加密的請求進行解密 可證明組織真實性的 EV SSL 證書 憑證是來證明其中一方的身份，再來就是確認伺服器規模。擁有該特性的憑證就是 EV SSL 憑證。 EV SSL 數位憑證基於國際標準，嚴格規定了對營運組織的確認方針，因此通過的網站可以獲得比較高的認可度。擁有 EV SSL 數位憑證的瀏覽器，在瀏覽器 URL 欄位的背景色是綠色，為的是防止釣魚攻擊。 用以確認客戶端的客戶端證書 HTTPS 中還可以使用客戶端憑證，證實伺服器正在通訊的那方是預期的客戶端，作用和伺服端憑證相同，但仍然有幾個問題點： 憑證的頒發與獲得：要拿到證書意味要付費購買，讓不同用戶自行安裝憑證這件事就具有很大的挑戰。現況是安全性比較高的憑證機構可以頒發客戶端憑證，但僅限於特殊用途，像是可以支付憑證的業務。像是網路銀行就常使用客戶端憑證。 無法獲得用戶本人的真實性：就算確認了電腦，但不能代表使用電腦的人就是擁有憑證的本人。 認證機構信譽第一SSL 機制之所以可行，是因為認證機構是可被信賴的，之前在荷蘭有被爆出憑證機構被駭客入侵。雖然現在有將憑證吊銷的機制，以及從客戶端刪除憑證發布機構的對策，但距離完全實現還需要一點時間。 由自認證機構頒發的證書稱為自簽名證書使用 Open SSL 每個人可以建立自己的數位憑證，給自己的伺服器憑證，但在網路上是不可以使用，如果瀏覽器訪問該網站就會出現「無法確認連接安全」或「此網站憑證存在問題」等等，主要是因為無法消除偽裝可能性的關係。 HTTPS 的安全通信機制 SSL 和 TLSIETF 以 SSL 3.0 為基準，後來又制訂了 TLS 1.0 及 TLS 1.1 的版本，目前主流的是 SSL 3.0 和 TLS 1.0。 SSL 速度慢嗎 通訊慢：和 HTTP 比，網路負載會慢 2-10 倍，TCP 連接、發送 HTTP 請求、回應也都要進行 SSL 通訊，所以通訊量也會增加。 效能慢：因為需要進行加密處理，伺服端和客戶端都需要進行加密和解密的過程，就結果來說 SSL 會消耗更多伺服器和客戶端的硬體資源。 為什麼不一直用 HTTPS 就好？其實只要與個人資訊相關等敏感資料再做加密通訊就好，除了上述缺點外，節約開銷也是重點。資料來源：《圖解 HTTP》 上野宣 人民郵電出版社筆記純屬推廣及分享，如有侵權，請告知。Please advise to remove immediately if any infringement caused.","link":"/graphic-http-chapter07/"},{"title":"【讀書筆記】圖解 HTTP Chapter 08 確認訪問用戶身份認證","text":"電腦本身沒辦法判斷正在使用電腦的人是誰，為了確認是否為本人，需要核對只有登入者本人才知道的訊息，核對訊息通常是以下： 密碼（password）：本人才知道的字串。 動態令牌（dynamic token）：僅限本人擁有設備的一次性密碼。 數位憑證：本人（終端）所有的訊息。 生物辨識：指紋或虹膜的生理訊息。 IC 卡：本人所有的訊息。 何謂認證電腦本身沒辦法判斷正在使用電腦的人是誰，為了確認是否為本人，需要核對只有登入者本人才知道的訊息，核對訊息通常是以下： 密碼（password）：本人才知道的字串。 動態令牌（dynamic token）：僅限本人擁有設備的一次性密碼。 數位憑證：本人（終端）所有的訊息。 生物辨識：指紋或虹膜的生理訊息。 IC 卡：本人所有的訊息。 HTTP 所使用的認證方式： BASIC 認證 基本認證 DIGEST 認證 摘要認證 SSL 認證 客戶端認證 FormBase 認證 基於表單認證 BASIC 認證這個認證方法是從 HTTP/1.0 就定義的，現在還有一部分網站會用這種認證方法，就伺服器和客戶端進行的認證。 BASIC 認證步驟 請求資料需要 BASIC 認證時，伺服器會隨著 401 狀態，回傳帶WWW-Authenticate的字串，這個字段包含認證方式，以及 Request-URI 安全域字串。 接收到狀態 401 的客戶端為了通過驗證，需要把客戶 ID 及密碼傳送給伺服器，發送字串由 ID 及密碼組成，兩者中間以冒號連接後，再以 Base 64 編碼處理。 如果客戶 ID 是 guest，密碼是 guest，那連接後就是guest:guest，再經過 Base64 編碼，最後再把編碼後的字串寫入首部字串Authenticate後發送請求。當客戶代理為瀏覽器時，客戶僅輸入用戶 ID 和密碼即可，瀏覽器就會自動完成 Base64 編碼轉換的工作。 接收首部字串Authenticate請求的伺服器，會對訊息的正確性進行驗證，通過驗證就會回傳包含一條 Request-URI 的資料回應。 問題點 雖然採用 Base64 編碼方式，但這不算加密處理，不需要附加訊息就可以對其解碼，解碼後就是用戶 ID 和密碼，所以被竊取的機率極高 如果要再進行 BASIC 認證，一般瀏覽器沒辦法實現認證註銷操作。 因此這個認證達不到一般網站對於安全性的需求。 DIGEST 認證為了彌補 BASIC 認證的弱點，在 HTTP/1.1 就有 DIGEST 認證，使用質詢/回應的方式，不像 BASIC 認證直接發送明文。 質詢/回應：一方會先發認證給對方，接著從對方那邊接收到質詢碼計算產生回應碼，最後將回應碼回傳給對方進行認證。 DIGEST 認證步驟 請求需認證的資料，伺服器會隨著狀態碼 401，回傳帶WWW-Authenticate的字串，這個字段包含質詢回應方式認證所需的臨時質詢碼（隨機）。 WWW-Authenticate：必須包含 realm 和 nonce 兩個訊息，客戶端就是靠這兩個字串進行認證 nonce：是每次隨著 401 回應產生的任意隨機字串，通常是由 Base 64 編碼的十六進制組成。 接收到 401 的客戶端，回傳回應包含 DIGEST 認證必要的字串 Authenticate 訊息。 Authenticate：必須包含 username、realm、nonce、uri 和 response 字串。 username：realm 限定範圍可進行認證的用戶名。 uri：Request-URI 的值，考慮經代理轉發 Request-URI 的值可能被修改，因此會先儲存一份在 uri 中。 response：也可以叫做 Response-Digest，經過 MD5 計算後的密碼字串，詳細閱 RFC 2617。 接收到包含Authenticate請求的伺服器，會確認認證訊息的正確性，認證通過後再回傳含有 Request-URI 的資料回應，並在這時候回傳包含Authenticate-Info 的字串，裡面寫了一些認證相關訊息。 DIGEST 認證提供了高於 BASIC 認證的安全等級，但和 HTTPS 的客戶端認證相比，還是很薄弱，DIGEST 認證提供防止密碼被竊聽的機制，但他和 BASIC 認證一樣不敏捷，再來網站高度安全性的要求，還是有所落差，而且適用範圍也有限制。 SSL 認證以 ID 和密碼的認證來說，只要兩者都正確，就可以確認是本人行為，但是如果用戶 ID 和密碼被盜，就可能冒充，利用 SSL 客戶端認證就可以避免這種狀況。 SSL 客戶端認證是藉由 HTTPS 的客戶端憑證完成認證，伺服器就可以確認是否來自自己登入的客戶端。 SSL 客戶端認證步驟為了能讓 SSL 客戶端認證，需要將客戶端憑證分發給客戶端，且客戶端需要安裝此憑證。 接收到需要認證資源的請求，伺服器會發送 Certificate Request 訊息，要求客戶端提供客戶端憑證。 用戶選擇將發送的客戶端憑證後，客戶端會把客戶端憑證訊息以 Client Certificate 訊息方式分發給伺服器。 伺服器檢驗客戶端憑證，通過後就可以領憑證裡面客戶端的公鑰，即開始 HTTP 加密通訊。 SSL 客戶端認證採用雙因素認證在多數狀況下，SSL 不會只依靠憑證，還跟後續會說到的表單驗證一起做，以達成雙因素認證，就可以確認是用戶本人的電腦在訪問伺服器。 雙因素認證：認證過程不僅需要密碼一個因素，還需要申請認證者提供其他持有訊息，當作另一個因素，一起結合使用的認證方式。 SSL 客戶端認證必要的費用SSL 客戶端認證需要用到客戶端憑證，而憑證需要支付費用才能使用，每個認證機構的費用不盡相同，要維持安全的營運需要產生相應的費用。 基於表單認證表單驗證方法不是在 HTTP 協議中定義的，客戶端會向伺服端的網站發送登入訊息，按登入訊息的驗證結果認證。 認證多半基於表單認證雖然 HTTP 有提供 BASIC 認證和 DIGEST 認證，但幾乎不怎麼使用，但又由於 SSL 客戶端認證雖然有高度安全性，可是因為導入及費用的關係，還未普及。 以 SSH 和 FTP 協議來說，服務器與客戶端之間的認證是合乎標準，也滿足了基本功能的需求上的安全級別，因此這些協議可以直接拿來使用，由於網站的認證功能，能夠滿足安全級別的標準規範幾乎不存在，所以只好由網站各自實現表單的認證。 不具備共同標準的表單驗證，在每個網站上都有不一樣的方式，如果全面考慮安全性的表單驗證，也夠具備高度的安全等級，可是也有很多網站的表單驗證是有問題的。 Session 管理及 Cookie 應用由於表單驗證沒有一定的規範，一般會用 Cookie 來管理 Session。 基於表單驗證本身是通過伺服端的網站，將客戶端發送的用戶 ID 和密碼與之前登入的訊息座配對來進行認證，但有鑒於 HTTP 是無狀態協定，之前以經任正成功的用戶狀態沒有辦法保存下來，表示用戶下次訪問也沒辦法特別區隔，所以會用 Cookie 來管理 Session，以彌補 HTTP 協議中不存在的狀態管理功能。 客戶端把用戶 ID 和密碼等登入訊息放在 HTTP 訊息的實體，通常以 POST 方法把請求發送給伺服器，會使用 HTPPS 來進行 HTML 表單畫面的顯示和用戶輸入資料的發送。 伺服器會發放以用來識別用戶的 SessionID，通過驗證從客戶端發送過來的登入訊息進行身份驗證，接著把認證狀態和 SessionID 綁定後記錄在伺服端。 客戶端回傳回應時，會在首部字串Set-Cookie內寫入 Session ID，你可以想像 Session ID 是一個用來區分不同用戶的等位號。如果 Session ID 被第三方盜走，那麼對方可能會偽裝你的身份來進行惡意操作，為了預防這種狀況發生，Session ID 應該要用難以預測的字串，伺服端也要進行有效期的管理來保障安全。另外為了減輕 XSS 造成的損失，建議在 Cookie 上加上 httponly 的屬性 客戶端接收從伺服端發來的 SessionID 後，會把這個當作 Cookie 保存在本地，下次伺服器發送請求時，瀏覽器會自動發送 Cookie，所以 SessionID 也會發送到伺服器，伺服端就可以驗證接收的 SessionID 以識別用戶跟狀態。 不僅基於表單認證的登入訊息和認證過程都沒有標準化，伺服端應該要如何保存用戶提交的密碼等登入訊息也沒有標準化。 通常安全地保存是給密碼加鹽（就是隨機產生字串讓他和密碼串相連）的方式增加額外的訊息，再使用散列（hash）函數去計算散列值之後保存，當然也有明文儲存密碼的方法，不過就可能會有風險。 為什麼不一直用 HTTPS 就好？其實只要與個人資訊相關等敏感資料再做加密通訊就好，除了上述缺點外，節約開銷也是重點。資料來源：《圖解 HTTP》 上野宣 人民郵電出版社筆記純屬推廣及分享，如有侵權，請告知。Please advise to remove immediately if any infringement caused.","link":"/graphic-http-chapter08/"},{"title":"【讀書筆記】圖解 HTTP Chapter 09 基於 HTTP 的功能追加協議","text":"當初在制定 HTTP 協議，主要是希望把 HTTP 當作傳輸 HTML 文件的協議，但根據時代演變，網站的用途越來越多樣，像是購物網站、SNS 等（社交網路服務 Social Networking Service），HTTP 協議即使已經滿足需求，但加上本身協議的限制和自身效能的限制，就效能來看不一定是最好的。 因為現在網路瀏覽器的使用已經佈及全世界，已經完全沒辦法離開 HTTP，因此在其他功能上的不足，會需要建立全新的協議來彌補。 基於 HTTP 協議當初在制定 HTTP 協議，主要是希望把 HTTP 當作傳輸 HTML 文件的協議，但根據時代演變，網站的用途越來越多樣，像是購物網站、SNS 等（社交網路服務 Social Networking Service），HTTP 協議即使已經滿足需求，但加上本身協議的限制和自身效能的限制，就效能來看不一定是最好的。 因為現在網路瀏覽器的使用已經佈及全世界，已經完全沒辦法離開 HTTP，因此在其他功能上的不足，會需要建立全新的協議來彌補。 消除 HTTP 瓶頸的 SPDYGoogle 在 2010 年發佈了 SPDY，開發宗旨是要解決 HTTP 的效能瓶頸，縮短頁面的載入時間。 http://www.chromium.org/spdy/ HTTP 的瓶頸在 SNS 網站上，可以看到海量的用戶所發佈的內容，這使網站需要短時間的大量更新內容，為了盡量顯示內容，伺服器內容有更新就馬上回靠到客戶端的頁面上，但這項任務對於 HTTP 來說卻相當困難，因為需要頻繁地從客戶端到伺服端進行確認，如果伺服器上的內容沒更新，就會有多餘的傳輸動作。 希望網站實現所需要的功能，HTTP 目前遇到下面的瓶頸： 一條連接只能發送一個請求 請求只能從客戶端開始，客戶端不能接收除了響應以外的指令 請求 / 響應首部未經壓縮就發送，首部訊息越多延遲越大 發送冗長的首部，每次互相發送相同首部造成的浪費較多。 AJAX 解決方法AJAX 是一種利用 JavaScript 和 DOM 的做，已達到局部網站頁面替換的非同步手段，和以前同步通訊相比，由於他只更新頁面的一部份，響應傳輸量會因此減少。 AJAX 的核心技術是 XMLHttpRequest 的 API ，透過 JavaScript 的呼叫就可以讓伺服器進行 HTTP 通訊，利用 AJAX 從伺服器取得內容，有可能導致大量請求產生，還是沒辦法解決 HTTP 根本的問題。 Comet 解決方法只要伺服器有更新，Comet 不會讓請求等待，而是直接給客戶端響應，這是透過一個延遲應答，模擬伺服器向客戶端推播的功能。 伺服器收到請求，處理完就會馬上回傳響應，但為了實現推播的功能，Comet 會掛起一個連結，當伺服器更新的時候再回傳響應，因此在伺服端有更新就可以立即回傳給客戶端。 在內容上雖然可以做到實際的更新，但為了保留響應，一次連續時間也變成，過程中消耗的效能也更多，所以 Comet 也沒有解決 HTTP 協議存在的問題。 SPDY 的設計與功能處於持續開發狀態中的 SPDY 協議，就是為了消除 HTTP 所遭遇的瓶頸。 SPDY 沒有改寫 HTTP 協議，而是在 TCP/IP 的應用層與傳輸層之間通過新加會一層形式，同時考慮到安全性，SPDY 規定在通訊中必須使用 SSL。SPDY 以會議層的形式加入，控制對資料的流動，但還是採用了 HTTP 建立通訊的連接，可照常使用 HTTP 的方法等。 使用 SPDY 可以獲得以下功能： 多路復用流透過單一 TCP 連接，可以無限制處理多個 HTTP 請求，所有請求都在一條 TCP 完成，效率因此提高。 賦予請求優先順序SPDY 不僅無限制地處理請求，還能分配優先順序，因此解決了頻寬導致的響應變慢的問題。 壓縮 HTTP 首部壓縮 HTTP 首部，讓封包數量和字串數變少。 推播功能支援伺服器向客戶端推波資料，因此伺服器可發送資料，也不需要等客戶端的請求。 伺服器提示服務伺服器可以主動提示客戶端所需要的資料，因此客戶端發現資料之前就可以知道其存在，因此在緩存的狀況下可以避免發送不需要的請求。 SPDY 消除 Web 的瓶頸了嗎希望使用 SPDY 時，希望網站的內容不要做特別的變動，而網站的瀏覽器和伺服器都要為對應的 SPDY 做一定程度的變動，有很多瀏覽器廠商針對 SPDY 做了相對應的調整，但進展不太好。 因為 SPDY 只是將單個域名（IP 位置）的通訊多路復用，所以當一個網站使用多個域名資料的狀況下，改善效果就會被受到限制。 SPDY 確實可以消除 HTTP 的瓶頸，但很多網站的問題不僅僅是因為 HTTP 的瓶頸所導致的，對網站效能的提升應該從其他可鑽研的地方下手。 使用瀏覽器進行全雙工的 WebSocket利用 AJAX 和 Comet 的通訊技術可以提升網站的瀏覽速度，但如果使用 HTTP 協議就無法徹底解決問題，而 WebSocket 就是為了解決這些問題而實現的新協議及 API。 WebSocket 的設計與功能WebSocket 就是網站瀏覽器和伺服器之間的全雙工通訊標準。當中 WebSocket 協議由 IETF 所提供，由 W3C 訂定標準，仍在開發中的 WebSocket 技術主要為了解決 AJAX 和 Comet 之中 XMLHttpRequest 附帶的缺陷所引起的問題。 WebSocket 協議一旦伺服器和客戶端之間建立起 WebSocket 協議的通訊，之後的通訊都是靠這個協議在進行，通訊過程可以發送任何格式的資料。由於是建立在 HTTP 基礎上的協議，因此發起端還是客戶端，只要 WebSocket 連接到了，無論伺服器還是客戶端，任何一方都可以直接向對方發起 HTTP 報文。 主要特點： 推播功能：支援由伺服器對客服端推送資料的推播功能，這樣伺服端就可以直接發送資料，而不用等客戶端的請求。 減少通訊量只要建立連接後，就會希望持續下去，和 HTTP 比，不但每次連接的消耗變小，而且因為 WebSocket 的首部訊息很少，通訊量也相對變小了。 為了做 WebSocket 通訊，在 HTTP 連結建立之後，還需要完成一次握手（Handshaking）的步驟。 握手。請求：為了實現 WebSocket 通訊，需要 HTTP 的 Upgrade 首部字串，告訴伺服器產生改變，已達到握手的目的。 Sec-WebSocket-Key字串裡紀錄握手過程必須的鍵值。 Sec-WebSocket-Protocol 記錄使用的子協議。子協議按 WebSocket 協議標準在連結分開時使用，定義那些連接的名稱。 握手。響應：對於之前的請求，返回狀態碼 101 的響應。 Sec-WebSocket-Accept 的字串是由請求中的Sec-WebSocket-Key的字串產生。 成功建立 WebSocket 連接後，通訊就不再使用 http 資料幀。 WebSocket API：JavaScript 可呼叫「The WebSocket API」來實現 WebSocket 協議下的全雙工通訊。 期盼已久的 HTTP/2.0 http 2.0 的特點：http 2.0 的目標是改善用戶在網站上的使用速度體驗。 SPDY HTTPSpeed + Mobility（Speed + Mobility）：微軟公司發起，用於提升移動裝置的通訊速度和性能，他建立在 SPDY 與 WebSocket 的基礎。 Network-Friendly HTTP Upgrade（Friendly）：主要是改善 HTTP 效能的標準。 HTTP/2.0 的七項紀錄與討論 壓縮：SPDY、Friendly 多路復用：SPDY TLS 義務化：Speed + Mobility 協商：Speed + Mobility, Friendly 客戶端拉曳、伺服端推播：Speed + Mobility 流量控制：SPDY WebSocket：Speed + Mobility Web 伺服器管理文件的 WebDAVWebDAV 是一個可對伺服器上的內容進行文件的複製、編輯等操作的分布式文件系統，除了新增、刪除文件等基本功能，還對文件建立者管理、文件編輯過程中禁止其他用戶內容覆蓋的加鎖功能，以及對文件內容修改的版本控制功能。 使用 http/1.1 的 put 和 delete 方法，就對伺服器上的文件進行新增和刪除，但基於安全和便利性，一般不使用。 擴展 http/1.1 的 WebDAV 集合：是一種統一管理資源的概念 資源：把文件或集合稱為資源 屬性：定義資源的屬性 鎖：把文件設置為無狀態，多人編輯可以防止同一時間寫入。 WebDAV 內新增的方法及狀態碼為了實踐遠端文件管理，在 http 1.1 中也新增了以下這些方法： PROPFIND：獲取屬性。 PROPPATCH：修改屬性。 MKCOL：建立集合。 COPY：複製資源及屬性。 MOVE：移動資源。 LOCK：資源加鎖。 UNLOCK：資源解鎖。 為了配合拓展，狀態碼也隨之新增： 102：可正常處理請求，但處理中。 207：存在多種狀態。 422：格式正確，內容有誤。 423：資源已被加鎖。 424：處理與請求關聯的請求失敗，因此不再維持依賴關係。 507：保存空間不足。 為什麼不一直用 HTTPS 就好？其實只要與個人資訊相關等敏感資料再做加密通訊就好，除了上述缺點外，節約開銷也是重點。資料來源：《圖解 HTTP》 上野宣 人民郵電出版社筆記純屬推廣及分享，如有侵權，請告知。Please advise to remove immediately if any infringement caused.","link":"/graphic-http-chapter09/"},{"title":"【讀書筆記】JavaScript Design Pattern Chapter01 介紹","text":"Javascript 是一個不尋常的語言，他沒有 class，而函式是他的第一級物件（firstclass）。 模式定義：反覆出現的事件或物件，它可以用來產生事物，可能是模板或樣板。 本書討論以下幾種模式： 設計模式：設計模式的研究起初以強型別語言為主，但以 js 來說可能有更簡單的選擇。 編碼模式：JavaScript 特有的模式，為本書的精華重點。 反模式：反模式和程式錯誤不同，他只是常見的糟糕實踐方法，讓你乍似解決問題，但最後得不償失。 JavaScript 的重要觀念物件導向任何在 JavaScript 中看到的都非常可能是物件，只有五種原始型別不是：數值、字串、布林、null 和 undefined，而前三者都有其對應原始型別包裹。 定義變數時，該變數自動變成內部物件的一個屬性，內部物件又稱為 Activation Object（保存函式作用域內的區域變數和物件，還有函式參數)。 物件：一堆具名屬性的集合，屬性可以是函式，稱為方法。物件創造後可以隨時修改。有兩種最主要的物件： Native（原生物件）：ECMA 標準中描述，可以被歸類為內建物件或使用者定義物件（var o = {}）。 Host（宿主物件）：定義在 host 環境中，例如：網頁瀏覽器（window、DOM）。如果不確定可在非瀏覽器環境下執行，如果執行成功，應該就只用到原生物件。 沒有 ClassJavaScript 沒有 Class ，JavaScript 只處理物件。四人幫書中提到：「多用物件複合，少用類別繼承。」 意思就是你可以用現有的材料創造新的物件，會比建立出冗長的父子類別繼承鍊或類別系統來得更好。 原型原型（prototype）是一個物件，建立的每個函式都會指向一個新的空白物件。此物件和使用物件實字或 Object() 建構式創造出的新物件幾乎一樣，除了它的 constructor 屬性會指向剛建立的函式而不是內建的 Object() 。可以為空白物件新增成員，而之後繼承此物件的新物件可以把這些屬性當作自己的來使用。 原型是一種屬性，且每個函式都有prototype。 執行環境JavaScript 的原生環境就是瀏覽器，接下來列出的模式大多直接與 JavaScript 核心相關，所以可以忽略環境的差別。","link":"/javascript-design-pattern-introduce/"},{"title":"【讀書筆記】JavaScript Design Pattern Chapter02 精要","text":"撰寫可維護的程式碼容易維護的程式碼必須具備下列條件： 可讀性 一致性 可預料的 看起來像同個人寫的 文件化 減少全域變數JavaScript 使用函數來管理作用域。 區域變數：在函式內的變數對於該函數來說為區域變數。 全域變數：定義在函式作用域之外，或者沒被宣告就直接使用的變數。 每種 JavaScript 執行環境都有全域物件，在函式作用域之外用this就可以存取得到，所有建立的全域變數都會成為全域物件的屬性。 全域變數的問題因為都存在在相同的全域命名空間，會有命名衝突的問題，之後會學習到命名空間模式，和自我執行的立即執行函式。 不小心建立全域變數的兩個狀況 未宣告就使用變數，會自動為全域物件的屬性。 連續賦值（var a = b = 0;，a 為區域變數，b 為全域變數）。 遺漏 var 的副作用明確定義的全域變數和隱含的全域變數有個微小差別，就是是否能用delete運算子將變數刪除。 用 var 創造出的全域變數不可刪除 不使用 var 隱含創造出的全域變數可以刪除 意思是說隱含創造出的全域變數並不是真的變數，而是全域物件的屬性，屬性可以透過delete運算子刪除，但是變數不行。 存取全域物件在瀏覽器上，任何程式碼都可以透過 window 屬性存取全域物件。 單一 var 模式在函式最開頭使用單一 var 述句是個非常有用的模式： 再找所有函式所需的變數，只需找一個地方就好。 避免未宣告就使用變數所造成的邏輯錯誤。 盡少使用全域變數 較少的程式碼 用單一 var 述句宣告多個變數，並用逗號隔開，同時也賦予初始值，可避免邏輯錯誤。 Hosting：分散的 var 所製造的問題JavaScript 允許一個函式內有多個 var 述句，並放在任何位置，他們的行為跟在函式頂端宣告一樣，此行為叫做 Hosting（提升）。 程式碼會進行兩個處理： 第一階段：語法分析和讀取內容，將產生變數、函數宣告，以及函式參數。 第二階段：執行時期，將產生函式表達式和不合格識別字。但為特殊目的，有時我們仍可以採用 hosting 概念。 for 迴圈使用迴圈可以重複整個陣列或類似陣列的物件，如果可以最好是預先計算陣列的長度。 遵照單一 var 模式，可以將 var 提出迴圈外： function looper()&#123; var i=0, max, myarray=[]; for(i=0,max=myarray.length;i&lt;max;i++)&#123; ... &#125;&#125; 優點：一致性缺點：重構時，若要將迴圈複製，要確認有把i及max複製過去。調整：將i++替換為i=i+1、i+=1。（JSLint 對++及--提示「過度使用伎倆」） for-in 迴圈for-in應該使用在重複非陣列物件，又稱為列舉，而陣列應該使用for迴圈。 在列舉屬性很重要的是使用hasOwnProperty()方法來過濾掉原型鍊的屬性。 var man = &#123; hands: 2, legs: 2, head: 1,&#125;;if (typeof Object.prototype.clone === 'undefined') &#123; Object.prototype.clone = function() &#123; console.log('hi'); &#125;;&#125;for (var i in man) &#123; if (man.hasOwnProperty(i)) &#123; console.log(i, ':', man[i]); &#125;&#125;// hands : 2// legs : 2// head : 1//for (var i in man) &#123; console.log(i, ':', man[i]);&#125;// hands : 2// legs : 2// head : 1// clone : ƒ ()&#123; console.log('hi')&#125; 意思就是假設你有自訂prototype，使用for-in也會將prototype的屬性列舉出來，不使用檢查也沒問題，只要你可以預期你的程式碼，但如果你不確定的話，最好還是加上去。 另一種過濾方法 var i, hasOwn = Object.prototype.hasOwnProperty;for (i in man)&#123; if(hasOwn.call(man, i)&#123; console.log(i, ':', man[i]) &#125;&#125; 不要擴充內建型別的原型如果擴充Object()、Array()，或是Function()，可能會讓程式碼難以預測。 以下可破例的狀況： 可預期 ECMA 將你新增的方法實作為未來瀏覽器可能有用的功能 你確定你的方法在原生的 prototype 不存在，也沒有在其他程式碼中被實作過。 你已經清楚與你的團隊溝通這個變更並文件化 switch 模式 將每個 case 與 switch 並排（這是大括號規則的例外） 將每個 case 內的程式碼縮排 用清楚的break;結束每個 case 避免未完結的 case （意思就是特別刪除break），如果堅決如此，應該寫文件說明 用一個default:結束 switch ，以確保都有合理的結果 避免隱含的型別轉換JavaScript 在比較變數時會做隱含的型別轉換，例如：false == 0或&quot;&quot; == 0皆會回傳 true 。 建議皆使用 === 和 !== 以維持程式碼的一致性，也可以減少一些精神閱讀。 避免使用 eval()eval 會將傳入的字串當作程式碼執行，同樣傳遞字串給 setInterval()、setTimeOut() 和 Function()也是如此。 為了避免安全性的問題，應避免使用 eval()。 new Function() 建構式和 eval() 非常接近，假設真的非用 eval() 那不如使用 new Function() 建構式取代，優點是在函式作用域中執行，只要使用 var 宣告的變數都不會自動變成全域變數，而使用 eval() 則是在全域的環境執行。 另外注意：Function 與 new Function() 是不同的。 使用 parseInt() 轉型成數值使用 parseInt() 將一個字串轉換成數值，第二個參數是轉型用的基數，第二個參數通常會被忽略，然而不該如此。如果當要轉換的字串開頭為 0 時，而又忽略第二個參數，基數可能為 10 或 8 ，具體狀況則要根據瀏覽器環境而決定。 將字串轉為數值也可使用Number()。 編碼規範縮排不統一的縮排比沒縮排更糟糕。 大括號在 if 或 for 的單行敘述，不加大括號可以執行，但應該加上大括號，以避免新增新的一行導致錯誤。 左括號的位置有些狀況下會因為括號的位置造成程式執行結果不同，影響原因是因為分號插入機制，如果在行尾遺漏分號，JavaScript 會自動補齊，但應該永遠在行尾加入分號，避免 JavaScript 隱晦的補上，而導致程式碼有含糊之處。 空格建議使用空格的地方： 區隔 for 迴圈各部分分號之後 for 迴圈，初始化多個變數之間 區隔 array 物件的逗號之後 物件屬性間的逗號之後，以及區隔 key/value 的分號之後 區隔參數的逗號之後 區隔函式宣告的左括號之前 匿名函式的 function 之後 區隔所有運算元及運算子 在左大括號（{）之前 命名慣例讓建構式字母為大寫將建構式命名為大寫，可快速辨別是建構式還是普通函式。 字詞的分隔方式針對建構式可用大駝峰寫法，一般函式使用小駝峰寫法，非函式的變數也可以用全小寫，中間底線區隔。 其他命名模式在整個程式的生命週期都不會變動的常數，可採用全大寫的命名方式。還有一種 private 成員命名慣例是在屬性和方法前面加上底線，以表示為 private 。 下方為其他 _private 規範的變化： 在變數尾巴加上底線表示。 用一個底線的前綴作為 _protected 屬性、用兩個底線作為 __private 屬性。 Firefox 有一些內部屬性命名前後都會加上兩個底線。 撰寫註解通常要為每個函式的參數、回傳值以及不常見的技術編寫註解。假設你有五到六行的程式碼來執行一個工作，用一行簡單敘述程式碼的目的為何寫在此，之後閱讀程式碼的人就不用詳讀細節。 持續更新註解，過時的註解比沒註解更糟 撰寫 API 文件推薦工具： JSDoc Toolkit YUIDoc API 文件生成 發布工具產生的結果（通常是 HTML 頁面） 撰寫特別格式的程式碼 執行工具來分析程式碼和註解 練習寫註解區塊： /** * 反轉一個字串 * * @param &#123;String&#125; 輸入字串來做反轉 * @return &#123;String&#125; 反轉後的字串 */var reverse = function (input)&#123; // ... return output;&#125;","link":"/javascript-design-pattern-chapter02/"},{"title":"【讀書筆記】JavaScript Design Pattern Chapter03 實字與建構式","text":"此章解釋為何實字標記會比內建建構式（new Object()、new Array()）還好，主要傳達就是訊息的延伸（避免用建構式並用實字替代）。 物件實字 名值對的雜湊表，類似其他語言的關聯式陣列。 值可以是原始型別或另一個物件，稱之屬性；值可以是函式，稱為方法。 JavaScript 允許任何時刻改變、移除、增加屬性和方法。 物件實字語法 將物件用大括號（{}）包起來 以逗號分格每個屬性和函式 分號分隔屬性名稱和屬性值 將物件賦予給變數，記得右大括號後要加上分號 用建構式創造物件JavaScript 沒有 class，但有建構函式，它使用非常類似其他語言以 class 為基礎的物件建立語法。 var car = &#123; goes: 'far' &#125;;// 實字var car = new Object();car.goes = 'far';//建構式 實字是更好的物件建立模式，程式碼比較短，且實字不需要作用域的判斷，意思就是你可能會創造其他相同名稱的區域建構式，而解譯器需要你從呼叫的 Object() 所在的作用域，一路向外查找整個作用域鍊，直到找到 Object() 建構式。 自訂建構式以 new 來呼叫建構式，會經過以下流程： 建立一個空物件，參考至 this 變數，並繼承此函式的原型 藉由 this 的參考，將屬性和方法加入到此物件 這個 this 所參考的物件，會隱晦地回傳出去 如下 var Person = function(name) &#123; // 使用物件實字 // 建立一個空物件 // var this = &#123;&#125;; this.name = name; this.say = function() &#123; return \"I'm\" + this.name; &#125;; //return this; //隱晦回傳&#125;; 將 say() 方法加入 this ，每次呼叫 new Person() 一次，一個新的函式就會建立在記憶體中，這樣是非常消耗效能的，較好的方法是加入到原型中： Person.prototype.say = function() &#123; return 'I am' + this.name;&#125;; 只要可重複利用的成員，例如方法，都應該放入原型。上述的建立空物件，並不是真的空，比較像是：var this = Object.create(Person.prototype);。 建構式的回傳值在建構函式中，沒有使用 return 的敘述，預設就是回傳 this 所參考的物件，另外你也可以自由回傳任何物件，只要是物件就好，如果回傳的不是物件就會被忽略，回傳就會是 this 所參考的物件。 強制 new 模式建構式只是用 new 呼叫，但本質還是函式，如果忘記加上 new，建構式中的 this 會指向全域物件，例如在瀏覽器中會指向 window ，這樣的行為如同替全域物件加上屬性，因此必須要使用 new 呼叫建構式。 命名慣例建構式的名字首部大寫，其他一般函式則首字小寫。 使用 thatfunction Wattle() &#123; var that = &#123;&#125;; that.tasts = 'yummy'; return that;&#125; 等同於 function Wattle()&#123; return &#123; that.tasts = 'yummy'; &#125;;&#125; 使用 that 輸出結果與一般建構式結果無異，但如果使用 that 方法，會讓建構式失去原本繼承的 prototype 屬性，物件實體會和原型本身失去連結。 自我呼叫的建構式為了解決前一個模式的問題，讓物件實體可以使用原型可以考慮以下方法： function Waffle() &#123; if (!(this instanceof Waffle)) &#123; return new Waffle(); &#125; this.tastes = 'yummy';&#125;Waffle.prototype.wantAnother = true; 令人好奇的陣列實字當你傳入單一數值給 new Array() 該數值不會變成陣列的第一個元素，而是變成陣列的長度，如果傳入一個符點數，就會造成錯誤。 檢查陣列陣列的型別是物件，但如果要檢查一個值是不是陣列，可以用程式檢查 length 屬性是否存在，更健全的方法是使用 isArray 方法，但如果環境不支援此方法，可對陣列呼叫 toString 的 call 方法，應會回傳[Object Array]。 JSONJSON 和物件實字在語法上唯一不同是 JSON 屬性名稱須用引號包起來，對於物件實字，屬性名稱只有在不合法的狀況下才需要包，例如中間穿插空格。在 JSON 中不可以使用函式及正規表示式實字。 正規表示式實字JavaScript 的正規表示式也是一種物件，可以透過兩種方式建立： 使用 new RegExp() 建構式 使用正規表示式實字 var re = /\\\\/gm;//實字var re = new RegExp('\\\\\\\\', 'gm'); 使用正規表示式實字符號需要跳脫字元，甚至經常需要兩個反斜線。 正規表示式實字語法正規實字符號使用斜線（”/“）來包住檢查對應的正規表示格式，第二個斜線後面可以加入格式的修飾詞，修飾詞的格式是不加引號的字母： g：全域檢查 m：檢查多行 i：不分大小寫 使用實字和建構式之間的差異： 遇到接受正規表示物件的函數（String.prototype.replace()），使用實字可以讓程式碼更簡潔 正規表示格式無法事先得知，而是要在執行階段才能知道，可使用建構式。 實字在語法解析時就已產生，而且只產生一個物件。如果在迴圈中使用同樣的正規表示式，前面建立的物件就會回傳，而且保留已設定過的所有屬性。 如果不使用 new 呼叫 RegExp() ，行為如同有使用 new。 原始型別包裹JavaScript 有五種原始型別：數值、布林、字串、物件、null、undefined ，除了最後兩種，其餘型別皆有原始型別包裹物件。包裹物件可使用建構式來建立。 包裹物件（new Number()…）擁有一些屬性和方法可以使用，但原始數值在呼叫方法時，會在背後暫時轉型為一個物件，因此可以表現得像物件一樣使用那些屬性和方法。 使用包裹物件唯一理由是，你想要擴充並保持狀態，因為原始物件不是物件，他們無法擴充以新增屬性，但擴充字串、布林、數字，這些狀況很少用到，狀況如下： var greeting = 'hello';//原始字串greeting.split(' ')[0]; //hello//暫時轉型成物件，可使用方法greeting.smile = true;//企圖擴充原始型別不會產生錯誤typeof greeting.smile; //undefined//但其實沒有用 錯誤物件JavaScript 有數個內建的錯誤物件，隨著 thorow 敘述一起使用：Error()、SyntaxError()、TypeError() 等等，這些錯誤物件具有下列屬性： name：建立錯誤物件的建構式函式名稱 message：建立錯誤物件時傳遞給建構式的字串 throw 可以跟任何物件一起運作，不一定是錯誤物件，可搭配 catch 敘述去處理資訊，錯誤物件的建構式如果沒有用 new 呼叫，結果會跟使用建構式呼叫一樣。","link":"/javascript-design-pattern-construction/"},{"title":"【讀書筆記】JavaScript Design Pattern Chapter04 函式（上）","text":"接下來會學習到不同定義的函式，首先是函式表達式和函式宣告式，接著看函式作用域與 hosting 如何運作。 背景JavaScript 有兩個主要特色： 函式屬於 JavaScript 第一級物件（first-class object） 函式提供作用域 函式也是物件： 可在執行期、程式執行的過程中動態建立 可以指定給變數，也可將參考複製給其他變數，可以被擴充，而且除了少數其他狀況外，也可以被刪除 可以作為參數傳遞給其他韓式，也可以作為其他函式的回傳值 可以有自己的屬性和方法 使用 Function 建構式跟使用 eval 一樣糟糕，因為程式碼使用字串的形式傳遞並執行，就必須跳脫字元，如此讀寫都很不方便。 JavaScript 中沒有大括號內的區域作用域，沒有區塊範圍，區塊並不產生有效的作用域，JavaScript 只有函式作用域，任何在函式裡面宣告的 var 變數 都是區域變數。 釐清術語的差別var add = function(a, b) &#123; return a + b;&#125;; 具名的函式表示式，又稱匿名函式，與函式宣告式的差別是函式物件的 name 屬性會是個空字串，具名的函式表示式和函式宣告式看起來類似，但表示式在結尾需要分號，而表達式不用。 函式實字也是常用的術語，但他可能代表函式表示式也可能代表具名韓式表示式，模凌兩可，最好不要用此術語。 宣告式 v.s. 表示式：命名與 Hoisiting那該使用函數宣告式還是表示式呢？當語法不能使用宣告式就可以使用表示式，例如：將函式物件作為參數傳遞、物件實字內定義方法。 函式宣告式只能出現在 program code 裡面，意思是函式本體或全域空間中，他們定義無法賦值給變數或其他屬性，或作其他函式的參數。 函式的 name 屬性對函式宣告式和具名函式表達式，name 屬性都有定義。對匿名函式表達式說，name 可能為 undefined 或空字串。name 屬性也會用來遞迴呼叫自己，或是在除錯工具中顯示函式名稱，如果這兩種狀況都沒有需要，用不具名表達式會比較簡單也不囉唆。 技術上來說可以將一個具名函式表示式指派給另一個名稱的變數，但不是所有瀏覽器都支援，因此不建議這樣做。 函式的 Hoisting所有變數無論被定義在函式中哪處，都會在幕後被提升到函式最前端。 function foo() &#123; console.log('global foo');&#125;function bar() &#123; console.log('global bar');&#125;function hoistMe() &#123; console.log(typeof foo); // 'function' console.log(typeof bar); //'undefined' foo(); // local foo bar(); // TypeError:bar is not function function foo() &#123; console.log('local foo'); &#125; // 變數 foo 和實作都被提升 var bar = function() &#123; console.log('local bar'); &#125;; // 僅有變數 bar 被提升，不包含實作，所以是 undefined&#125;hoistMe(); 回呼模式函數是物件，意思就是可以作為參數傳遞給其他函式。 回呼與作用域回呼並非是一次性的匿名函式或者全域函式，而是某個物件的方法，如果回呼的方法使用了 this 去參考其所屬的物件，this 會參考到全域物件，解決方法是除了傳遞回呼函式，額外傳遞回呼函式所屬物件，並使用 call 改變 this 的指向。 逾時當使用 setTimeout 或 setInterval ，函數在作為變數傳遞時沒有加上括號，因為你不是想立刻執行它，而是指向它，讓 setTimeout 或 setInterval 稍後可以使用。 回傳函式有個函式做了一個工作，可能是一些初始化，接著就對其回傳值工作，回傳值剛好是另一個函式： var setup = function() &#123; alert(1); return function() &#123; alert(2); &#125;;&#125;;var my = setup();my(); var setup = function() &#123; var count = 0; return function() &#123; return (count += 1); &#125;;&#125;;var next = setup();next(); //1next(); //2next(); //3next(); //4 自我定義函式函式可以動態建立，且可以指派給變數。建立新函式，並指派給同一個變數，此變數原本指向的舊函數就會被覆蓋成新的。 var scareMe = function() &#123; alert('boo!'); scareMe = function() &#123; alert('double boo!'); &#125;;&#125;;scareMe();scareMe(); 使用這種模式可以顯著提升效能，當函式一部份不需要的狀況下，就可以使用自我定義的函式更新自身的實作。這個模式另一個名字叫做懶惰的函式定義，因為這種函式在第一次使用之前都沒有正確定義，而之後就會變得懶惰。 此函數的缺點在它重新定義自身之前你加到原始函式的屬性都會遺失，如果使用不同名稱，例如新函式指派給另一個變數或是物件的另一個方法，那重新定義的部分就不會執行，而原始的函式本體就會執行。 以另一個例子來說，這次 scareMe() 函式要用第一級物件的使用方式： 加入一個新的屬性 將函式物件指派給新變數 函式也作為方法使用 // 1.加入一個新屬性scareMe.property = 'properly';// 2.賦值給一個不同名稱var prank = scareMe;// 3.作為一個方法來使用var spooky = &#123; boo: scareMe,&#125;;// 用新的名稱呼叫prank(); //booprank(); //booconsole.log(prank.property); // properly// 用方法呼叫spooky.boo(); //boospooky.boo(); //booconsole.log(spooky.boo.property); // properly// 用自我定義函式呼叫scareMe(); //double boo!scareMe(); //double boo!console.log(scareMe.property); //undefined 當自我定義函式被賦值給一個新變數時，他沒有照你預期，每一次呼叫 prank(); 都會印出 boo，同時覆蓋全域的 scareMe(); 函式，但 prank(); 自己仍保有舊有的定義，包含 property 屬性。 這些每次的呼叫都會重新覆蓋 scareMe(); 的指標，所以最終呼叫它，它擁有的是第一次就被更新的主體，會印出 double boo! ，同時也沒有 property 屬性。 立即函式此模式本質上是一個函數表示式，並在定義後立刻執行。立即函式由下面部分所組成： 用函式表示式定義函式 在函式最後加上括號，這樣會讓函式立刻執行 整個函式包在括號中（如果不將函式賦予給一個值才需要） 立即函式可以賦予程式碼作用域，有時候通常工作只要執行一次，沒有理由再去寫具名函式，有時候工作會需要暫時性變數，初始化後，變數會被洩露為全域變數，立即函式可以避免這個狀況。 立即函式的參數立即函式可以傳遞參數，但不應該傳太多，這樣容易造成理解時的負擔。 立即函式的回傳值立即函式可以有回傳值，而這些函式可以賦值給變數： var result = (function() &#123; return 2 + 2;&#125;)(); 或是省略包著函式的括號，因為將立即函式的回傳值賦值給變數時不需要括號。 var result = (function() &#123; return 2 + 2; //4&#125;)(); 但可能會誤導，因為沒注意函式後面的括號，可能會以為 result 指向的是函式，但其實 result 是立即函式的回傳值。 但除了原始型別外，立即函式可以回傳任何型別的值，包含回傳函式，如此就可以利用立即函式私有的作用域儲存 private 資料。 這個範例中，立即函式回傳是一個函式，他會賦值給變數 getResult ，作用是簡單回傳 res ，它已經預先算好，存在立即函式的 closure。 var getResult = (function() &#123; var res = 2 + 2; return function() &#123; return res; &#125;;&#125;)(); 立即函式也可以用來定義物件屬性，假設你需要一個屬性，但在定義之前需要一些運算才能得到正確的值，而立即函式的回傳值就成為該屬性的值。 var o = &#123; msg: (function() &#123; var who = 'me'; what = 'call'; return what + ' ' + who; &#125;)(), getMsg: function() &#123; return this.msg; &#125;,&#125;;o.msg; //call meo.getMsg; //call me 優點及用法 將運算包裝，不必留下全域變數 將程式模組化，包裝到立即函式中","link":"/javascript-design-pattern-function01/"},{"title":"【讀書筆記】JavaScript Design Pattern Chapter04 函式（下）","text":"另一種類似立即函式且避免全域污染的方式，此模式建立一個物件，並帶有 init 方法，建立物件後立即執行 init 做初始化。 立即物件初始化另一種類似立即函式且避免全域污染的方式，此模式建立一個物件，並帶有 init 方法，建立物件後立即執行 init 做初始化。 (&#123; maxwidth: 500, maxheight: 30, gimmeMax:function ()&#123; return this.maxwidth + \"x\" + this.maxheight &#125;, init:function() &#123; console.log(this.gimmeMax();) &#125;&#125;).init(); 用括號包起物件實字，關閉括號之後立即呼叫 init ，意思就是下方兩種寫法都成立。 (&#123;...&#125;).init();(&#123;...&#125;.init()); 優點： 與立即函式相同，執行一次性初始化工作，也不會汙染全域物件 適合一次性工作 初始階段的分支將功能分開測試，並使用初始化分支做唯一一次檢查。 函式屬性——記憶模式任何函式都具有length屬性，用來表示預期接收的參數數量。 function func(a, b)&#123; ... &#125;console.log(func.length); //2 可以隨時將你的函式新增屬性，一種自訂屬性的案例是用它來快取函式的運算結果（回傳值），快取函式的結果也被稱為記憶模式。 假設限定函式只接受原始型別的參數，如果有更複雜的參數，可以將參數序列化，化為一個 JSON 字串，並用此字串作為 catch 物件的鍵值。 序列化後，物件的識別會消失，如果有兩個不同物件但剛好有相同屬性，這兩個物件會共用同一個快取項目。 設定值物件設定值模式是提供乾淨 API 的一種方式，在建立函式庫或是給其他開發者使用的程式，此模式會特別有效。 在編寫函式時需要傳遞大量參數，有一種更好的方法，就是將所有參數替換成唯一一個，讓此參數變成一個物件來表示設定值。 var conf = &#123; username: 'batman', first: 'Bruce', last: 'Wayne',&#125;;addPerson(conf); 設定設定值的優點： 不需要記住參數和順序 可以更安全略過選用參數 更容易閱讀和維護 更容易新增和移除參數 缺點： 需要知道參數名稱 設定值物件的屬性名稱無法被最小化 Curry函式的應用在純函式的程式語言中，函式並不是被呼叫而是被應用，因為 JavaScript 的函式其實是物件而且有自己的方法。 // 定義函式var sayHi = function(who) &#123; return 'Hello' + (who ? ',' + who : '') + '!';&#125;;// 呼叫函式sayHi(); // \"Hello\"sayHi('world'); // 'Hello, world'// 應用函式sayHi.apply(null, ['hello']); //Hello, hello 呼叫函式和應用函式的結果都相同，apply() 需要兩個參數，第一個參數是物件，用來綁定函式內部的 this，第二個參數是參數陣列，會成為函式內可使用的類陣列 arguments 物件。如果第一個參數值是 null ，則 this 會指向全域物件，這正是當你呼叫一個非物件內方法的函式時會發生的事。 如果函式是某物件的方式，就不會像前面例子傳遞 null 參考，而物件會成為 apply 的第一個參數。 var alien = &#123; sayHi : function (who) &#123; return \"Hello\" + (who ? \",\" + who : \"\") + \"!\"; &#125;;&#125;sayHi.apply(alien, [\"hello\"]); 除了 apply 之外，有另一個 call 方法，可省下建立陣列的工作。 部分應用程式碼的執行過程： // 定義函式function add(x, y)&#123; return x + y;&#125;// 知道參數並呼叫add(5, 4);//程式執行：步驟一function add(5, y)&#123; return 5 + y;&#125;//程式執行：步驟二function add(5, 4)&#123; return 5 + 4;&#125; 此階段步驟一可稱為部分應用，意思是用第一個參數替換函式中的未知數，但我們並沒有得到結果（解答），而是得到另一個函式。 現在讓我們假想一個函式叫做 partialApply()。（以下為非正規用法） function add(x, y) &#123; return x + y;&#125;//全應用add(5, 4);//部分應用var newadd = add.partialApply(null, [5]);newadd.apply(null, [4]); //9 部分運用給了另一個函式，該函式可以在之後用別的參數呼叫，等同於 add(5, 4); ，因為 add(5) 會回傳一個函式，於是可以用 (4) 呼叫，換句話說 add(5, 4); 只是 add(5)(4) 的語法糖。 這種單一輸入、單一輸出並讓函式可以理解，並處理部分應用的過程，稱為 curry 化。 Currycurry 是一種轉換的過程——我們在轉換函式。（拆解函式） 泛用的 curry 化函式： function curry(fn) &#123; var slice = Array.prototype.slice, stored_args = slice.call(arguments, 1); // arguments : curry 的參數。因為傳進參數的第一個參數值是 function 必須刪除， // 但因為參數是類陣列，無法用陣列的方法，因此用 call 將 slice 指向 arguments，使arguments 為陣列，以使用陣列的方法，並刪除第一個參數。 // 如同：arguments.slice(1); return function() &#123; var new_args = slice.call(arguments), // 第二組傳入的參數，同上，將參數轉陣列 args = stored_args.concat(new_args); //將第一組和第二組傳入的參數合併 return fn.apply(null, args); //將合併的新參數傳入 fn &#125;;&#125; 承上，新解釋範例如下： function add(x, y) &#123; return x + y;&#125;var newadd = curry(add, 5);newadd(4); //9//另一種寫法curry(add, 6)(7); //13 第二個範例： function add(a, b, c, d, e) &#123; return a + b + c + d + e;&#125;//可以轉換任何數量的參數curry(add, 1, 2, 3)(5, 5);//兩步驟的 curry 也可以。var addOne = curry(add, 1);addOne(10, 10, 10, 10); //41 使用 Curry 的時機當呼叫某個函式，發現傳入的參數大多相同，這時可以用柯里化，可以運用部分應用的方式，傳入一些參數給函式，並動態產生新的函式，新函式幫你保留重複的那些參數，於是不用每次都傳遞，並用他們預先填入原始函式，預期接受完整的參數列。 //不使用柯里化add(1, 2, 3, 'abby');add(1, 2, 3, 'leia');add(1, 2, 3, 'jammy');add(1, 2, 3, 'lisa');//使用柯里化var curryFn = curry(add, 1, 2, 3);curryFn('abby');curryFn('leia');curryFn('jammy');curryFn('lisa'); 總結 JavaScript 是第一級物件，他們可以和原始型別值）一樣作為參數傳遞，也可以擴充屬性和方法。 函式提供區域作用域，而大括號產生的區塊則沒有，區域變數的宣告會被提升到區域作用的頂端。 建立函式的語法： 具名函式表示式 函式表示式：和上一個相同，只是缺少名字，也稱為匿名函式 韓式宣告式：類似其他語言 好用的函式模式： API 模式：使函式介面更簡潔 - 回呼模式：將函式作為參數傳遞 - 設定值物件：幫助你讓函式的參數數量 - 回傳函式：函式的回傳值是另一個函式 - curry 化：用現有的函式加上部分參數列產生新的函式 初始化模式：結構化的方式來執行初始和設定，不會因暫時變數污染全域 - 立即函式：定義後立即執行 - 立即物件初始化：結構化初始工作被包進一個匿名函式中，此模式提供一個立即呼叫的方法。 - 初始階段的分支：初始階段執行唯一一次分支，而不是在應用程式的生命週期中執行許多次。 效能模式： - 記憶模式：使函式屬性暫存，運算過的值不必重複運算 - 自我定義函式：函式使用新的定義覆蓋自己，在第二次呼叫過後省下工作","link":"/javascript-design-pattern-function02/"},{"title":"【讀書筆記】JavaScript Design Pattern Chapter05 物件建立模式（上）","text":"可以降低全域變數的需求量，幫忙避免命名衝突和過度的名稱前綴詞。JavaScript 沒有內建的命名空間，為了避免一堆函式、變數、物件污染全域空間，應該要建立一個全域物件。 命名空間可以降低全域變數的需求量，幫忙避免命名衝突和過度的名稱前綴詞。JavaScript 沒有內建的命名空間，為了避免一堆函式、變數、物件污染全域空間，應該要建立一個全域物件。 var MYAPP = &#123;&#125;;//全域物件MYAPP.Parent = function () &#123;&#125;;//建構式MY.somevar = =1;//變數MYAPP.modules.modules1 = &#123;&#125;;MYAPP.modules.modules1.data = &#123;a:1&#125;;//巢狀物件 應該用全大寫表示全域變數，讓他特別明顯（另外注意常數也是全大寫）。 缺點： 越長的巢狀名稱表示更長 唯一的全域實體代表任何程式碼都可以變更這個實體，而接下來的功能也都會使用變更後的狀態。 要多打一點字，它相當於在每個變數和函數之前加上前綴詞。 泛用的命名空間函式有些你正要加入命名空間的屬性也許早已存在了，於是會不小心覆蓋它，因此最好建立命名空間和新增屬性前，先檢查是否存在。 if (typeof MYAPP === 'undefined') &#123; var MYAPP = &#123;&#125;;&#125;// 檢查全域var MYAPP = MYAPP || &#123;&#125;;//簡短寫法 但如果遇到巢狀物件，必須對每個物件或屬性檢查，此時需要一個函數幫忙做檢查細節。 MYAPP.namespace('MYAPP.module.module2');//效果等同於：//var MYAPP = &#123;// module: &#123;// module2: &#123;&#125;// &#125;//&#125;var MYAPP = MYAPP || &#123;&#125;;MYAPP.namespace = function(ns_str) &#123; var parts = ns_str.split('.'), parent = MYAPP, i; //去除最前投多餘的全域名稱 if (parts[0] === 'MYAPP') &#123; parts = parts.slice(1); &#125; for (i = 0; i &lt; parts.length; i += 1) &#123; if (typeof parent[parts[i]] === 'undefined') &#123; parent[parts[i]] = &#123;&#125;; &#125; parent = parent[parts[i]]; &#125; return parent;&#125;; 允許下列做法： var m2 = MYAPP.namespace('MYAPP.module.module2');m2 === MYAPP.module.module2; //true//將回傳值指派給區域變數MYAPP.namespace('module.module2');//忽略開頭的MYAPPMYAPP.namespace('MYAPP.once.upon.the.time');//很長的命名空間 宣告相依性JavaScript 通常會使用命名空間，並讓良好的模組化，讓你可以只引用你需要的模組。 將與你程式碼相依的模組，宣告在函式或是模組頂端，這樣意味者建立唯一一個區域變數，並指向所需的模組。 var myFunction = function() &#123; var event = YAHOO.util.Event, dom = YAHOO.util.Dom; //使用event, dom&#125;; 好處： 宣告相依性，揭示你程式碼的使用者可以了解他們需要哪些相依模組需要引用 宣告在函式頂端，較容易找到並解決相依性 使用區域變數比找全域變數快，更比起全域變數的巢狀屬性快。採用相依性模式，只需要在函式使用全域變數一次就好。 有些最小化工具會重新命名區域變數，但不會去更改全域變數，因為不安全。 比較： //未使用function oldFn() &#123; alert(MYAPP.modules.m1); alert(MYAPP.modules.m2); alert(MYAPP.modules.m3);&#125;//最小化alert(MYAPP.modules.m1);alert(MYAPP.modules.m2);alert(MYAPP.modules.m3);//使用function newFn() &#123; var modules = MYAPP.modules; alert(m1); alert(m2); alert(m3);&#125;//最小化var a = MYAPP.modules;alert(a.m1);alert(a.m2);alert(a.m3); Private 屬性與方法JavaScript 所有的物件成員都是 Public。 var myobj = &#123; myprop: 1, getProp: function() &#123; return this.myprop; &#125;,&#125;;console.log(myobj.myprop); // myprop 可被 public 存取console.log(myobj.getProp()); // getProp() 也是 public Private 成員雖然語言本身沒有提供特殊語法，但可以用閉包來實作，任何屬於閉包作用域的變數都不會暴露在建構式之外，以下舉例： function Gadget() &#123; //private 成員 var name = 'iPod'; //public 方法 this.getName = function() &#123; return name; &#125;;&#125;var toy = new Gadget();console.log(tou.name); //undefinedconsole.log(toy.getName()); //\"iPod\" 在 JavaScript 表現隱私權很容易，將想要保持 Private 的資料用函式包起來，且確保他是函式的區域變數，為了是不要讓他在函式外被存取。 特權方法存取 private 成員的 public 方法的一個名字。 上一個 getName() 就是一個特權函式，因為他對 name 屬性有特別的存取權。 隱私權錯誤當你直接從特權函式回傳一個 private 變數，且這個變數是個物件或陣列時，外圍的程式碼仍可以更改 private 變數，因為傳遞的是變數的參考。 function Gadget() &#123; var specs = &#123; screen_width: 320, screen_height: 480, color: 'white', &#125;; this.getSpecs = function() &#123; return specs; &#125;;&#125;var toy = new Gadget(), specs = toy.getSpecs();specs.color = 'black';specs.price = 'free';console.dir(toy.getSpecs()); 小心！不要回傳想要保持 private 的物件或陣列參考。 讓 getSpecs() 回傳一個新的物件，物件中僅需要使用者所需要的資料(最低授權原則)。 建立一個 specs 物件的複本，你可以使用常用的的複製物件函式。 之後會提到 extend ，它會對物件做一個淺層複製（只複製最上一層的參數），另一個為 extendDeep 他會以遞迴的方式複製所有的屬性和他們所擁有的巢狀屬性。 最低授權原則：以這個範例來說，假設 Gadget 的使用者對於此元件的大小是否符合感興趣，那僅需要的只有大小而已。因此你給全部，不如新的函式，讓函式回傳包含寬和高的物件，甚至你可能都不需要 getSpecs 方法。 物件實字與隱私權前面的範例都是使用建構式，那如果使用物件實字仍可能使用 private 成員嗎？ 你所需要只是要將 private 成員用函式包起來，如果是物件實字可以使用立即函式來建立閉包。 var myobj;(function() &#123; var name = 'oh, mygod'; myobj = &#123; getName: function() &#123; return name; &#125;, &#125;;&#125;)();myobj.getName(); // \"oh, mygod\" 用另一個相同概念的方法寫： var myobj = (function() &#123; var name = 'oh, mygod'; return &#123; getName: function() &#123; return name; &#125;, &#125;;&#125;)();myobj.getName(); // \"oh, mygod\" Prototypes 與隱私權使用建構式所產生的 private 成員，他們在每次建構式呼叫產生新物件時都重新建立，這是建構式每個 this 成員都有的缺點。 解法：將共同屬性和方法加到 prototype 屬性中，如此所有相同建構式的實例都會共享，實體之間也能共享隱藏的 private 成員。 可以用建構式中的 private 屬性和物件實字的 private 屬性來組合，因為 prototype 也是物件，所以可以用物件實字來建立。 function Gadget() &#123; var name = 'iPod'; this.getName = function() &#123; return name; &#125;;&#125;Gadget.prototype = (function() &#123; var browser = 'mobile webkit'; return &#123; getBrowser: function() &#123;&#125;, &#125;;&#125;)();var toy = new Gadget();console.log(toy.getName());console.log(toy.getBrowser()); 將 Private 函式揭露成 Public揭露模式：將 private 方法揭露為 public 方法的模式。 假設物件中的所有功能都對物件來說很關鍵，於是你可能想盡可能保護此物件，但同時希望 public 方法來存取他的一些功能，就很適合用揭露模式。 當揭露方法是 public ，物件會變得很脆弱，時時暴露在可能不小心被修改的風險之下。 先來第一種範例，建立在其中一種私有權模式上物件實字的 private 成員模式： var myarr;(function() &#123; var astr = '[object Array]', toString = Object.prototype.toString; function isArray(a) &#123; return toString.call(a) === astr; &#125; function indexOf(haystack, needle) &#123; var i = 0, max = haystack.length; for (; i &lt; max; i += 1) &#123; if (haystack[i] === needle) &#123; return i; &#125; return -1; &#125; &#125; myarr = &#123; isArray: isArray, indexOf: indexOf, inArray: indexOf, &#125;;&#125;)(); astr 和 toString 為 private 變數，isArray 和 indexOf 為 private 函式，結尾出現 myarr 物件，裡面包含允許揭露的 public 功能。 myarr.isArray([1, 2]); // truemyarr.isArray(&#123; 0: 1,&#125;); // falsemyarr.indexOf(['a', 'b', 'z'], 'z'); // 2myarr.inArray(['a', 'b', 'z'], 'z'); // 2 myarr.indexOf = null;myarr.inArray(['a', 'b', 'z'], 'z'); // 2 現在如果發生預料之外的事在 public 的 indexOf 上，但 private 的 indexOf 函式仍然是安全的，所以 inArray() 仍然可以運作。","link":"/javascript-design-pattern-object01/"},{"title":"【讀書筆記】JavaScript Design Pattern Chapter05 物件建立模式（下）","text":"模組模式提供了結構化，所以被廣泛使用，JavaScript 沒有專給套件用的特殊語法，而模組模式提供工具，來建立自成一體且去耦合的程式碼。 模組模式模組模式提供了結構化，所以被廣泛使用，JavaScript 沒有專給套件用的特殊語法，而模組模式提供工具，來建立自成一體且去耦合的程式碼。 模組模式是數種模式的組合： 命名模式 立即函式 Private 成員和特權方法 宣告相依性 第一步：建立命名空間——參考之前使用 namespace() 建立出 utility 模組範例： var MYAPP = namespace('MYAPP.utilities.array'); 第二步：定義模組。此模組使用一個立即執行函式，如果需要隱私權就提供 private 作用域，立即函式會回傳一個物件：真正的模組，有自己 public 介面，給模組的客戶使用： MYAPP.utilities.array = (function() &#123; return &#123; //... &#125;;&#125;)(); 接著新增一些 public 方法： MYAPP.utilities.array = (function() &#123; return &#123; inArray: function(needle, haystack) &#123; //... &#125;, isArray: function(a) &#123; //... &#125;, &#125;;&#125;)(); 揭示模組模式前面介紹隱私權模式的時候已經討論過揭露模式，請參考前面範例，就是讓縮有方法保持 private 而僅在最後建立 public API。 產生建構式的模組有時候建構式建立物件會更方便，唯一的差別就是包裝模組的立即函式回傳的不是物件，是函式。 MYAPP.utilities.array = (function() &#123; // 宣告相依性 var uobj = MYAPP.utilities.object, ulang = MYAPP.utilities.lang, // private 屬性跟方法 Constr; //Public API —— 建構式 Constr = function(o) &#123; this.elements = this.toArray(o); &#125;; //Public API —— 原型 Constr.prototype = &#123; consturctor: MYAPP.utilities.Array, version: '2.0', toArray: function(obj) &#123; for (var i = 0, a = [], len = obj.length; i &lt; len; i += 1) &#123; a[i] = obj[i]; &#125; return a; &#125;, &#125;; // 回傳建構式 // 給新的命名空間 return Constr;&#125;)();var arr = new MYAPP.utilities.Array(obj); 引進全域物件你可以傳遞參數給包裝模組的建構式，通常是全域變數的參考，甚至是全域物件的本身，引入全域物件可以幫忙加速立即函式的執行，因為引入的變數對函式來說而言已經是區域的。 MYAPP.utilities.module = (function(app, global) &#123; //全域物件的參考 //還有全域命名空間的物件 //現在都為區域&#125;)(MYAPP, this); 沙盒模式沙盒模式提供一個環境讓模組執行，此環境不會影響其他模組或沙盒。 除此之外，也解決了命名模式的缺點： 命名模式依賴一個全域變數，不可能在同一頁面上讓同一個函式庫或程式的兩種版本同時執行，因為他們都需要全域符號。 命名空間需要輸入很長的明稱，執行時需要解析多層的命名。 一個全域建構式全域物件的差別： 命名空間模式：全域物件。 沙盒模式：全域建構式。 利用這個建構式來建立物件，並同時傳遞一個回呼函式，此函式會讓沙盒看起來像一個孤立的環境。此建構式看起來像上個 MYAPP 範例。 new Sandbox(function (box))&#123; //here is the code&#125;); 再新增兩個特性： 建立物件時可以使用 new ，也可以不用。 建構式可以額外接受一些設定值參數，來指定該物件實體所需要的模組名稱。 略過 new 並用虛構的「ajax」、「event」模組來建立： Sandbox(['ajax', 'event'], function(box) &#123; //console.log(box);&#125;); 拆成個別參數傳遞的用法： Sandbox('ajax', 'dom', function(box) &#123; //console.log(box);&#125;); 當沒有傳遞任何模組的時候： Sandbox('*', function (box) &#123; //console.log(box);&#125;Sandbox(function (box) &#123; //console.log(box);&#125;); 巢狀化： Sandbox('dom', 'dom', function(box) &#123; Sandbox('ajax', function(box) &#123; //兩邊的 box 物件是不同的 // ajax &#125;); //這邊的程式不會有 ajax 模組&#125;); 這邊可以看到，程式碼被包進回呼函式來保護全域命名空間。除此之外也可以利用函式也是物件的特性，將資料用靜態屬性的方式儲存在沙盒建構式中。 新增模組沙盒建構式也是物件，可以新增一個名為 modules 的靜態屬性，這屬性又是另一個物件： Sandbox.modules = &#123;&#125;;Sandbox.modules.dom = function(box) &#123; box.getElement = function() &#123;&#125;; box.getStyle = function() &#123;&#125;; box.foo = 'bar';&#125;;Sandbox.modules.event = function(box) &#123; // box.constructor.prototype.m = \"mm\" // 如有必要則存取沙盒的原型 box.attachEvent = function() &#123;&#125;; box.dettachEvent = function() &#123;&#125;;&#125;; 這個範例中加入了 dom 模組與 event 模組，每個函式都接受 box 實體為參數，可能會新增屬性或方法到這個 box 裡面。 實作建構式沙盒建構式實作範例： function Sandbox() &#123; //將參數轉為陣列 var args = Array.prototype.slice.call(argument), callback = args.pop(), modules = (atgs[0] &amp;&amp; typeof atgs[0] === \"string\") ? args : args[0], i; // 確保函式是建構式呼叫 if (!(this instanceof Sandbox)) &#123; return new Sandbox(modules, callback); &#125; // 依照需要為 this 增加屬性 this.a = 1; this.b = 2; // 現在將模組新增至核心的 this 物件 // 沒有指定模組或是用 * 來表示所有模組 if (!module || modules === '*') &#123; modules = []; for (i in Sandbox.modules) &#123; if (Sandbox.modules.hasownProperty(i)) &#123; modules.push(i); &#125; //初始所需要的模組 for (i = 0; i &lt; modules.length; i += 1) &#123; Sandbox.modules[modules[i]](this); &#125; //執行回呼 callback(this); &#125; &#125;Sandbox.prototype = &#123; name: \"My App\", version: 1.0, getName: function () &#123; return this.name; &#125;&#125; 檢查 this 是否為 Sandbox 的實體，如果不是，表示呼叫 Sandbox 沒有加 new ，那麼就以建構式的方式再呼叫函式。 可以在建構式中，新增屬性到 this ，也可以新增屬性到此函式的原型。 Sandbox 中所使用的模組名稱可以用陣列、個別參數、* 字號，或不填入參數。 你可以只載入最基礎的模組，所需的模組都可以用命名慣例找到外部檔案並載入。 如果已經知道所需模組便可初始化，意思是呼叫所有模組的實作函式。 建構式最後一個參數是回呼，會在新被建立好的實體中呼叫，這個回呼就是 Sandbox ，他會取得一個裝好全部所需功能的 box 物件。 靜態成員 靜態的屬性和方法不會在實體之間有所改變。 以 class 為基礎的語言，靜態成員使用特別的語法建立並使用，也可以有 private 成員。 Public 靜態成員JavaScript 沒有特別的語法來表達靜態成員，但你可以使用建構式，並新增屬性到建構式中， 這樣如同擁有 class 語言的語法，因為建構式跟函式一樣都是物件，也可以擁有屬性，新增屬性可參考上一章記憶模式。 這個例子定義了一個建構式，有一個靜態方法和一個實體方法，靜態方法不需要 Gadget 物件就可以運作，但實體方法則需要。 //建構式var Gadget = function() &#123;&#125;;//靜態方法Gadget.isShiny = function() &#123; return 'u bet';&#125;;//加在原型中的一般方法Gadget.prototype.setPrice = function(price) &#123; this.price = price;&#125;; 一般的方法要透過實體呼叫，而靜態方法可以直接透過建構式呼叫。 // 呼叫靜態方法Gadget.isShiny(); // \"u bet\"// 建立一個實體然後呼叫方法var iphone = new Gadget();iphone.setPrice(500); 無法試圖用靜態方法呼叫實體，也同樣不能用實體呼叫靜態方法。 typeof Gadget.setPrice; // \"undefined\"typeof iphone.isShiny; // \"undefined\" 有時候讓實體也使用靜態方法會很方便，只要在原型新增就可以了，並以此方法作為外觀，指向原本的靜態方法。 Gadget.pototype.isShiny = Gadget.isShiny;iphone.isShiny(); // \"u bet\" 小心！呼叫 Gadget.isShiny() 會將 this 指向建構式；呼叫 iphone.isShiny(); 而 this 將指向 iphone。 //建構式var Gadget = function(price) &#123; this.price = price;&#125;;//一個靜態方法Gadget.isShiny = function() &#123; //這裡永遠都會運作 var msg = 'u bet'; if (this instanceof Gadget) &#123; msg += ', it costs $' + this.price + '!'; &#125; return msg;&#125;;//將一個一般的方法加到原型Gadget.prototype.isShiny = function() &#123; return Gadget.isShiny.call(this);&#125;;//測試呼叫靜態方法Gadget.isShiny(); // \"u bet\"//測試一個實體，並非用靜態的方式呼叫var a = new Gadget('499.99');a.isShiny(); // \"u bet , it costs $499.99!\" Private 靜態成員 由同個建構式建立的物件之間都可分享的成員 建構式之外不可存取的成員 var Gadget = (function() &#123; var counter = 0; return function() &#123; console.log((counter += 1)); &#125;;&#125;)(); // 立即執行 這個範例有一個靜態屬性名稱 counter ，參考前面討論過的 private 屬性，現在也是需要建立一個閉包來裝 private 成員，讓函式執行並回傳一個函式。將回傳的函式指派給變數 Gadget。 var g1 = new Gadget(); //logs 1var g2 = new Gadget(); //logs 2var g3 = new Gadget(); //logs 3 因為每個物件都讓 counter 值增加，這種靜態屬性就成為一個 ID ，這種唯一識別符非常有用。 接下來承上範例，來試看看特權方法 //建構式var Gadget = (function() &#123; //靜態變數/屬性 var counter = 0; NewGadget; //新的實作 NewGadget = function() &#123; counter += 1; &#125;; //特權方法 NewGadget.prototype.getLastId = function() &#123; return counter; &#125;; //覆蓋原本的建構式 return NewGadget;&#125;)(); // 立即執行 var iphone = new Gadget();iphone.getLastId(); // 1var ipod = new Gadget();ipod.getLastId(); // 2var ipad = new Gadget();ipad.getLastId(); //3 無論 public 還是 private ，他們可以包含非特定於實體的方法和資料，且不會隨著新的實體又重新建立，這種靜態屬性實作有點類似之後會講的單體建構式。 物件常數JavaScript 沒有常數，一種常見的變通方法就是使用命名慣例將變數全部大寫。 Math.PI;Math.SQRT2;Number.MAX_VALUE; 你也可以為你的常數使用相同命名慣例，並讓他們變成建構式靜態屬性。 var Widget = function() &#123; //實作&#125;;Widget.MAX_HEIGHT = 320;Widget.MAX_WIDTH = 480; 假設真的需要一個不可變動的值，可以建立 private 屬性，並提供一個 getter 方法且不要有 setter。 一個泛用的 constant 物件實作，提供這些方法： set(name, value);//用來定義一個新的常數isDefined(name);//檢查常數是否存在get(name);//取得常數值 下面這份實作允許原始型別為常數值，且採用額外的保護措施（hasOwnProperty），以確保是用內建屬性的名稱來宣告屬性，並每個常數名稱再額外隨機產生一個前綴詞。 var constant = function() &#123; var constants = &#123;&#125;, ownProp = Object.prototype.hasOwnProperty, allowed = &#123; string: 1, number: 1, boolean: 1, &#125;, prefix = (Math.random() + '_').slice(2); return &#123; set: function(name, value) &#123; if (this.isDefined(name)) &#123; return false; &#125; if (!ownProp.call(allowed, typeof value)) &#123; return false; &#125; constants[prefix + name] = value; return true; &#125;, isDefined: function(name) &#123; return ownProp.call(constants, prefix + name); &#125;, get: function(name) &#123; if (this.isDefined(name)) &#123; return constants[prefix + name]; &#125; return null; &#125;, &#125;;&#125;; 實作範例： //檢查是否定義過constant.isDefined('maxwidth'); //false//定義常數constant.set('maxwidth', 480); //true//再檢查一次constant.isDefined('maxwidth'); //true//嘗試重新定義constant.set('maxwidth', 320); //false//確認常數值constant.get('maxwidth'); //480 鏈接模式鏈接模式允許你讓物件一個接著一個呼叫多個方法，既不需要將前一次操作賦值給變數，也不需要將你的呼叫拆成多行。 當建立的方法不具有意義的回傳值時，你可以讓他們回傳 this ，也就是方法所運作的實體物件，這樣就能讓物件的使用者直接呼叫下一個方法： var obj = &#123; value: 1, increment: function() &#123; this.value += 1; return this; &#125;, add: function(v) &#123; this.value += v; return this; &#125;, shout: function() &#123; alert(this.value); &#125;,&#125;;//鏈接呼叫obj .increment() .add(3) .shout(); //5//逐一呼叫obj.increment();obj.add(3);obj.shout(); //5 鏈接模式的優點與缺點優點： 少打字 幫助思考，看能不能建立更小更專門的函式，可提升維護性 缺點： debug 困難（又稱為火車事故） method() 方法（sugar method）對於習慣 method() 思考，JS 可能會讓他們困惑，這就是為什麼有些程式員會把 JS 寫得 class-like，提出 method() 的作者（Douglas Crockford）承認這個方法並不是推薦的方式，但可能會在未來某些應用程式中碰到。 使用建構式就像在 Java 中使用 class ，也讓你可以在建構式本體中，新增實體的屬性到 this，但在 this 上新增方法非常沒效率，會造成每個實體都重新建立，這就是為什麼可重用的方法需要新增在 prototype 上。 定義一個 class 的方法類似這樣： var Person = function(name) &#123; this.name = name;&#125; .method('getName', function() &#123; return this.name; &#125;) .method('setName', function(name) &#123; this.name = name; return this; &#125;); 注意建構式是如何鏈接 method 的呼叫，這用到鏈接模式，幫助你單一敘述定義整個 class。 這個 method 接受兩個參數： 新方法的名稱 新方法的實作 這些鏈接的新方法就會新增到 Person 的 class 裡面，而方法的實作也就是一個函式，內部的 this 會指向 Person 所建立的物件。 用 Person() 建立新物件： var a = new Person('Adam');a.getName(); //'Adam'a.setName('Eve').getName(); // 'Eve' 注意範例的 setName，可以這樣是因為 setName 回傳 this。 最後這是 method 模式實作的方法： if (typeof Function.prototype.method !== 'function') &#123; //先檢查是否已經建立過了 Function.prototype.method = function(name, implementation) &#123; this.prototype[name] = implementation; //將 implementation 傳遞的函式加到建構式的原型中，this 會指向建構式 //原型就會被擴充 return this; &#125;;&#125;","link":"/javascript-design-pattern-object02/"},{"title":"【讀書筆記】JavaScript Design Pattern Chapter06 程式碼重用模式（上）","text":"「多用物件複合，少用類別繼承。」 說到程式碼重用，第一件事想到的就是繼承，但他不是唯一一種方法。 Classical 繼承模式 v.s. Modern 繼承模式在有 class 的語言中，每個物件都是某個特定的 class 的一個實體，沒有 class 就無法建立出物件，但在 JavaScript 中，物件僅是名與值，可以立即建立及改變。 JavaScript 有建構式，new 運算子類似 classes 的用法。 1234Person adam = new Person();//Javavar adam = new Person();//JavaScript 這兩段語法非常相像，但建構式仍舊是函式，導致許多開發者用 class 的方式來思考 JavaScript，進而發展出模擬 class 的繼承想法，這稱之為「classical」。而所謂的「modern」模式指的是讓你不需要思考 classes 的其他所有模式。 使用 Classical 繼承的預期結果Classical 的實作目標是讓一個 child(); 建構式所建立的物件可以取得另一個Parent();建構式的屬性。 123456789101112function Parent(name) &#123; this.name = name || 'Adam';&#125;//父建構式Parent.prototype.say = function() &#123; return this;&#125;;//新增功能function Child(name) &#123;&#125;//子建構式inherit(Child, Parent);//繼承 inherit() 函式做了繼承的工作，但它需要自己實作，非語言提供。 Classical 模式 #1 —— 預設的模式最常用的方式，是使用 Parent() 建構式建立一個物件，並指派給 Child() 的原型。 1234function inherit(C, P) &#123; C.prototype = new P(); //注意 new 運算子&#125; prototype 應指向一個物件而非函式，所以它必須指向父建構式所建立的實體，而非建構式本身。之後使用new Child(); 就會取得 Parent(); 的原型。 追蹤原型鍊用這個模式，你同時繼承了實體本身的屬性和方法。 用 new Pserson() 建立一個物件，他保有 name 的屬性資料。 物件嘗試存取 say() ，但建構式沒有這個方法。 往上查找 Pserson() 的 prototype。 12var kid = new Child();kid.say(); //\"Adam\" 建構式 Child() 和 prototype 都是空白的，proto 指向 inherit() 函式建立的 new Pserson() ，在呼叫 say() ，子建構式沒有這個方法，父建構式也沒有這個方法，就會再往上查找父建構式的 prototype。 say() 裡面有個參考 this.name，再依序從 kid、子建構式、子建構式 prototype、父建構式、父建構式 prototype 查找。 123var kid = new Child();kid.name = 'Amy';kid.say(); //\"Amy\" kid.name 不會修改父建構式的屬性，會在自身直接建立新的屬性，say() 再從剛剛的序列查找，查找this.name，在 kid 物件就找到了。 模式 #1 的缺點 同時繼承加在 this 本身的屬性和原形的屬性，大多時候你並不想要本身的屬性，這比較像是屬於特定的實例，不適合重用。 不能讓參數給予子建構式，再讓子建構式傳遞給父建構式。 123var s = new Child('Setch');s.say(); //\"Adam\"//希望出現 Setch，但出現 Adam 這個結果不如預期，必須每次需要子物件時執行一次繼承，最後是不斷再建立父建構式。 Classical 模式 #2 —— 借用建構式這個模式解決了上個範例的「無法傳遞參數」給父建構式的問題，他借用了父建構式，將子建構式用 this 綁定父建構式，並轉送所有參數： 123function Child(a, c, b, d) &#123; Parent.apply(this, argument);&#125; 用這個方法，只繼承了在父建構式中加至 this 的屬性，而沒有繼承加到原型的成員，子物件可以取得繼承成員的複製，而不像第一個模式（只是參考）。 範例比較： 1234567891011121314151617function Article() &#123; this.tag = ['js', 'css'];&#125;var article = new Article();function Blogpost() &#123;&#125;Blogpost.prototype = article;var blog = new BlogPost();function StaticPage() &#123; Article.call(this);&#125;var page = new StaticPage();article.hasOwnProperty('tags'); // trueblog.hasOwnProperty('tags'); // falsepage.hasOwnProperty('tags'); // true 第一種的預設模式使得 blog 物件可以透過原型獲得 tags 的存取權，自身不具有 tags，所以是 false。 第二種借用模式，page 自身屬性有 tags，是因為使用了借用建構式，新物件就會取得父建構式 tags 成員的複製，而不是參考。 原型鍊123456789101112131415function Parent(name) &#123; this.name = name || 'Adam';&#125;Parent.prototype.say = function() &#123; return this.name;&#125;;//父建構式新增新功能function Child(name) &#123; Parent.apply(this.argument);&#125;//子建構式繼承父建構式，但不會繼承父原型var kid = new Child('Amy');kid.name; //\"Amy\"typeof kid.say; //\"undefined\" Child.prototype 根本沒被使用到，他所指向的是一個空物件。 用借用建構式實現多重繼承12345678910111213141516171819function Cat() &#123; this.legs = 4; this.say = function() &#123; return 'meaowww'; &#125;;&#125;function Bird() &#123; this.wings = 2; this.fly = true;&#125;function CatWings() &#123; Cat.apply(this); Bird.apply(this);&#125;var jane = new CatWings();console.dir(jane); 借用建構式的優點和缺點 優點：可以拿到父物件自身屬性的複製，而不是參考，所以不會有意外覆寫到父物件屬性的問題。 缺點：prototype 的屬性都沒被繼承 Classical 模式 #3 —— 借用並設定原型將前兩個模式組合起來，先借用建構式，接著也將子建構式的原型指向父建構式的實體。 1234function Child(a, c, b, d) &#123; Parent.apply(this, argument);&#125;Child.prototype = new Parent(); 優點： 子建構式取得了父建構式自身成員的複製 取得父建構式原型成員的參考 子建構式可以傳遞任何參數給父建構式 缺點： 父建構式被呼叫了兩次，效率比較差。 範例：123456789101112131415161718192021function Parent(name) &#123; this.name = name || 'Adam';&#125;//父建構式Parent.prototype.say = function() &#123; return this.name;&#125;;//新增原型function Child(name) &#123; Parent.apply(this, arguments);&#125;Child.prototype = new Parent();var kid = new Child('Amy');kid.name; // \"Amy\"kid.say(); //\"Amy\"delete kid.name;kid.say(); //\"Adam\" say() 的原型被繼承了，所以當自身的 name 被刪除，就會使用到原型鍊預設的屬性。 Classical 模式 #4 —— 分享原型這個模式不像上一個繼承模式一樣，需要呼叫兩次父建構式，這個模式不會引發父建構式的呼叫。 根據經驗來說，重要的成員，且任何需要繼承的事物，都應該放在原型，而不是放在 this 裏，那就可以將子建構式原型設為和父建構式原型相同。 123function inherit(C, P) &#123; C.prototype = P.prototype;&#125; 但所有物件其實都分享相同原型，導致修改了原型，就會影響所有原型鏈。 Classical 模式 #5 —— 暫時的建構式這個模式可以打斷父原型和子原型之間的連結，同時又能受益於原型鏈的優點。 12345function inherit(C, P) &#123; var F = function() &#123;&#125;; F.prototype = P.prototype; C.prototype = new F();&#125; 這個模式和 #1 的預設模式稍有不同，因為這邊的子物件謹繼承原型的屬性，這樣利用了「原型就是為了放置可重用功能的地方」也處理好 this，「讓任何在父建構式加在 this 的成員都不會被繼承」。 建立一個新的子物件，並觀察他的行為： 1var kid = new Child(); 若你存取 kid.name 會是 undefined，因為 name 是父建構式自身的屬性，而在繼承的過程中，並沒有呼叫 new Parent() 代表根本沒有父建構式的屬性。 而當存取 kid.say() 的時候，物件在 new Child() 根本不存在，因此原型鏈會向上查找，new F() 也沒有這個方法，但 Parent.prototype 有這個方法，Parent.prototype 會讓所有繼承 Parent() 的不同建構式和這些子建構式所建立的物件所共享，他們使用的都是同一塊記憶體。 Superclass在前一個模式的基礎上，你可以新增一個參考指向原本的父親，這很類似在其他語言的 superclass。 我們將屬性命名為 uber，因為「super」是個保留字，而 superclass 可能會引導不知情開發者的聯想，而誤以為 Javascript 是有 class 的。 123456function inherit(C, P) &#123; var F = function() &#123;&#125;; F.prototype = P.prototype; C.prototype = new F(); C.uber = P.prototype;&#125; 重新設定建構式的參考現在我們的 classical 繼承函式近乎完美，最後我們要重新設定建構式的參考，如果不設定的話，所以有的子物件就會回報 Parent() 是他的建構式，這樣不行的。 假設用前一份 inherit() 的實作： 12345678function Parent() &#123;&#125;function Child() &#123;&#125;inherit(Child, Parent);var kid = new Child();kid.constructor.name; //\"Parent\"kid.constructor === Parent; //true constructor 屬性比較少用，但在執行時期用來檢查物件很方便，可以重新設定，讓他指向預期中的建構式。 1234567function inherit(C, P) &#123; var F = function() &#123;&#125;; F.prototype = P.prototype; C.prototype = new F(); C.uber = P.prototype; C.prototype.constructor = C;&#125; 這個模式又稱為聖杯繼承模式（holy grail）。 另一種聖杯模式的優化，是避免每次繼承都重複建立暫時（代理）建構式，因為我們建立一次就夠了，需要改變的是他的原型，可以利用一個立即函式，並將 proxy 函式儲存在他的閉包裏。 123456789var inherit = (function() &#123; var F = function() &#123;&#125;; return function(C, P) &#123; F.prototype = P.prototype; C.prototype = new F(); C.uber = P.prototype; C.prototype.constructor = C; &#125;;&#125;)(); Klass許多 JavaScript 函式庫都在模擬 class ，並提供新的語法糖，將下來的實作有點不一樣，但有一些共通點： 命名都有一組慣例，遵循這個慣例都會被當成 class 的建構式，例如：initialize、_init 等等。 Classes 可以繼承其他 classes 可以在子 class 中存取父 class（superclass）。 接下來用 JavaScript 來模擬 Class。 123456789var Man = klass(null, &#123; __construct: function(what) &#123; console.log(\"Man's constructor\"); this.name = what; &#125;, getName: function() &#123; return this.name; &#125;,&#125;); 上述範例，是以一個 klass 函式的形式出現，你在其他狀況可以會看到 Klass 的建構式，或是 Object.prototype 的方式出現，關於 klass 函式的實作，下方會在探討。 這個函式接受兩個參數： 父 class 作為繼承用 一個新的 class 實作，採用物件實字語法 規定 class 的建構式必須是一個名為 __constructor 的方法。一個 Man 的 class 實作，他不繼承任何 class，意思就是他繼承的是 object。 Man 本身有自己的屬性，建立在 constructor 中，另外還有個 getName 方法，Man class 本身就是建構式，接下來的動作讓它更像 class 實體化： 12var first = new Man('Adam'); //logs \"Man's constructor\"first.getName(); //\"Adam\" 接下來來擴充新的 class，建立 SuperMan class： 123456789var SuperMan = klass(Man, &#123; __construct: function(what) &#123; console.log(\"SuperMan's constructor\"); &#125;, getName: function() &#123; var name = SuperMan.uber.getName.call(this); return 'I am' + name; &#125;,&#125;); 這個範例中，給的第一個參數是 class Man，會被繼承，在 getName() 它利用 SuperMan 的 uber（super）靜態屬性呼叫父 class 的 getName()： 12var clark = new SuperMan('Clark Kent');clark.getName(); //\"I am Clark Kent\" 在 console.log 裡面，印出的第一行是「Man’s constructor」接著是「SuperMan’s constructor」，父建構式會在子建構式之前呼叫。 再來試看看 instanceof 運算子是否回傳預期中的結果： 12clark instanceof Man; //trueclark instanceof SuperMan; //true 接下來看看 klass 實作： 12345678910111213141516171819202122232425262728293031323334353637var klass = function(Parent, props) &#123; var Child, F, i; //1. //新的建構式，在最後會被回傳，且被當 class使用。 //在函式中呼叫 __consteuct 方法，在那之前會先利用靜態的 uber 屬性呼叫父 class 的 __consteuct ，如果繼承是 Object 的話， uber 有可能未被定義，例如 class 的 Man。 Child = function() &#123; if (Child.uber &amp;&amp; Child.uber.hasOwnProperty('__construct')) &#123; Child.uber.__construct.apply(this, arguments); &#125; if (Child.uber.hasOwnProperty('__construct')) &#123; Child.prototype.__construct.apply(this, arguments); &#125; &#125;; //2. //新的建構式，使用了前面的 classical 繼承的聖杯模式 //如果 沒有需要繼承的 Parent，那就繼承 Object 的 prototype。 Parent = Parent || Object; F = function() &#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.uber = Parent.prototype; Child.prototype.constructor = Child; //3. //加入實作的方法 //用迴圈查找所有方法，加到 Child 的原型之中 for (i in props) &#123; if (props.hasOwnProperty(i)) &#123; Child.prototype[i] = props[i]; &#125; &#125; // 回傳Class return Child;&#125;;","link":"/javascript-design-pattern-multiplexing01/"},{"title":"【讀書筆記】JavaScript Design Pattern Chapter06 程式碼重用模式（下）","text":"原型繼承模式可以開始討論「modern」的無 class 模式，物件要繼承自其他物件。 原型繼承原型繼承模式可以開始討論「modern」的無 class 模式，物件要繼承自其他物件。 假設你有個物件需要重用，需要從這個物件取得功能，已建立第二個物件，會這樣： 123456var parent = &#123; name: 'Papa',&#125;;var child = object(parent);alert(child.name); //\"Papa\" 新增的 child 物件希望讓他和 parent 物件有一樣的屬性和方法，這個新的物件由 object 的函式去建立，但 JavaScript 本身沒有這個函式，那我們必須實作這個函式： 12345function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125; 這邊讓 暫時建構式 F() 的原型指向父物件，最後在回傳這個實體，在這邊的 child 物件本身為空，但他可以使用 parent 的原型。 討論當使用建構式來實作原型繼承模式，注意自身的屬性和建構式原型的屬性都會被繼承： 1234567891011121314151617//父建構式function Person() &#123; //一個自己的屬性 this.name = 'Adam';&#125;//在原型中新增屬性Person.prototype.getName = function() &#123; return this.name;&#125;;//建立新的 Personsvar papa = new Person();//繼承var kid = object(papa);//測試自身的屬性和來自原型的屬性是不是都被繼承kid.getName(); //\"Adam\" 另一個變形範例，你可以選擇是否只繼承建構式的原型物件： 12345678910111213141516// 父建構式function Person() &#123; //一個自己的屬性 this.name = 'Adam';&#125;//在原型中新增了一個屬性Person.prototype.getName = function() &#123; return this.name;&#125;;//繼承var kid = obejct(Person.prototype);typeof kid.getName; //\"function\" 因為只繼承了 prototype 的函式typeof kid.name; //\"undefined\" 而沒有繼承建構式內的屬性 ECMA 5 特性現在有 Object.create 方法，我們不需要再做剛剛 Object() 的實作了： 1var child = Object.create(parent); Object.create 接受了一個額外的參數：一個物件，這個物件的屬性會被加到新物件的屬性內： 12345var child = Object.create(parent, &#123; age: &#123; value: 2 &#125;,&#125;);child.hasOwnProperty('age'); //true 用複製屬性實作繼承在這個模式之中，物件像其他物件取得功能的方式，只是簡單的使用複製，只是用迴圈來尋訪父物件的所有成員並複製他們，child 參數是選用的，沒有就會建立一個全新物件並回傳： 1234567891011121314function extend(parent, child) &#123; var i; child = child || &#123;&#125;; for (i in parent) &#123; if (parent.hasOwnProperty(i)) &#123; child[i] = parent[i]; &#125; &#125; return child;&#125;var dad = &#123; name: 'Adam' &#125;;var kid = extend(dad);kid.name; //\"Adam\" 這邊做的是淺拷貝，因為 JavaScript 的物件是使用參考來傳遞，一樣尋訪每個屬性並複製，只要該屬性是物件，那麼也同時改到父物件： 12345678var dad = &#123; counts: [1, 2, 3], reads: &#123; paper: true &#125;,&#125;;var kid = extend(dad);kid.counts.push(4);dad.counts.toString(); //\"1,2,3,4\"dad.reads === kid.reads; //true 想要避免這個問題就要使用深拷貝，深拷貝會檢查你要複製的屬性是否為物件或陣列，如果是的話會以遞迴的方式進入該物件。 你需要做的就是檢查屬性是否為物件，是的話就已遞迴方式複製每個屬性： 12345678910111213141516171819function extendDeep(parent, child) &#123; var i, toStr = Object.prototype.toString, astr = '[object Array]'; child = child || &#123;&#125;; for (i in parent) &#123; if (parent.hasOwnProperty(i)) &#123; if (typeof parent[i] === 'object') &#123; child[i] = toStr.call(parent[i]) === astr ? [] : &#123;&#125;; extendDeep(parent[i], child[i]); &#125; else &#123; child[i] = parent[i]; &#125; &#125; &#125; return child;&#125; 接下來看新的實作，是否真的深拷貝到物件： 1234567891011121314var dad = &#123; counts: [1, 2, 3], reads: &#123; paper: true &#125;,&#125;;var kid = extendDeep(dad);kid.counts.push(4);kid.counts.toString(); //\"1,2,3,4\"dad.counts.toString(); //\"1,2,3\"dad.reads === kids.reads; //falsekid.reads.paper = false;kid.reads.web = true;dad.reads.paper; //true 而這個模式完全沒有涉及到原型：只有物件跟物件自身的屬性。 混搭混搭模式，不僅從一個物件複製，可以從任意數量的物件來複製屬性，並將他們混合到一個新物件中，只用迴圈跑過參數列，將傳遞進來的每個物件的每個屬性都複製起來： 12345678910111213function mix() &#123; var arg, prop, child = &#123;&#125;; for (arg = 0; arg &lt; arguments.length; args += 1) &#123; for (prop in arguments[arg]) &#123; if (arguments[arg].hasOwnProperty(prop)) &#123; child[prop] = arguments[arg][prop]; &#125; &#125; &#125; return child;&#125; 現在有個通用的混搭模式，可以傳遞任何數量的物件給他，並得到一個新物件： 1var cake = mix(&#123; egg: 2, large: true &#125;, &#123; butter: 1, salted: true &#125;, &#123; flour: '3 cups' &#125;, &#123; sugar: 'sure!' &#125;); 借用方法有時候會發生一個狀況，你只需要物件中的一到兩個方法，，你希望重用他們，但不希望對該物件建立父子物件關係，這時候可以使用借用方法。 此模式是受益於 call 及 apply，兩者差別在他們接受的參數一個使用陣列表示，一個則接受一個個獨立參數。 這裡有個物件叫 myobj ，而且你知道另一個 notmyobj 物件裡有個 doStuff 方法，我們需要暫時借用他，你傳入你的物件，讓借來方法的 this 綁在 myobj 物件。 1234// callnotmyobj.doStuff.call(myobj, param1, p2, p3);// applynotmyobj.doStuff.apply(myobj, [param1, p2, p3]); 範例：向陣列借用方法陣列有些有很好用的方法，而像 arguments 則沒有這些方法，這時可以使用 slice 跟陣列借用： 123456function f() &#123; var args = [].slice.call(arguments, 1, 3); return args;&#125;f(1, 2, 3, 4, 5, 6); // returns [2,3] 有個空物件被建立出來，只是為了使用他的方法。另一種稍微長的方式是向 Array.prototype.slice.call(...)，這個方始要輸入比較常，但是可以省略建立空陣列的運算。 借用並綁定不管是透過 call、apply 或是簡單的賦值來借用方法，方法內的 this 所指向的物件都是依賴運算式來決定，最好讓 this 的值在事先就綁定在一個特定的值。 123456789var onder = &#123; name: 'object', say: function(greet) &#123; return greet + ', ' + this.name; &#125;,&#125;;//試用one.say('hi'); //\"hi, object\" 現在有個 two 沒有 say() 方法，讓他從 one 那邊借用，say() 的 this 指向 two ，因此 this.name 為「another object」： 12345var two = &#123; name: 'another object',&#125;;one.say.apply(two, ['hello']); //\"hello, another object\" 如果將函式指標賦予給全域變數，或者將函式作為 callback，那這樣的狀況該如何處理： 12345678910111213//將方法指定給變數//方法內的 this 會指向全域物件var say = one.say;say('hoho'); //\"hoho, undefined\"//將方法作為回呼傳遞var yetanother = &#123; name: 'Yet another object', method: function(callback) &#123; return callback('Hola'); &#125;,&#125;;yetanother.method(one.say); //\"Holla, undefined\" say() 內部的 this 都指向了全域，於是上面整段都不如預期，這時候可以用一個簡單的函式，來將一個物件固定，或是綁在方法： 12345function bind(o, m) &#123; return function() &#123; return m.apply(o, [].slice.call(arguments)); &#125;;&#125; 這個 bind 函式接受一個物件 o 和方法 m，將兩者綁定在一起後回傳一個新函式，新的函式透過閉包來存取 o 和 m，所以即使 bind 回傳之後，裡面那個函式也可以存取指向原本的物件跟方法（o 和 m）。 12var twosay = bind(two, one.say);twosay('yo'); //\"yo, another object\" 透過上面的實作可以知道，twosay 被建立成一個全域函式，this 也沒有指向全域物件，而是指向傳遞給 bind 的 two 物件，不管用什麼方式呼叫 twosay，this 都永遠綁定 two。 Function.prototype.bind()12var newFunc = obj.someFunc.bind(myobj, 1, 2, 3);// 將 someFunc 和 myobj 綁在一起，並同時域先填好三個參數給 someFunc。 bind 的實作： 12345678910if (typeof Function.prototype.bind === 'undefined') &#123; Function.prototype.bind = function(thisArg) &#123; var fn = this, slice = Array.prototype.slice, args = slice.call(arguments, 1); return function() &#123; return fn.apply(thisArg, args.concat(slice.call(arguments))); &#125;; &#125;;&#125; 這份實作使用了部分應用，並串接參數列，包含傳遞給 bind 的參數（不含第一個），還有之後傳給 bind 所建立的新函數的參數，除了要綁的物件之外，沒有傳其他參數： 12var twosay2 = one.say.bind(two);twosay2('Bonjour'); //\"Bonjour, another object\" 這個範例，我們傳遞一個參數來做部分應用： 12var twosay3 = one.say.bind(two, 'hihihi');twosay3(); //\"hihihi, another object\"","link":"/javascript-design-pattern-multiplexing02/"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"TravisCI","slug":"TravisCI","link":"/tags/TravisCI/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"攻城屍筆記","slug":"攻城屍筆記","link":"/tags/攻城屍筆記/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"Webpack","slug":"Webpack","link":"/tags/Webpack/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"JS30系列","slug":"JS30系列","link":"/tags/JS30系列/"},{"name":"圖解 HTTP","slug":"圖解-HTTP","link":"/tags/圖解-HTTP/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"讀書筆記","slug":"讀書筆記","link":"/tags/讀書筆記/"},{"name":"JSDP","slug":"JSDP","link":"/tags/JSDP/"}],"categories":[{"name":"Front-end","slug":"Front-end","link":"/categories/Front-end/"},{"name":"Others","slug":"Others","link":"/categories/Others/"}]}