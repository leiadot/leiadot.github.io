<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【CSS】如何使用阿里巴巴圖標庫</title>
      <link href="/how-to-use-iconfont/"/>
      <url>/how-to-use-iconfont/</url>
      
        <content type="html"><![CDATA[<p>阿里巴巴是中國境內最大的圖標庫，裡面有各式各樣的圖示可以使用，這邊簡單教授以 CSS 的方法使用。</p><a id="more"></a><h1 id="當某天-fontawesome-GG-時，我們還有-iconfont"><a href="#當某天-fontawesome-GG-時，我們還有-iconfont" class="headerlink" title="當某天 fontawesome GG 時，我們還有 iconfont"></a>當某天 fontawesome GG 時，我們還有 iconfont</h1><p>Type: CSS</p><p>進入 <a href="https://www.iconfont.cn/collections/index" target="_blank" rel="noopener">Iconfont</a> 登入，選擇喜歡的 icon 放進購物車，匯集完之後，可以選擇加入項目，匯集到資料夾中。</p><p><img src="/img/css/iconfont/step01.png" alt></p><p>進到進到項目中，可以看到下面的圖示。</p><p><img src="/img/css/iconfont/step02.png" alt></p><p>點擊下載至本地會有一個 zip 檔案。</p><p><img src="/img/css/iconfont/step03.png" alt></p><h2 id="嵌入字體檔，並以-Unicode-方式引入"><a href="#嵌入字體檔，並以-Unicode-方式引入" class="headerlink" title="嵌入字體檔，並以 Unicode 方式引入"></a>嵌入字體檔，並以 Unicode 方式引入</h2><h3 id="定義-font-face"><a href="#定義-font-face" class="headerlink" title="定義 font-face"></a>定義 font-face</h3><p><figure class="highlight css hljs"><table><tr><td class="code"><pre><span class="line">font-family: 'iconfont';</span><br><span class="line">src: url('iconfont.eot');</span><br><span class="line">src: url('iconfont.eot?#iefix') format('embedded-opentype'),</span><br><span class="line">  url('iconfont.woff2') format('woff2'),</span><br><span class="line">  url('iconfont.woff') format('woff'),</span><br><span class="line">  url('iconfont.ttf') format('truetype'),</span><br><span class="line">  url('iconfont.svg#iconfont') format('svg');</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用定義的-iconfont"><a href="#使用定義的-iconfont" class="headerlink" title="使用定義的 iconfont"></a>使用定義的 iconfont</h3><p><figure class="highlight css hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-selector-class">.iconfont</span> &#123;</span><br><span class="line">  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">'iconfont'</span> <span class="hljs-meta">!important</span>;</span><br><span class="line">  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;</span><br><span class="line">  <span class="hljs-attribute">font-style</span>: normal;</span><br><span class="line">  <span class="hljs-attribute">-webkit-font-smoothing</span>: antialiased;</span><br><span class="line">  <span class="hljs-attribute">-moz-osx-font-smoothing</span>: grayscale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用-Unicode"><a href="#使用-Unicode" class="headerlink" title="使用 Unicode"></a>使用 Unicode</h3><p><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"iconfont"</span>&gt;</span>&amp;#x33;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="嵌入-CSS，並以-class-方式引入"><a href="#嵌入-CSS，並以-class-方式引入" class="headerlink" title="嵌入 CSS，並以 class 方式引入"></a>嵌入 CSS，並以 class 方式引入</h2><h3 id="引入-CSS"><a href="#引入-CSS" class="headerlink" title="引入 CSS"></a>引入 CSS</h3><p><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"./iconfont.css"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"iconfont icon-xxx"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="引入-JS-，使用-Symbol-（SVG-的集合）"><a href="#引入-JS-，使用-Symbol-（SVG-的集合）" class="headerlink" title="引入 JS ，使用 Symbol （SVG 的集合）"></a>引入 JS ，使用 Symbol （SVG 的集合）</h2><h3 id="引入-JS"><a href="#引入-JS" class="headerlink" title="引入 JS"></a>引入 JS</h3><p><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./iconfont.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="使用通用的-CSS"><a href="#使用通用的-CSS" class="headerlink" title="使用通用的 CSS"></a>使用通用的 CSS</h3><p><figure class="highlight css hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-selector-class">.icon</span> &#123;</span><br><span class="line">  <span class="hljs-attribute">width</span>: <span class="hljs-number">1em</span>;</span><br><span class="line">  <span class="hljs-attribute">height</span>: <span class="hljs-number">1em</span>;</span><br><span class="line">  <span class="hljs-attribute">vertical-align</span>: -<span class="hljs-number">0.15em</span>;</span><br><span class="line">  <span class="hljs-attribute">fill</span>: currentColor;</span><br><span class="line">  <span class="hljs-attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用-SVG"><a href="#使用-SVG" class="headerlink" title="使用 SVG"></a>使用 SVG</h3><p><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"icon"</span> <span class="hljs-attr">aria-hidden</span>=<span class="hljs-string">"true"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">"#icon-xxx"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">use</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="如何引進-Vue"><a href="#如何引進-Vue" class="headerlink" title="如何引進 Vue"></a>如何引進 Vue</h2><p>第一種的形式是 unicode，複雜的編碼對於前端來說，我個人覺得沒有比較方便，</p><p>第三種是用 js 的方法引入 svg，因為解壓縮的資料夾中其實有 svg 檔，這個方法我覺得也不好，所以這邊教授用 class 的方式引入。</p><p>在 <code>public/index.html</code> 引入，vue-cli 3 中的 webpack 會解析 <code>&lt;%= BASE_URL %&gt;</code></p><p>把 <code>iconfont.css</code> 的檔案也放在 <code>public</code> 資料夾底下。</p><p><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"&lt;%= BASE_URL %&gt;iconfont.css"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS】Functional Programming</title>
      <link href="/javascript-functional-programming/"/>
      <url>/javascript-functional-programming/</url>
      
        <content type="html"><![CDATA[<p>Functional Programming 是一種程式設計範例，但把函式本身上升到一等公民的位置，<br>就像是物件導向編程（Object-oriented Programming）一樣，是一種寫程式的方法。</p><a id="more"></a><h2 id="什麼是-Functional-Programming"><a href="#什麼是-Functional-Programming" class="headerlink" title="什麼是 Functional Programming"></a>什麼是 Functional Programming</h2><p>Functional Programming 是一種程式設計範例，但把函式本身上升到一等公民的位置，<br>就像是物件導向編程（Object-oriented Programming）一樣，是一種寫程式的方法。</p><h2 id="Expression-no-Statement"><a href="#Expression-no-Statement" class="headerlink" title="Expression, no Statement"></a>Expression, no Statement</h2><ul><li>概念：僅有表達式，沒有陳述式。</li><li>表達式：一個運算過程，一定有回傳值。</li><li>陳述式：表現某個行為，例如：賦值給變數。</li></ul><h2 id="First-Class-Function-一級函式："><a href="#First-Class-Function-一級函式：" class="headerlink" title="First Class Function 一級函式："></a>First Class Function 一級函式：</h2><h3 id="函式可以被賦值給變數。"><a href="#函式可以被賦值給變數。" class="headerlink" title="函式可以被賦值給變數。"></a>函式可以被賦值給變數。</h3><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> greet = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Hello <span class="hljs-subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line">greet(<span class="hljs-string">'Semlinker'</span>); <span class="hljs-comment">// Output: 'Hello Semlinker'</span></span><br></pre></td></tr></table></figure></p><h3 id="函式可以當參數被傳遞。"><a href="#函式可以當參數被傳遞。" class="headerlink" title="函式可以當參數被傳遞。"></a>函式可以當參數被傳遞。</h3><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> logger = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Hello <span class="hljs-subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">const</span> greet = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg, print</span>) </span>&#123;</span><br><span class="line">  print(msg);</span><br><span class="line">&#125;;</span><br><span class="line">greet(<span class="hljs-string">'Semlinker'</span>, logger);</span><br></pre></td></tr></table></figure></p><h3 id="函式可以當作回傳值。"><a href="#函式可以當作回傳值。" class="headerlink" title="函式可以當作回傳值。"></a>函式可以當作回傳值。</h3><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> a = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">b</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> a + b;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">const</span> add5 = a(<span class="hljs-number">5</span>);</span><br><span class="line">add5(<span class="hljs-number">10</span>); <span class="hljs-comment">// Output: 15</span></span><br></pre></td></tr></table></figure></p><h2 id="Pure-Function-純函數"><a href="#Pure-Function-純函數" class="headerlink" title="Pure Function 純函數"></a>Pure Function 純函數</h2><ul><li>概念：給這個函式相同的輸入值，無論這個函數在哪個時間、哪個地點，得到都會是同一個結果，並且沒有副作用。</li></ul><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// impure</span></span><br><span class="line"><span class="hljs-keyword">var</span> minimum = <span class="hljs-number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> checkAge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">age</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> age &gt;= minimum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// pure</span></span><br><span class="line"><span class="hljs-keyword">var</span> checkAge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">age</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> minimum = <span class="hljs-number">21</span>;</span><br><span class="line">  <span class="hljs-keyword">return</span> age &gt;= minimum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="Side-Effect-副作用"><a href="#Side-Effect-副作用" class="headerlink" title="Side Effect 副作用"></a>Side Effect 副作用</h3><ul><li>概念：與函式外部環境相互作用的都是副作用。</li><li>副作用可能包含以下（但不僅僅只有以下）：<ul><li>更改檔案系統</li><li>在資料庫寫入紀錄</li><li>發送一個 http 請求</li><li>可變資料</li><li>印出至畫面 / log</li><li>取得使用者輸入</li><li>DOM 查詢</li><li>存取系統狀態</li></ul></li></ul><h3 id="immutable-不可變性"><a href="#immutable-不可變性" class="headerlink" title="immutable 不可變性"></a>immutable 不可變性</h3><p>概念：建立某個變數之後就不能再更改其值。</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> statement = <span class="hljs-string">'I am an immutable value'</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> otherStr = statement.slice(<span class="hljs-number">8</span>, <span class="hljs-number">17</span>);</span><br></pre></td></tr></table></figure></p><p>我們可以說 statement 是 immutable，因為他的變形是由 otherStr 儲存。</p><h2 id="Partial-Application-部分應用"><a href="#Partial-Application-部分應用" class="headerlink" title="Partial Application 部分應用"></a>Partial Application 部分應用</h2><p>概念：提供部分參數給其函式應用</p><h3 id="一般函式："><a href="#一般函式：" class="headerlink" title="一般函式："></a>一般函式：</h3><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span>(<span class="hljs-params">list, unaryFn</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> [].map.call(list, unaryFn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span>(<span class="hljs-params">n</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> n * n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>], square); <span class="hljs-comment">// =&gt; [4, 9, 25]</span></span><br></pre></td></tr></table></figure></p><ul><li>map：接受一組陣列跟函式</li><li>square：接受一個數值</li></ul><h3 id="實作部分應用"><a href="#實作部分應用" class="headerlink" title="實作部分應用"></a>實作部分應用</h3><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapWith</span>(<span class="hljs-params">list, unaryFn</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> map(list, unaryFn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接著把二元函式變成疊層的一元函式：</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapWith</span>(<span class="hljs-params">unaryFn</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">list</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> map(list, unaryFn);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以當我們把參數傳進去：</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mapWith(square)([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]); <span class="hljs-comment">// =&gt; [4, 9, 25]</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> squareAll = mapWith(square);</span><br><span class="line">squareAll([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]); <span class="hljs-comment">// =&gt; [4, 9, 25]</span></span><br><span class="line">squareAll([<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>]); <span class="hljs-comment">// =&gt; [1, 16, 49, 36]</span></span><br></pre></td></tr></table></figure></p><p>如此可以減少傳遞 square 函式，隨時抽取變換陣列。</p><h2 id="Curry-柯里化"><a href="#Curry-柯里化" class="headerlink" title="Curry 柯里化"></a>Curry 柯里化</h2><p>概念：只傳遞一個參數給函式並呼叫，回傳另一個函式來處理剩下的參數。</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">y</span> =&gt;</span> x + y;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> add2 = add(<span class="hljs-number">2</span>);</span><br><span class="line"><span class="hljs-keyword">var</span> add200 = add(<span class="hljs-number">200</span>);</span><br><span class="line"></span><br><span class="line">add2(<span class="hljs-number">2</span>); <span class="hljs-comment">// =&gt;4</span></span><br><span class="line">add200(<span class="hljs-number">50</span>); <span class="hljs-comment">// =&gt;250</span></span><br></pre></td></tr></table></figure></p><h2 id="Compose-組合函式"><a href="#Compose-組合函式" class="headerlink" title="Compose 組合函式"></a>Compose 組合函式</h2><p>概念：將兩個簡短的函式，當作堆樂高一樣組成一個比較複雜的函式。</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> add10 = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value + <span class="hljs-number">10</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> mult5 = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value * <span class="hljs-number">5</span>;</span><br><span class="line"><span class="hljs-comment">//兩個簡短的函式</span></span><br><span class="line"><span class="hljs-keyword">var</span> mult5AfterAdd10 = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-number">5</span> * (value + <span class="hljs-number">10</span>);</span><br><span class="line"><span class="hljs-comment">//重寫一個新的</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> mult5AfterAdd10 = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> mult5(add10(value));</span><br><span class="line"><span class="hljs-comment">//但我們不想寫新的，所以把它組合起來。</span></span><br></pre></td></tr></table></figure></p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> compose = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">f, g</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> f(g(x));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//或者</span></span><br><span class="line"><span class="hljs-keyword">var</span> compose = <span class="hljs-function">(<span class="hljs-params">f, g</span>) =&gt;</span> <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> f(g(x));</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> add1 = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> mul5 = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * <span class="hljs-number">5</span>;</span><br><span class="line"></span><br><span class="line">compose(</span><br><span class="line">  mul5,</span><br><span class="line">  add1,</span><br><span class="line">)(<span class="hljs-number">2</span>);</span><br><span class="line"><span class="hljs-comment">// =&gt;15</span></span><br></pre></td></tr></table></figure></p><h2 id="Point-Free"><a href="#Point-Free" class="headerlink" title="Point Free"></a>Point Free</h2><p>概念：減少不必要的命名變數。</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//這不 Piont free</span></span><br><span class="line"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-params">str</span> =&gt;</span> str.toUpperCase().split(<span class="hljs-string">' '</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> toUpperCase = <span class="hljs-function"><span class="hljs-params">word</span> =&gt;</span> word.toUpperCase();</span><br><span class="line"><span class="hljs-keyword">var</span> split = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">str</span> =&gt;</span> str.split(x);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> f = compose(</span><br><span class="line">  split(<span class="hljs-string">' '</span>),</span><br><span class="line">  toUpperCase,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">f(<span class="hljs-string">'abcd efgh'</span>);</span><br><span class="line"><span class="hljs-comment">// =&gt;["ABCD", "EFGH"]</span></span><br></pre></td></tr></table></figure></p><h2 id="High-order-function-高階函式"><a href="#High-order-function-高階函式" class="headerlink" title="High-order function 高階函式"></a>High-order function 高階函式</h2><h3 id="要點"><a href="#要點" class="headerlink" title="要點"></a>要點</h3><ul><li>高階函式一定是一級函式</li><li>以一個函式當參數傳遞</li><li>同時回傳一個函式當作是回傳值</li></ul><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeAdder</span>(<span class="hljs-params">constantValue</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">adder</span>(<span class="hljs-params">value</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> constantValue + value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> add10 = makeAdder(<span class="hljs-number">10</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(add10(<span class="hljs-number">20</span>)); <span class="hljs-comment">// prints 30</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(add10(<span class="hljs-number">30</span>)); <span class="hljs-comment">// prints 40</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(add10(<span class="hljs-number">40</span>)); <span class="hljs-comment">// prints 50</span></span><br></pre></td></tr></table></figure></p><blockquote><h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ithelp.ithome.com.tw/articles/10186465" target="_blank" rel="noopener">30 天精通 RxJS (02)： Functional Programming 基本觀念</a> &gt; <a href="https://segmentfault.com/a/1190000009190906" target="_blank" rel="noopener">想学函数式编程？ - 收藏集 - 掘金</a> &gt; <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/" target="_blank" rel="noopener">JS 函数式编程指南</a> &gt; <a href="https://segmentfault.com/a/1190000006046508" target="_blank" rel="noopener">JavaScript 函数式编程（一）</a> &gt; <a href="https://segmentfault.com/a/1190000007784565" target="_blank" rel="noopener">SegmentFault 技术周刊 Vol.16 - 浅入浅出 JavaScript 函数式编程</a> &gt; <a href="https://segmentfault.com/a/1190000000765247" target="_blank" rel="noopener">函数式编程中局部应用（Partial Application）和局部套用（Currying）的区别</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Hexo】hackMD 功能</title>
      <link href="/hackMD/"/>
      <url>/hackMD/</url>
      
        <content type="html"><![CDATA[<h2 id="測試-hackmd-語法"><a href="#測試-hackmd-語法" class="headerlink" title="測試 hackmd 語法"></a>測試 hackmd 語法</h2><p>此頁是用來測試到底支援了多少 hackmd 原本的寫法<br>不過，確實有許多功能不需要照本宣科的移植過來，畢竟身為 hackmd 的愛用者，只要夠用，而不是取代呀<br>所以，下面列出目前支援的語法與功能到什麼程度，標示 danger 區塊的則是<em>不支援</em>或<em>沒有這功能</em>的意思。</p><a id="more"></a><h3 id="測試開始"><a href="#測試開始" class="headerlink" title="測試開始"></a>測試開始</h3><h2 id="功能介紹"><a href="#功能介紹" class="headerlink" title="功能介紹"></a>功能介紹</h2><p><strong><a href="/features">English version</a></strong><br><strong><a href="/CwYwhgzAbApgHFAtHAnAIzY4awBNkwCsA7ImFCBCHAIxwBMhhIQAAA==">中文版</a></strong><br><strong><a href="/GwMxE4HYA4EMBMC0BTcwBMiAs94FZFpktZFIQ91pp1xwAjdPIA==">日本語版</a></strong></p><p><strong>請不要修改這份筆記</strong> 非常謝謝您 :smile:<br><strong>如果要說 嗨 或是 玩些東西，請至 <a href="/CwDgDAZgTFCcCmBaAhvAJgVkceA2AzIgEYDGIJiIGIU8GYRYJA7PkAAA">遊樂場</a></strong></p><h2 id="特賣會"><a href="#特賣會" class="headerlink" title="特賣會"></a>特賣會</h2><p><strong>歡迎來自 Front-End Developers Taiwan 的各位！</strong>:100:<br><strong>歡迎來自 g0v 的各位！</strong>:+1:<br><strong>歡迎來自 程式人雜誌 的各位！</strong>:smiley:</p><h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p><i class="fa fa-file-text"></i> ** hackmd ** 是個跨平台的 Markdown 即時協作筆記<br>所以您可以在<strong>電腦、平板甚至是手機</strong>與其他人做筆記！<br>同時也可以在 <strong><a href="/">首頁</a></strong> 透過 <strong>Facebook、Twitter、GitHub、Dropbox</strong> 登入</p><p>目前這個服務還在初步階段，所以可能會有點問題或是壞掉<br>如有任何狀況，請至 [GitHub](<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a> hackmd io/ hackmd ) 回報問題<br>如果需要即時支援，請使用 <a href="https://www.facebook.com/messages/866415986748945" target="_blank" rel="noopener">Facebook Message</a><br><strong>謝謝您！</strong></p><h2 id="工作區"><a href="#工作區" class="headerlink" title="工作區"></a>工作區</h2><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p><strong>電腦 &amp; 平板</strong></p><p><i class="fa fa-edit fa-fw"></i> 編輯：只看到編輯器<br><i class="fa fa-eye fa-fw"></i> 檢視：只看到結果<br><i class="fa fa-columns fa-fw"></i> 同時：同時看到兩邊</p><p><strong>手機</strong></p><p><i class="fa fa-toggle-on fa-fw"></i> 檢視：只看到結果<br><i class="fa fa-toggle-off fa-fw"></i> 編輯：只看到編輯器</p><h3 id="上傳圖片"><a href="#上傳圖片" class="headerlink" title="上傳圖片"></a>上傳圖片</h3><p>只要按下這個按鈕 <i class="fa fa-camera"></i><br>或是 <strong>拖放</strong> 圖片到編輯器，甚至 <strong>貼上</strong> 圖片也可以喔！<br>這會自動上傳圖片至 <strong><a href="http://imgur.com" target="_blank" rel="noopener">imgur</a></strong>，啥都不必煩惱了 :tada:<br><img src="https://i.imgur.com/9cgQVqD.png" alt></p><h3 id="分享筆記"><a href="#分享筆記" class="headerlink" title="分享筆記"></a>分享筆記</h3><p>如果您想分享 <strong>可編輯的</strong> 筆記，複製這份文件的網址就好<br>如果您想分享 <strong>只可讀的</strong> 筆記，按下這個按鈕 <i class="fa fa-share-alt"></i> 然後複製網址</p><h3 id="儲存"><a href="#儲存" class="headerlink" title="儲存"></a>儲存</h3><p>目前可以儲存至 <strong>Dropbox</strong> <i class="fa fa-dropbox"></i> 或是存放 <strong>.md</strong> <i class="fa fa-file-text"></i> 到您的本機</p><h3 id="匯入"><a href="#匯入" class="headerlink" title="匯入"></a>匯入</h3><p>就像上面的儲存功能，您可以從 <strong>Dropbox</strong> <i class="fa fa-dropbox"></i> 匯入 <strong>.md</strong> <i class="fa fa-file-text"></i><br>或是從 <strong>剪貼簿</strong> <i class="fa fa-clipboard"></i> 匯入，而且這可以轉換 <strong>html</strong> 喔 :smiley:</p><h3 id="權限"><a href="#權限" class="headerlink" title="權限"></a>權限</h3><p>檢視右上方有個小按鈕，您可以透過以下選項來更改權限：</p><p><i class="fa fa-leaf fa-fw"></i> 隨意：任何人都可以更改這份筆記<br><i class="fa fa-pencil fa-fw"></i> 可編輯：已登入使用者可以更改這份筆記<br><i class="fa fa-lock fa-fw"></i> 鎖定：只有擁有者可以更改這份筆記<br><i class="fa fa-hand-stop-o fa-fw"></i> 私有：只有擁有者可以更改與檢視這份筆記</p><p><strong>只有筆記的擁有者可以更改權限</strong></p><h3 id="嵌入"><a href="#嵌入" class="headerlink" title="嵌入"></a>嵌入</h3><p><figure class="highlight xml hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"100%"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"500"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https:// hackmd .io/features"</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">"0"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="簡報模式"><a href="#簡報模式" class="headerlink" title="簡報模式"></a><a href="./slide-example">簡報模式</a></h3><p>您可以使用一些語法將您的筆記分成投影片<br>然後用 <strong>簡報模式</strong> <i class="fa fa-tv"></i> 來展示，詳細請至上連結</p><h2 id="檢視"><a href="#檢視" class="headerlink" title="檢視"></a>檢視</h2><h3 id="目錄"><a href="#目錄" class="headerlink" title="目錄"></a>目錄</h3><p>在右下角有個目錄的小按鈕 <i class="fa fa-bars"></i><br>按下它會顯示目前的目錄，而且會標明你所在的區塊<br>支援到<strong>第三階段的標頭</strong></p><h3 id="永久連結"><a href="#永久連結" class="headerlink" title="永久連結"></a>永久連結</h3><p>每個標頭都會在右側自動加上永久連結<br>您可以在滑到上面並且按 <i class="fa fa-chain"></i> 去移到那個錨點</p><h2 id="編輯"><a href="#編輯" class="headerlink" title="編輯"></a>編輯</h2><h3 id="快速鍵"><a href="#快速鍵" class="headerlink" title="快速鍵"></a>快速鍵</h3><p>跟又快又方便的 Sublime text 很像</p><blockquote><p>更多訊息請至 <a href="https://codemirror.net/demo/sublime.html" target="_blank" rel="noopener">這裡</a></p></blockquote><h3 id="自動完成"><a href="#自動完成" class="headerlink" title="自動完成"></a>自動完成</h3><p>提供完整的 Markdown 自動完成與提示</p><ul><li>表情符號：輸入 <code>:</code> 顯示提示</li><li>程式碼區塊：<br>:::danger<br>(這一段顯示錯誤)<br>輸入 加上一個字元 顯示提示 <i hidden> </i><br>:::</li><li>標頭：輸入 <code>#</code> 顯示提示</li><li>參考：輸入 <code>[]</code> 顯示提示</li><li>外部：輸入 <code>{}</code> 顯示提示</li><li>圖片：輸入 <code>!</code> 顯示提示</li></ul><h3 id="標題"><a href="#標題" class="headerlink" title="標題"></a>標題</h3><p>會使用 <strong>第一個第一級標頭</strong> 作為筆記標題</p><h3 id="標籤"><a href="#標籤" class="headerlink" title="標籤"></a>標籤</h3><p>:::danger<br>(這個語法的功能不同)<br>如同以下方式來使用標籤，它們會顯示在您的 <strong>歷史紀錄</strong></p><p>####### tags: <code>功能</code> <code>酷</code> <code>更新</code></p><p>:::</p><h3 id="YAML-metadata"><a href="#YAML-metadata" class="headerlink" title="YAML metadata"></a><a href="./yaml-metadata">YAML metadata</a></h3><p>提供描述筆記的資訊，以進階設定瀏覽行為，詳細請至上連結</p><ul><li>robots: 設定網路機器人 meta</li><li>lang: 設定瀏覽器顯示語言</li><li>dir: 設定文字方向</li><li>breaks: 設定是否使用分行</li><li>mathjax: 設定是否使用 mathjax</li></ul><h3 id="表情符號"><a href="#表情符號" class="headerlink" title="表情符號"></a>表情符號</h3><p>您可以像是這樣使用表情符號 :smile: :smiley: :cry: :wink:</p><blockquote><p>完整的表情符號列表 <a href="http://www.emoji-cheat-sheet.com/" target="_blank" rel="noopener">在這裡</a></p></blockquote><h3 id="待辦清單"><a href="#待辦清單" class="headerlink" title="待辦清單"></a>待辦清單</h3><ul><li><input disabled type="checkbox"> 待辦 - [x] 買些沙拉<ul><li><input checked disabled type="checkbox"> 刷牙 - [ ] 喝水</li></ul></li></ul><h3 id="程式碼區塊"><a href="#程式碼區塊" class="headerlink" title="程式碼區塊"></a>程式碼區塊</h3><p>我們支援非常多程式語言，使用自動完成來看看有些什麼</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> s = <span class="hljs-string">'JavaScript syntax highlighting'</span>;</span><br><span class="line">alert(s);</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">$initHighlight</span>(<span class="hljs-params">block, cls</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (cls.search(<span class="hljs-regexp">/\bno\-highlight\b/</span>) != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> process(block, <span class="hljs-literal">true</span>, <span class="hljs-number">0x0f</span>) + <span class="hljs-string">' class=""'</span>;</span><br><span class="line">  &#125; <span class="hljs-keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="hljs-comment">/* handle exception */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span> / <span class="hljs-number">2</span>; i &lt; classes.length; i++) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (checkCondition(classes[i]) === <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">return</span> <span class="hljs-regexp">/\d+[\s/]/g</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>如果想要 <strong>行號</strong>，在表明程式語言之後輸入 <code>=</code><br>您也可以指定開始行號，如下所示，行號從 101 開始</p></blockquote><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> s = <span class="hljs-string">'JavaScript syntax highlighting'</span>;</span><br><span class="line">alert(s);</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">$initHighlight</span>(<span class="hljs-params">block, cls</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (cls.search(<span class="hljs-regexp">/\bno\-highlight\b/</span>) != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> process(block, <span class="hljs-literal">true</span>, <span class="hljs-number">0x0f</span>) + <span class="hljs-string">' class=""'</span>;</span><br><span class="line">  &#125; <span class="hljs-keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="hljs-comment">/* handle exception */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span> / <span class="hljs-number">2</span>; i &lt; classes.length; i++) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (checkCondition(classes[i]) === <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">return</span> <span class="hljs-regexp">/\d+[\s/]/g</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>:::danger<br>(這一段語法不吃，行號判定是<code>+</code>變 NaN)</p><blockquote><p>或是可以接續上一個程式碼區塊的行號，使用 <code>=+</code></p></blockquote><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> s = <span class="hljs-string">'JavaScript syntax highlighting'</span>;</span><br><span class="line">alert(s);</span><br></pre></td></tr></table></figure></p><p>:::</p><p>:::danger<br>(這一段語法不吃)</p><h3 id="引用區塊標籤"><a href="#引用區塊標籤" class="headerlink" title="引用區塊標籤"></a>引用區塊標籤</h3><blockquote><p>您可以使用以下語法，表明自己的 <strong>姓名、時間與顏色</strong> 並與其他的引用區塊做區別<br>[name=ChengHan Wu][time=sun, jun 28, 2015 9:59 pm] [color=#907bf7]</p><blockquote><p>也支援巢狀引用區塊喔！<br>[name=ChengHan Wu][time=sun, jun 28, 2015 10:00 pm] [color=red]<br>:::</p></blockquote></blockquote><h3 id="外部"><a href="#外部" class="headerlink" title="外部"></a>外部</h3><h4 id="Youtube"><a href="#Youtube" class="headerlink" title="Youtube"></a>Youtube</h4><div class="video-container"><iframe src="//www.youtube.com/embed/1G4isv_Fylg" frameborder="0" allowfullscreen></iframe></div><h4 id="Vimeo"><a href="#Vimeo" class="headerlink" title="Vimeo"></a>Vimeo</h4><div class="video-container"><iframe src="//player.vimeo.com/video/124148255" frameborder="0" allowfullscreen></iframe></div><h4 id="Gist"><a href="#Gist" class="headerlink" title="Gist"></a>Gist</h4><script src="//gist.github.com/schacon/4277.js"></script><p>:::danger<br>(這一段語法不吃)</p><p><figure class="highlight markdown hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-section">#### SlideShare</span></span><br><span class="line"></span><br><span class="line">&#123;%slideshare briansolis/26-disruptive-technology-trends-2016-2018-56796196 %&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-section">#### Speakerdeck</span></span><br><span class="line"></span><br><span class="line">&#123;%speakerdeck sugarenia/xxlCSS-how-to-scale-CSS-and-keep-your-sanity %&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-section">#### PDF</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-strong">**注意：請使用 https 的網址，否則可能會被您的瀏覽器阻擋載入**</span></span><br><span class="line">&#123;%pdf https://papers.nips.cc/paper/5346-sequence-to-sequence-learning-with-neural-networks.pdf %&#125;</span><br></pre></td></tr></table></figure></p><p>:::</p><h3 id="MathJax"><a href="#MathJax" class="headerlink" title="MathJax"></a>MathJax</h3><p>您可以使用 <strong>MathJax</strong> 語法 來產生 <em>LaTeX</em> 數學表達式，如同 <a href="http://math.stackexchange.com/" target="_blank" rel="noopener">math.stackexchange.com</a>：</p><p>The <em>Gamma function</em> satisfying $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$ is via the Euler integral</p><p>$$<br>x = {-b \pm \sqrt{b^2-4ac} \over 2a}.<br>$$</p><p>$$<br>\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt,.<br>$$</p><blockquote><p>更多關於 <strong>LaTeX</strong> 數學表達式 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">請至這裡</a></p></blockquote><h3 id="UML-圖表"><a href="#UML-圖表" class="headerlink" title="UML 圖表"></a>UML 圖表</h3><h4 id="循序圖"><a href="#循序圖" class="headerlink" title="循序圖"></a>循序圖</h4><p>您可以像是以下使用循序圖：</p><div id="sequence-0"></div><h4 id="流程圖"><a href="#流程圖" class="headerlink" title="流程圖"></a>流程圖</h4><p>您可以像是以下使用流程圖：</p><div id="flowchart-0" class="flow-chart"></div><p>:::danger<br>(這一段語法不吃)</p><h4 id="Graphviz"><a href="#Graphviz" class="headerlink" title="Graphviz"></a>Graphviz</h4><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">digraph hierarchy &#123;</span><br><span class="line"></span><br><span class="line">  nodesep=1.0 // increases the separation between nodes</span><br><span class="line"></span><br><span class="line">  node [color=Red,fontname=Courier,shape=box] //All nodes will this shape and colour</span><br><span class="line">  edge [color=Blue, style=dashed] //All the lines look like this</span><br><span class="line"></span><br><span class="line">  Headteacher-&gt;&#123;Deputy1 Deputy2 BusinessManager&#125;</span><br><span class="line">  Deputy1-&gt;&#123;Teacher1 Teacher2&#125;</span><br><span class="line">  BusinessManager-&gt;ITManager</span><br><span class="line">  &#123;rank=same;ITManager Teacher1 Teacher2&#125;  // Put them on the same level</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Mermaid"><a href="#Mermaid" class="headerlink" title="Mermaid"></a>Mermaid</h4><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">gantt</span><br><span class="line">    title A Gantt Diagram</span><br><span class="line"></span><br><span class="line">    section Section</span><br><span class="line">    A task           :a1, 2014-01-01, 30d</span><br><span class="line">    Another task     :after a1  , 20d</span><br><span class="line">    section Another</span><br><span class="line">    Task in sec      :2014-01-12  , 12d</span><br><span class="line">    anther task      : 24d</span><br></pre></td></tr></table></figure></p><blockquote><p>更多關於 <strong>循序圖</strong> 語法 <a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="noopener">在這裡</a>.<br>更多關於 <strong>流程圖</strong> 語法 <a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="noopener">在這裡</a>.<br>更多關於 <strong>Graphviz</strong> 語法 <a href="http://www.tonyballantyne.com/graphs.html" target="_blank" rel="noopener">在這裡</a><br>更多關於 <strong>Mermaid</strong> 語法 <a href="http://knsv.github.io/mermaid" target="_blank" rel="noopener">在這裡</a><br>:::</p></blockquote><h3 id="警告區塊"><a href="#警告區塊" class="headerlink" title="警告區塊"></a>警告區塊</h3><p>:::success<br>耶 :tada:<br>:::</p><p>:::info<br>這是訊息 :mega:<br>:::</p><p>:::warning<br>注意 :zap:<br>:::</p><p>:::danger<br>喔不 :fire:<br>:::</p><h3 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h3><h4 id="標頭"><a href="#標頭" class="headerlink" title="標頭"></a>標頭</h4><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">## h1 標頭</span><br><span class="line">### h2 標頭</span><br><span class="line">#### h3 標頭</span><br><span class="line">##### h4 標頭</span><br><span class="line">###### h5 標頭</span><br><span class="line">####### h6 標頭</span><br></pre></td></tr></table></figure></p><h4 id="水平分隔線"><a href="#水平分隔線" class="headerlink" title="水平分隔線"></a>水平分隔線</h4><hr><hr><hr><h4 id="字形替換"><a href="#字形替換" class="headerlink" title="字形替換"></a>字形替換</h4><p>(c) (C) (r) (R) (tm) (TM) (p) (P) +-</p><p>測試.. 測試… 測試….. 測試?….. 測試!….</p><p>!!!!!! ???? ,,</p><p>Remarkable – awesome</p><p>“Smartypants, 雙引號”</p><p>‘Smartypants, 單引號’</p><h4 id="強調"><a href="#強調" class="headerlink" title="強調"></a>強調</h4><p><strong>這是粗體文字</strong></p><p><strong>這是粗體文字</strong></p><p><em>這是斜體文字</em></p><p><em>這是斜體文字</em></p><p><del>這是刪除文字</del></p><p>上標： 19^th^</p><p>下標： H<del>2</del>O</p><p>++這是底線文字++</p><p>==這是標記文字==</p><h4 id="引用區塊"><a href="#引用區塊" class="headerlink" title="引用區塊"></a>引用區塊</h4><blockquote><p>引用區塊也可以是巢狀的喔…</p><blockquote><p>…可以多層次的使用…</p><blockquote><p>…或是用空白隔開</p></blockquote></blockquote></blockquote><h4 id="清單"><a href="#清單" class="headerlink" title="清單"></a>清單</h4><h5 id="項目"><a href="#項目" class="headerlink" title="項目"></a>項目</h5><ul><li>在行開頭使用 <code>+</code> <code>-</code> 或是 <code>*</code> 來建立清單</li><li>空兩個空白就可以產生子清單<ul><li>當清單標記使用的字元不同，會強制建立新的清單<ul><li>Ac tristique libero volutpat at</li></ul><ul><li>Facilisis in pretium nisl aliquet</li></ul><ul><li>Nulla volutpat aliquam velit</li></ul></li></ul></li><li>非常簡單！</li></ul><h5 id="編號"><a href="#編號" class="headerlink" title="編號"></a>編號</h5><ol><li>Lorem ipsum dolor sit amet</li><li>Consectetur adipiscing elit</li><li>Integer molestie lorem at massa</li></ol><p>1) 您可以逐次增加項目數字…</p><p>1) …或是全部都使用 <code>1.</code></p><p>1) feafw</p><p>1) 332</p><p>1) 242</p><p>1) 2552</p><p>1) e2</p><p>從其他範圍開始編號清單</p><ol start="57"><li>foo</li><li>bar</li></ol><h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h4><p>行內 <code>程式碼</code></p><p>縮排程式碼</p><pre><code>// Some commentsline 1 of codeline 2 of codeline 3 of code</code></pre><p>程式碼區塊</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Sample text here...</span><br></pre></td></tr></table></figure></p><p>語法標色</p><p><figure class="highlight javascript hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">bar</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> bar++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(foo(<span class="hljs-number">5</span>));</span><br></pre></td></tr></table></figure></p><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><table><thead><tr><th>選項</th><th>描述</th></tr></thead><tbody><tr><td>data</td><td>path to data files to supply the data that will be passed into templates.</td></tr><tr><td>engine</td><td>engine to be used for processing templates. Handlebars is the default.</td></tr><tr><td>ext</td><td>extension to be used for dest files.</td></tr></tbody></table><p>向右對齊</p><table><thead><tr><th align="right">選項</th><th align="right">描述</th></tr></thead><tbody><tr><td align="right">data</td><td align="right">path to data files to supply the data that will be passed into templates.</td></tr><tr><td align="right">engine</td><td align="right">engine to be used for processing templates. Handlebars is the default.</td></tr><tr><td align="right">ext</td><td align="right">extension to be used for dest files.</td></tr></tbody></table><p>向左對齊</p><table><thead><tr><th align="left">選項</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">data</td><td align="left">path to data files to supply the data that will be passed into templates.</td></tr><tr><td align="left">engine</td><td align="left">engine to be used for processing templates. Handlebars is the default.</td></tr><tr><td align="left">ext</td><td align="left">extension to be used for dest files.</td></tr></tbody></table><p>置中對齊</p><table><thead><tr><th align="center">選項</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">data</td><td align="center">path to data files to supply the data that will be passed into templates.</td></tr><tr><td align="center">engine</td><td align="center">engine to be used for processing templates. Handlebars is the default.</td></tr><tr><td align="center">ext</td><td align="center">extension to be used for dest files.</td></tr></tbody></table><h4 id="連結"><a href="#連結" class="headerlink" title="連結"></a>連結</h4><p><a href="http://dev.nodeca.com" target="_blank" rel="noopener">連結文字</a><br><a href="http://nodeca.github.io/pica/demo/" title="標題文字！" target="_blank" rel="noopener">加上標題的連結文字</a><br>自動轉換連結 <a href="https://github.com/nodeca/pica" target="_blank" rel="noopener">https://github.com/nodeca/pica</a></p><h4 id="圖片"><a href="#圖片" class="headerlink" title="圖片"></a>圖片</h4><p><img src="https://octodex.github.com/images/minion.png" alt="Minion"><br><img src="https://octodex.github.com/images/stormtroopocat.jpg" alt="Stormtroopocat" title="The Stormtroopocat"><br>如同連結一般，圖片也可以用註腳語法<br><img src="https://octodex.github.com/images/dojocat.jpg" alt="Alt text" title="The Dojocat"><br>使用參考，可以在稍後的文件中再定義圖片網址</p><p>![Minion](<a href="https://octodex.github.com/images/minion.png" target="_blank" rel="noopener">https://octodex.github.com/images/minion.png</a> =200x200)<br>使用指定的大小顯示圖片</p><h4 id="註腳"><a href="#註腳" class="headerlink" title="註腳"></a>註腳</h4><p>註腳 1 連結[^first].<br>註腳 2 連結[^second].<br>行內註腳^[行內註腳的文字] 定義<br>重複的註腳參考[^second].</p><p>[^first]:</p><p>  註腳 <strong>也可以標記</strong><br>  還可以有很多段落</p><p>[^second]: 註腳 文字</p><h4 id="定義清單"><a href="#定義清單" class="headerlink" title="定義清單"></a>定義清單</h4><p>名詞 1</p><p>: 定義 1 快速連續項目</p><p>名詞 2 加上 <em>行內標記</em></p><p>: 定義 2</p><pre><code>    { 這些程式碼屬於 定義 2 的一部分 }定義 2 的第三段落</code></pre><p><em>緊密樣式：</em></p><p>名詞 1<br>~ 定義 1</p><p>名詞 2<br>~ 定義 2a<br>~ 定義 2b</p><h4 id="縮寫"><a href="#縮寫" class="headerlink" title="縮寫"></a>縮寫</h4><p>這是 HTML 的縮寫範例<br>它會轉換 ‘HTML’，但是縮寫旁邊其他的部分，例如：”xxxHTMLyyy”，不受影響</p><p>*[HTML]: Hyper Text Markup Language</p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 開始e=>end: 結束op=>operation: 我的操作op2=>operation: 啦啦啦cond=>condition: 是或否？st->op->op2->condcond(yes)->econd(no)->op2</textarea><textarea id="flowchart-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">艾莉絲->包柏: 哈摟，你好嗎？Note right of 包柏: 包柏思考中包柏-->艾莉絲: 我很好，謝謝！Note left of 艾莉絲: 艾莉絲回應艾莉絲->包柏: 最近過得怎樣？</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【讀書筆記】JavaScript Design Pattern Chapter06 程式碼重用模式（下）</title>
      <link href="/javascript-design-pattern-multiplexing02/"/>
      <url>/javascript-design-pattern-multiplexing02/</url>
      
        <content type="html"><![CDATA[<p>原型繼承模式可以開始討論「modern」的無 class 模式，物件要繼承自其他物件。</p><a id="more"></a><h2 id="原型繼承"><a href="#原型繼承" class="headerlink" title="原型繼承"></a>原型繼承</h2><p>原型繼承模式可以開始討論「modern」的無 class 模式，物件要繼承自其他物件。</p><p>假設你有個物件需要重用，需要從這個物件取得功能，已建立第二個物件，會這樣：</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> parent = &#123;</span><br><span class="line">  name: <span class="hljs-string">'Papa'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> child = object(parent);</span><br><span class="line">alert(child.name); <span class="hljs-comment">//"Papa"</span></span><br></pre></td></tr></table></figure></p><p>新增的 child 物件希望讓他和 parent 物件有一樣的屬性和方法，這個新的物件由 object 的函式去建立，但 JavaScript 本身沒有這個函式，那我們必須實作這個函式：</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">object</span>(<span class="hljs-params">o</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>這邊讓 暫時建構式 F() 的原型指向父物件，最後在回傳這個實體，在這邊的 child 物件本身為空，但他可以使用 parent 的原型。</p><h2 id="討論"><a href="#討論" class="headerlink" title="討論"></a>討論</h2><p>當使用建構式來實作原型繼承模式，注意自身的屬性和建構式原型的屬性都會被繼承：</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//父建構式</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">//一個自己的屬性</span></span><br><span class="line">  <span class="hljs-keyword">this</span>.name = <span class="hljs-string">'Adam'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//在原型中新增屬性</span></span><br><span class="line">Person.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//建立新的 Persons</span></span><br><span class="line"><span class="hljs-keyword">var</span> papa = <span class="hljs-keyword">new</span> Person();</span><br><span class="line"><span class="hljs-comment">//繼承</span></span><br><span class="line"><span class="hljs-keyword">var</span> kid = object(papa);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//測試自身的屬性和來自原型的屬性是不是都被繼承</span></span><br><span class="line">kid.getName(); <span class="hljs-comment">//"Adam"</span></span><br></pre></td></tr></table></figure></p><p>另一個變形範例，你可以選擇是否只繼承建構式的原型物件：</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 父建構式</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">//一個自己的屬性</span></span><br><span class="line">  <span class="hljs-keyword">this</span>.name = <span class="hljs-string">'Adam'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//在原型中新增了一個屬性</span></span><br><span class="line">Person.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//繼承</span></span><br><span class="line"><span class="hljs-keyword">var</span> kid = obejct(Person.prototype);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">typeof</span> kid.getName; <span class="hljs-comment">//"function" 因為只繼承了 prototype 的函式</span></span><br><span class="line"><span class="hljs-keyword">typeof</span> kid.name; <span class="hljs-comment">//"undefined" 而沒有繼承建構式內的屬性</span></span><br></pre></td></tr></table></figure></p><h3 id="ECMA-5-特性"><a href="#ECMA-5-特性" class="headerlink" title="ECMA 5 特性"></a>ECMA 5 特性</h3><p>現在有 <code>Object.create</code> 方法，我們不需要再做剛剛 <code>Object()</code> 的實作了：</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> child = <span class="hljs-built_in">Object</span>.create(parent);</span><br></pre></td></tr></table></figure></p><p><code>Object.create</code> 接受了一個額外的參數：一個物件，這個物件的屬性會被加到新物件的屬性內：</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> child = <span class="hljs-built_in">Object</span>.create(parent, &#123;</span><br><span class="line">  age: &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">2</span> &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">child.hasOwnProperty(<span class="hljs-string">'age'</span>); <span class="hljs-comment">//true</span></span><br></pre></td></tr></table></figure></p><h2 id="用複製屬性實作繼承"><a href="#用複製屬性實作繼承" class="headerlink" title="用複製屬性實作繼承"></a>用複製屬性實作繼承</h2><p>在這個模式之中，物件像其他物件取得功能的方式，只是簡單的使用複製，只是用迴圈來尋訪父物件的所有成員並複製他們，child 參數是選用的，沒有就會建立一個全新物件並回傳：</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extend</span>(<span class="hljs-params">parent, child</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> i;</span><br><span class="line">  child = child || &#123;&#125;;</span><br><span class="line">  <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> parent) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (parent.hasOwnProperty(i)) &#123;</span><br><span class="line">      child[i] = parent[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> dad = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">'Adam'</span> &#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> kid = extend(dad);</span><br><span class="line">kid.name; <span class="hljs-comment">//"Adam"</span></span><br></pre></td></tr></table></figure></p><p>這邊做的是淺拷貝，因為 JavaScript 的物件是使用參考來傳遞，一樣尋訪每個屬性並複製，只要該屬性是物件，那麼也同時改到父物件：</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> dad = &#123;</span><br><span class="line">  counts: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],</span><br><span class="line">  reads: &#123; <span class="hljs-attr">paper</span>: <span class="hljs-literal">true</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> kid = extend(dad);</span><br><span class="line">kid.counts.push(<span class="hljs-number">4</span>);</span><br><span class="line">dad.counts.toString(); <span class="hljs-comment">//"1,2,3,4"</span></span><br><span class="line">dad.reads === kid.reads; <span class="hljs-comment">//true</span></span><br></pre></td></tr></table></figure></p><p>想要避免這個問題就要使用深拷貝，深拷貝會檢查你要複製的屬性是否為物件或陣列，如果是的話會以遞迴的方式進入該物件。</p><p>你需要做的就是檢查屬性是否為物件，是的話就已遞迴方式複製每個屬性：</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extendDeep</span>(<span class="hljs-params">parent, child</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> i,</span><br><span class="line">    toStr = <span class="hljs-built_in">Object</span>.prototype.toString,</span><br><span class="line">    astr = <span class="hljs-string">'[object Array]'</span>;</span><br><span class="line"></span><br><span class="line">  child = child || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> parent) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (parent.hasOwnProperty(i)) &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> parent[i] === <span class="hljs-string">'object'</span>) &#123;</span><br><span class="line">        child[i] = toStr.call(parent[i]) === astr ? [] : &#123;&#125;;</span><br><span class="line">        extendDeep(parent[i], child[i]);</span><br><span class="line">      &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        child[i] = parent[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下來看新的實作，是否真的深拷貝到物件：</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> dad = &#123;</span><br><span class="line">  counts: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],</span><br><span class="line">  reads: &#123; <span class="hljs-attr">paper</span>: <span class="hljs-literal">true</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> kid = extendDeep(dad);</span><br><span class="line"></span><br><span class="line">kid.counts.push(<span class="hljs-number">4</span>);</span><br><span class="line">kid.counts.toString(); <span class="hljs-comment">//"1,2,3,4"</span></span><br><span class="line">dad.counts.toString(); <span class="hljs-comment">//"1,2,3"</span></span><br><span class="line"></span><br><span class="line">dad.reads === kids.reads; <span class="hljs-comment">//false</span></span><br><span class="line">kid.reads.paper = <span class="hljs-literal">false</span>;</span><br><span class="line">kid.reads.web = <span class="hljs-literal">true</span>;</span><br><span class="line">dad.reads.paper; <span class="hljs-comment">//true</span></span><br></pre></td></tr></table></figure></p><p>而這個模式完全沒有涉及到原型：只有物件跟物件自身的屬性。</p><h2 id="混搭"><a href="#混搭" class="headerlink" title="混搭"></a>混搭</h2><p>混搭模式，不僅從一個物件複製，可以從任意數量的物件來複製屬性，並將他們混合到一個新物件中，只用迴圈跑過參數列，將傳遞進來的每個物件的每個屬性都複製起來：</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mix</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> arg,</span><br><span class="line">    prop,</span><br><span class="line">    child = &#123;&#125;;</span><br><span class="line">  <span class="hljs-keyword">for</span> (arg = <span class="hljs-number">0</span>; arg &lt; <span class="hljs-built_in">arguments</span>.length; args += <span class="hljs-number">1</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (prop <span class="hljs-keyword">in</span> <span class="hljs-built_in">arguments</span>[arg]) &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>[arg].hasOwnProperty(prop)) &#123;</span><br><span class="line">        child[prop] = <span class="hljs-built_in">arguments</span>[arg][prop];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>現在有個通用的混搭模式，可以傳遞任何數量的物件給他，並得到一個新物件：</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> cake = mix(&#123; <span class="hljs-attr">egg</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">large</span>: <span class="hljs-literal">true</span> &#125;, &#123; <span class="hljs-attr">butter</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">salted</span>: <span class="hljs-literal">true</span> &#125;, &#123; <span class="hljs-attr">flour</span>: <span class="hljs-string">'3 cups'</span> &#125;, &#123; <span class="hljs-attr">sugar</span>: <span class="hljs-string">'sure!'</span> &#125;);</span><br></pre></td></tr></table></figure></p><h2 id="借用方法"><a href="#借用方法" class="headerlink" title="借用方法"></a>借用方法</h2><p>有時候會發生一個狀況，你只需要物件中的一到兩個方法，，你希望重用他們，但不希望對該物件建立父子物件關係，這時候可以使用借用方法。</p><p>此模式是受益於 <code>call</code> 及 <code>apply</code>，兩者差別在他們接受的參數一個使用陣列表示，一個則接受一個個獨立參數。</p><p>這裡有個物件叫 myobj ，而且你知道另一個 notmyobj 物件裡有個 doStuff 方法，我們需要暫時借用他，你傳入你的物件，讓借來方法的 this 綁在 myobj 物件。</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// call</span></span><br><span class="line">notmyobj.doStuff.call(myobj, param1, p2, p3);</span><br><span class="line"><span class="hljs-comment">// apply</span></span><br><span class="line">notmyobj.doStuff.apply(myobj, [param1, p2, p3]);</span><br></pre></td></tr></table></figure></p><h3 id="範例：向陣列借用方法"><a href="#範例：向陣列借用方法" class="headerlink" title="範例：向陣列借用方法"></a>範例：向陣列借用方法</h3><p>陣列有些有很好用的方法，而像 arguments 則沒有這些方法，這時可以使用 <code>slice</code> 跟陣列借用：</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> args = [].slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);</span><br><span class="line">  <span class="hljs-keyword">return</span> args;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>); <span class="hljs-comment">// returns [2,3]</span></span><br></pre></td></tr></table></figure></p><p>有個空物件被建立出來，只是為了使用他的方法。<br>另一種稍微長的方式是向 <code>Array.prototype.slice.call(...)</code>，這個方始要輸入比較常，但是可以省略建立空陣列的運算。</p><h3 id="借用並綁定"><a href="#借用並綁定" class="headerlink" title="借用並綁定"></a>借用並綁定</h3><p>不管是透過 call、apply 或是簡單的賦值來借用方法，方法內的 this 所指向的物件都是依賴運算式來決定，最好讓 this 的值在事先就綁定在一個特定的值。</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> onder = &#123;</span><br><span class="line">  name: <span class="hljs-string">'object'</span>,</span><br><span class="line">  say: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">greet</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> greet + <span class="hljs-string">', '</span> + <span class="hljs-keyword">this</span>.name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//試用</span></span><br><span class="line">one.say(<span class="hljs-string">'hi'</span>); <span class="hljs-comment">//"hi, object"</span></span><br></pre></td></tr></table></figure></p><p>現在有個 two 沒有 <code>say()</code> 方法，讓他從 one 那邊借用，<code>say()</code> 的 this 指向 two ，因此 this.name 為「another object」：</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> two = &#123;</span><br><span class="line">  name: <span class="hljs-string">'another object'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">one.say.apply(two, [<span class="hljs-string">'hello'</span>]); <span class="hljs-comment">//"hello, another object"</span></span><br></pre></td></tr></table></figure></p><p>如果將函式指標賦予給全域變數，或者將函式作為 callback，那這樣的狀況該如何處理：</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//將方法指定給變數</span></span><br><span class="line"><span class="hljs-comment">//方法內的 this 會指向全域物件</span></span><br><span class="line"><span class="hljs-keyword">var</span> say = one.say;</span><br><span class="line">say(<span class="hljs-string">'hoho'</span>); <span class="hljs-comment">//"hoho, undefined"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//將方法作為回呼傳遞</span></span><br><span class="line"><span class="hljs-keyword">var</span> yetanother = &#123;</span><br><span class="line">  name: <span class="hljs-string">'Yet another object'</span>,</span><br><span class="line">  method: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> callback(<span class="hljs-string">'Hola'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">yetanother.method(one.say); <span class="hljs-comment">//"Holla, undefined"</span></span><br></pre></td></tr></table></figure></p><p><code>say()</code> 內部的 this 都指向了全域，於是上面整段都不如預期，這時候可以用一個簡單的函式，來將一個物件固定，或是綁在方法：</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bind</span>(<span class="hljs-params">o, m</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> m.apply(o, [].slice.call(<span class="hljs-built_in">arguments</span>));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>這個 bind 函式接受一個物件 o 和方法 m，將兩者綁定在一起後回傳一個新函式，新的函式透過閉包來存取 o 和 m，所以即使 bind 回傳之後，裡面那個函式也可以存取指向原本的物件跟方法（o 和 m）。</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> twosay = bind(two, one.say);</span><br><span class="line">twosay(<span class="hljs-string">'yo'</span>); <span class="hljs-comment">//"yo, another object"</span></span><br></pre></td></tr></table></figure></p><p>透過上面的實作可以知道，twosay 被建立成一個全域函式，this 也沒有指向全域物件，而是指向傳遞給 bind 的 two 物件，不管用什麼方式呼叫 twosay，this 都永遠綁定 two。</p><h3 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind()"></a>Function.prototype.bind()</h3><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> newFunc = obj.someFunc.bind(myobj, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</span><br><span class="line"><span class="hljs-comment">// 將 someFunc 和 myobj 綁在一起，並同時域先填好三個參數給 someFunc。</span></span><br></pre></td></tr></table></figure></p><p>bind 的實作：</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Function</span>.prototype.bind === <span class="hljs-string">'undefined'</span>) &#123;</span><br><span class="line">  <span class="hljs-built_in">Function</span>.prototype.bind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">this</span>,</span><br><span class="line">      slice = <span class="hljs-built_in">Array</span>.prototype.slice,</span><br><span class="line">      args = slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> fn.apply(thisArg, args.concat(slice.call(<span class="hljs-built_in">arguments</span>)));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>這份實作使用了部分應用，並串接參數列，包含傳遞給 bind 的參數（不含第一個），還有之後傳給 bind 所建立的新函數的參數，除了要綁的物件之外，沒有傳其他參數：</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> twosay2 = one.say.bind(two);</span><br><span class="line">twosay2(<span class="hljs-string">'Bonjour'</span>); <span class="hljs-comment">//"Bonjour, another object"</span></span><br></pre></td></tr></table></figure></p><p>這個範例，我們傳遞一個參數來做部分應用：</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> twosay3 = one.say.bind(two, <span class="hljs-string">'hihihi'</span>);</span><br><span class="line">twosay3(); <span class="hljs-comment">//"hihihi, another object"</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 讀書筆記 </tag>
            
            <tag> JSDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【讀書筆記】JavaScript Design Pattern Chapter06 程式碼重用模式（上）</title>
      <link href="/javascript-design-pattern-multiplexing01/"/>
      <url>/javascript-design-pattern-multiplexing01/</url>
      
        <content type="html"><![CDATA[<ul><li>「多用物件複合，少用類別繼承。」</li><li>說到程式碼重用，第一件事想到的就是繼承，但他不是唯一一種方法。</li></ul><a id="more"></a><h2 id="Classical-繼承模式-v-s-Modern-繼承模式"><a href="#Classical-繼承模式-v-s-Modern-繼承模式" class="headerlink" title="Classical 繼承模式 v.s. Modern 繼承模式"></a>Classical 繼承模式 v.s. Modern 繼承模式</h2><p>在有 class 的語言中，每個物件都是某個特定的 class 的一個實體，沒有 class 就無法建立出物件，但在 JavaScript 中，物件僅是名與值，可以立即建立及改變。</p><p>JavaScript 有建構式，new 運算子類似 classes 的用法。</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person adam = <span class="hljs-keyword">new</span> Person();</span><br><span class="line"><span class="hljs-comment">//Java</span></span><br><span class="line"><span class="hljs-keyword">var</span> adam = <span class="hljs-keyword">new</span> Person();</span><br><span class="line"><span class="hljs-comment">//JavaScript</span></span><br></pre></td></tr></table></figure></p><p>這兩段語法非常相像，但建構式仍舊是函式，導致許多開發者用 class 的方式來思考 JavaScript，進而發展出模擬 class 的繼承想法，這稱之為「classical」。而所謂的「modern」模式指的是讓你不需要思考 classes 的其他所有模式。</p><h2 id="使用-Classical-繼承的預期結果"><a href="#使用-Classical-繼承的預期結果" class="headerlink" title="使用 Classical 繼承的預期結果"></a>使用 Classical 繼承的預期結果</h2><p>Classical 的實作目標是讓一個 <code>child();</code> 建構式所建立的物件可以取得另一個<code>Parent();</code>建構式的屬性。</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">name</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.name = name || <span class="hljs-string">'Adam'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//父建構式</span></span><br><span class="line">Parent.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">//新增功能</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">name</span>) </span>&#123;&#125;</span><br><span class="line"><span class="hljs-comment">//子建構式</span></span><br><span class="line">inherit(Child, Parent);</span><br><span class="line"><span class="hljs-comment">//繼承</span></span><br></pre></td></tr></table></figure></p><p><code>inherit()</code> 函式做了繼承的工作，但它需要自己實作，非語言提供。</p><h2 id="Classical-模式-1-——-預設的模式"><a href="#Classical-模式-1-——-預設的模式" class="headerlink" title="Classical 模式 #1 —— 預設的模式"></a>Classical 模式 #1 —— 預設的模式</h2><p>最常用的方式，是使用 <code>Parent()</code> 建構式建立一個物件，並指派給 <code>Child()</code> 的原型。</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inherit</span>(<span class="hljs-params">C, P</span>) </span>&#123;</span><br><span class="line">  C.prototype = <span class="hljs-keyword">new</span> P();</span><br><span class="line">  <span class="hljs-comment">//注意 new 運算子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>prototype 應指向一個物件而非函式，所以它必須指向父建構式所建立的實體，而非建構式本身。之後使用<code>new Child();</code> 就會取得 <code>Parent();</code> 的原型。</p><h3 id="追蹤原型鍊"><a href="#追蹤原型鍊" class="headerlink" title="追蹤原型鍊"></a>追蹤原型鍊</h3><p>用這個模式，你同時繼承了實體本身的屬性和方法。</p><ol><li>用 <code>new Pserson()</code> 建立一個物件，他保有 name 的屬性資料。</li><li>物件嘗試存取 <code>say()</code> ，但建構式沒有這個方法。</li><li>往上查找 <code>Pserson()</code> 的 prototype。</li></ol><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> kid = <span class="hljs-keyword">new</span> Child();</span><br><span class="line">kid.say(); <span class="hljs-comment">//"Adam"</span></span><br></pre></td></tr></table></figure></p><p>建構式 <code>Child()</code> 和 prototype 都是空白的，<strong>proto</strong> 指向 <code>inherit()</code> 函式建立的 <code>new Pserson()</code> ，在呼叫 <code>say()</code> ，子建構式沒有這個方法，父建構式也沒有這個方法，就會再往上查找父建構式的 prototype。</p><p><code>say()</code> 裡面有個參考 <code>this.name</code>，再依序從 <code>kid</code>、子建構式、子建構式 prototype、父建構式、父建構式 prototype 查找。</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> kid = <span class="hljs-keyword">new</span> Child();</span><br><span class="line">kid.name = <span class="hljs-string">'Amy'</span>;</span><br><span class="line">kid.say(); <span class="hljs-comment">//"Amy"</span></span><br></pre></td></tr></table></figure></p><p><code>kid.name</code> 不會修改父建構式的屬性，會在自身直接建立新的屬性，<code>say()</code> 再從剛剛的序列查找，查找<code>this.name</code>，在 <code>kid</code> 物件就找到了。</p><h3 id="模式-1-的缺點"><a href="#模式-1-的缺點" class="headerlink" title="模式 #1 的缺點"></a>模式 #1 的缺點</h3><ul><li>同時繼承加在 this 本身的屬性和原形的屬性，大多時候你並不想要本身的屬性，這比較像是屬於特定的實例，不適合重用。</li><li>不能讓參數給予子建構式，再讓子建構式傳遞給父建構式。</li></ul><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">'Setch'</span>);</span><br><span class="line">s.say(); <span class="hljs-comment">//"Adam"</span></span><br><span class="line"><span class="hljs-comment">//希望出現 Setch，但出現 Adam</span></span><br></pre></td></tr></table></figure></p><p>這個結果不如預期，必須每次需要子物件時執行一次繼承，最後是不斷再建立父建構式。</p><h2 id="Classical-模式-2-——-借用建構式"><a href="#Classical-模式-2-——-借用建構式" class="headerlink" title="Classical 模式 #2 —— 借用建構式"></a>Classical 模式 #2 —— 借用建構式</h2><p>這個模式解決了上個範例的「無法傳遞參數」給父建構式的問題，他借用了父建構式，將子建構式用 this 綁定父建構式，並轉送所有參數：</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">a, c, b, d</span>) </span>&#123;</span><br><span class="line">  Parent.apply(<span class="hljs-keyword">this</span>, argument);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用這個方法，只繼承了在父建構式中加至 this 的屬性，而沒有繼承加到原型的成員，子物件可以取得繼承成員的複製，而不像第一個模式（只是參考）。</p><p>範例比較：</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Article</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.tag = [<span class="hljs-string">'js'</span>, <span class="hljs-string">'css'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> article = <span class="hljs-keyword">new</span> Article();</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Blogpost</span>(<span class="hljs-params"></span>) </span>&#123;&#125;</span><br><span class="line">Blogpost.prototype = article;</span><br><span class="line"><span class="hljs-keyword">var</span> blog = <span class="hljs-keyword">new</span> BlogPost();</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">StaticPage</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  Article.call(<span class="hljs-keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> page = <span class="hljs-keyword">new</span> StaticPage();</span><br><span class="line"></span><br><span class="line">article.hasOwnProperty(<span class="hljs-string">'tags'</span>); <span class="hljs-comment">// true</span></span><br><span class="line">blog.hasOwnProperty(<span class="hljs-string">'tags'</span>); <span class="hljs-comment">// false</span></span><br><span class="line">page.hasOwnProperty(<span class="hljs-string">'tags'</span>); <span class="hljs-comment">// true</span></span><br></pre></td></tr></table></figure></p><ul><li>第一種的預設模式使得 blog 物件可以透過原型獲得 tags 的存取權，自身不具有 tags，所以是 false。</li><li>第二種借用模式，page 自身屬性有 tags，是因為使用了借用建構式，新物件就會取得父建構式 tags 成員的複製，而不是參考。</li></ul><h3 id="原型鍊"><a href="#原型鍊" class="headerlink" title="原型鍊"></a>原型鍊</h3><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">name</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.name = name || <span class="hljs-string">'Adam'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">//父建構式新增新功能</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">name</span>) </span>&#123;</span><br><span class="line">  Parent.apply(<span class="hljs-keyword">this</span>.argument);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//子建構式繼承父建構式，但不會繼承父原型</span></span><br><span class="line"><span class="hljs-keyword">var</span> kid = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">'Amy'</span>);</span><br><span class="line">kid.name; <span class="hljs-comment">//"Amy"</span></span><br><span class="line"><span class="hljs-keyword">typeof</span> kid.say; <span class="hljs-comment">//"undefined"</span></span><br></pre></td></tr></table></figure></p><p>Child.prototype 根本沒被使用到，他所指向的是一個空物件。</p><h3 id="用借用建構式實現多重繼承"><a href="#用借用建構式實現多重繼承" class="headerlink" title="用借用建構式實現多重繼承"></a>用借用建構式實現多重繼承</h3><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.legs = <span class="hljs-number">4</span>;</span><br><span class="line">  <span class="hljs-keyword">this</span>.say = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">'meaowww'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Bird</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.wings = <span class="hljs-number">2</span>;</span><br><span class="line">  <span class="hljs-keyword">this</span>.fly = <span class="hljs-literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CatWings</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  Cat.apply(<span class="hljs-keyword">this</span>);</span><br><span class="line">  Bird.apply(<span class="hljs-keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> jane = <span class="hljs-keyword">new</span> CatWings();</span><br><span class="line"><span class="hljs-built_in">console</span>.dir(jane);</span><br></pre></td></tr></table></figure></p><h3 id="借用建構式的優點和缺點"><a href="#借用建構式的優點和缺點" class="headerlink" title="借用建構式的優點和缺點"></a>借用建構式的優點和缺點</h3><ul><li>優點：可以拿到父物件自身屬性的複製，而不是參考，所以不會有意外覆寫到父物件屬性的問題。</li><li>缺點：prototype 的屬性都沒被繼承</li></ul><h2 id="Classical-模式-3-——-借用並設定原型"><a href="#Classical-模式-3-——-借用並設定原型" class="headerlink" title="Classical 模式 #3 —— 借用並設定原型"></a>Classical 模式 #3 —— 借用並設定原型</h2><p>將前兩個模式組合起來，先借用建構式，接著也將子建構式的原型指向父建構式的實體。</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">a, c, b, d</span>) </span>&#123;</span><br><span class="line">  Parent.apply(<span class="hljs-keyword">this</span>, argument);</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="hljs-keyword">new</span> Parent();</span><br></pre></td></tr></table></figure></p><h3 id="優點："><a href="#優點：" class="headerlink" title="優點："></a>優點：</h3><ul><li>子建構式取得了父建構式自身成員的複製</li><li>取得父建構式原型成員的參考</li><li>子建構式可以傳遞任何參數給父建構式</li></ul><h3 id="缺點："><a href="#缺點：" class="headerlink" title="缺點："></a>缺點：</h3><ul><li>父建構式被呼叫了兩次，效率比較差。</li></ul><h3 id="範例："><a href="#範例：" class="headerlink" title="範例："></a>範例：</h3><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">name</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.name = name || <span class="hljs-string">'Adam'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//父建構式</span></span><br><span class="line"></span><br><span class="line">Parent.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">//新增原型</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">name</span>) </span>&#123;</span><br><span class="line">  Parent.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="hljs-keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> kid = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">'Amy'</span>);</span><br><span class="line">kid.name; <span class="hljs-comment">// "Amy"</span></span><br><span class="line">kid.say(); <span class="hljs-comment">//"Amy"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">delete</span> kid.name;</span><br><span class="line">kid.say(); <span class="hljs-comment">//"Adam"</span></span><br></pre></td></tr></table></figure></p><p><code>say()</code> 的原型被繼承了，所以當自身的 <code>name</code> 被刪除，就會使用到原型鍊預設的屬性。</p><h2 id="Classical-模式-4-——-分享原型"><a href="#Classical-模式-4-——-分享原型" class="headerlink" title="Classical 模式 #4 —— 分享原型"></a>Classical 模式 #4 —— 分享原型</h2><p>這個模式不像上一個繼承模式一樣，需要呼叫兩次父建構式，這個模式不會引發父建構式的呼叫。</p><p>根據經驗來說，重要的成員，且任何需要繼承的事物，都應該放在原型，而不是放在 this 裏，那就可以將子建構式原型設為和父建構式原型相同。</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inherit</span>(<span class="hljs-params">C, P</span>) </span>&#123;</span><br><span class="line">  C.prototype = P.prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但所有物件其實都分享相同原型，導致修改了原型，就會影響所有原型鏈。</p><h2 id="Classical-模式-5-——-暫時的建構式"><a href="#Classical-模式-5-——-暫時的建構式" class="headerlink" title="Classical 模式 #5 —— 暫時的建構式"></a>Classical 模式 #5 —— 暫時的建構式</h2><p>這個模式可以打斷父原型和子原型之間的連結，同時又能受益於原型鏈的優點。</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inherit</span>(<span class="hljs-params">C, P</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;</span><br><span class="line">  F.prototype = P.prototype;</span><br><span class="line">  C.prototype = <span class="hljs-keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>這個模式和 #1 的預設模式稍有不同，因為這邊的子物件謹繼承原型的屬性，這樣利用了「原型就是為了放置可重用功能的地方」也處理好 this，「讓任何在父建構式加在 this 的成員都不會被繼承」。</p><p>建立一個新的子物件，並觀察他的行為：</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> kid = <span class="hljs-keyword">new</span> Child();</span><br></pre></td></tr></table></figure></p><p>若你存取 <code>kid.name</code> 會是 undefined，因為 <code>name</code> 是父建構式自身的屬性，而在繼承的過程中，並沒有呼叫 <code>new Parent()</code> 代表根本沒有父建構式的屬性。</p><p>而當存取 <code>kid.say()</code> 的時候，物件在 <code>new Child()</code> 根本不存在，因此原型鏈會向上查找，<code>new F()</code> 也沒有這個方法，但 <code>Parent.prototype</code> 有這個方法，<code>Parent.prototype</code> 會讓所有繼承 <code>Parent()</code> 的不同建構式和這些子建構式所建立的物件所共享，他們使用的都是同一塊記憶體。</p><h3 id="Superclass"><a href="#Superclass" class="headerlink" title="Superclass"></a>Superclass</h3><p>在前一個模式的基礎上，你可以新增一個參考指向原本的父親，這很類似在其他語言的 superclass。</p><p>我們將屬性命名為 uber，因為「super」是個保留字，而 superclass 可能會引導不知情開發者的聯想，而誤以為 Javascript 是有 class 的。</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inherit</span>(<span class="hljs-params">C, P</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;</span><br><span class="line">  F.prototype = P.prototype;</span><br><span class="line">  C.prototype = <span class="hljs-keyword">new</span> F();</span><br><span class="line">  C.uber = P.prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="重新設定建構式的參考"><a href="#重新設定建構式的參考" class="headerlink" title="重新設定建構式的參考"></a>重新設定建構式的參考</h3><p>現在我們的 classical 繼承函式近乎完美，最後我們要重新設定建構式的參考，如果不設定的話，所以有的子物件就會回報 <code>Parent()</code> 是他的建構式，這樣不行的。</p><p>假設用前一份 <code>inherit()</code> 的實作：</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">inherit(Child, Parent);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> kid = <span class="hljs-keyword">new</span> Child();</span><br><span class="line">kid.constructor.name; <span class="hljs-comment">//"Parent"</span></span><br><span class="line">kid.constructor === Parent; <span class="hljs-comment">//true</span></span><br></pre></td></tr></table></figure></p><p>constructor 屬性比較少用，但在執行時期用來檢查物件很方便，可以重新設定，讓他指向預期中的建構式。</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inherit</span>(<span class="hljs-params">C, P</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;</span><br><span class="line">  F.prototype = P.prototype;</span><br><span class="line">  C.prototype = <span class="hljs-keyword">new</span> F();</span><br><span class="line">  C.uber = P.prototype;</span><br><span class="line">  C.prototype.constructor = C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>這個模式又稱為聖杯繼承模式（holy grail）。</p><p>另一種聖杯模式的優化，是避免每次繼承都重複建立暫時（代理）建構式，因為我們建立一次就夠了，需要改變的是他的原型，可以利用一個立即函式，並將 proxy 函式儲存在他的閉包裏。</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> inherit = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">C, P</span>) </span>&#123;</span><br><span class="line">    F.prototype = P.prototype;</span><br><span class="line">    C.prototype = <span class="hljs-keyword">new</span> F();</span><br><span class="line">    C.uber = P.prototype;</span><br><span class="line">    C.prototype.constructor = C;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><h3 id="Klass"><a href="#Klass" class="headerlink" title="Klass"></a>Klass</h3><p>許多 JavaScript 函式庫都在模擬 class ，並提供新的語法糖，將下來的實作有點不一樣，但有一些共通點：</p><ul><li>命名都有一組慣例，遵循這個慣例都會被當成 class 的建構式，例如：initialize、_init 等等。</li><li>Classes 可以繼承其他 classes</li><li>可以在子 class 中存取父 class（superclass）。</li></ul><p>接下來用 JavaScript 來模擬 Class。</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> Man = klass(<span class="hljs-literal">null</span>, &#123;</span><br><span class="line">  __construct: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">what</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Man's constructor"</span>);</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = what;</span><br><span class="line">  &#125;,</span><br><span class="line">  getName: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>上述範例，是以一個 klass 函式的形式出現，你在其他狀況可以會看到 Klass 的建構式，或是 Object.prototype 的方式出現，關於 klass 函式的實作，下方會在探討。</p><p>這個函式接受兩個參數：</p><ul><li>父 class 作為繼承用</li><li>一個新的 class 實作，採用物件實字語法</li></ul><p>規定 class 的建構式必須是一個名為 __constructor 的方法。一個 Man 的 class 實作，他不繼承任何 class，意思就是他繼承的是 object。</p><p>Man 本身有自己的屬性，建立在 constructor 中，另外還有個 getName 方法，Man class 本身就是建構式，接下來的動作讓它更像 class 實體化：</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> first = <span class="hljs-keyword">new</span> Man(<span class="hljs-string">'Adam'</span>); <span class="hljs-comment">//logs "Man's constructor"</span></span><br><span class="line">first.getName(); <span class="hljs-comment">//"Adam"</span></span><br></pre></td></tr></table></figure></p><p>接下來來擴充新的 class，建立 SuperMan class：</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> SuperMan = klass(Man, &#123;</span><br><span class="line">  __construct: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">what</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"SuperMan's constructor"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  getName: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> name = SuperMan.uber.getName.call(<span class="hljs-keyword">this</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">'I am'</span> + name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>這個範例中，給的第一個參數是 class Man，會被繼承，在 <code>getName()</code> 它利用 SuperMan 的 uber（super）靜態屬性呼叫父 class 的 <code>getName()</code>：</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> clark = <span class="hljs-keyword">new</span> SuperMan(<span class="hljs-string">'Clark Kent'</span>);</span><br><span class="line">clark.getName(); <span class="hljs-comment">//"I am Clark Kent"</span></span><br></pre></td></tr></table></figure></p><p>在 <code>console.log</code> 裡面，印出的第一行是「Man’s constructor」接著是「SuperMan’s constructor」，父建構式會在子建構式之前呼叫。</p><p>再來試看看 instanceof 運算子是否回傳預期中的結果：</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clark <span class="hljs-keyword">instanceof</span> Man; <span class="hljs-comment">//true</span></span><br><span class="line">clark <span class="hljs-keyword">instanceof</span> SuperMan; <span class="hljs-comment">//true</span></span><br></pre></td></tr></table></figure></p><p>接下來看看 klass 實作：</p><p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> klass = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Parent, props</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> Child, F, i;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">//1.</span></span><br><span class="line">  <span class="hljs-comment">//新的建構式，在最後會被回傳，且被當 class使用。</span></span><br><span class="line">  <span class="hljs-comment">//在函式中呼叫 __consteuct 方法，在那之前會先利用靜態的 uber 屬性呼叫父 class 的 __consteuct ，如果繼承是 Object 的話， uber 有可能未被定義，例如 class 的 Man。</span></span><br><span class="line">  Child = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (Child.uber &amp;&amp; Child.uber.hasOwnProperty(<span class="hljs-string">'__construct'</span>)) &#123;</span><br><span class="line">      Child.uber.__construct.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (Child.uber.hasOwnProperty(<span class="hljs-string">'__construct'</span>)) &#123;</span><br><span class="line">      Child.prototype.__construct.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">//2.</span></span><br><span class="line">  <span class="hljs-comment">//新的建構式，使用了前面的 classical 繼承的聖杯模式</span></span><br><span class="line">  <span class="hljs-comment">//如果 沒有需要繼承的 Parent，那就繼承 Object 的 prototype。</span></span><br><span class="line">  Parent = Parent || <span class="hljs-built_in">Object</span>;</span><br><span class="line">  F = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;</span><br><span class="line">  F.prototype = Parent.prototype;</span><br><span class="line">  Child.prototype = <span class="hljs-keyword">new</span> F();</span><br><span class="line">  Child.uber = Parent.prototype;</span><br><span class="line">  Child.prototype.constructor = Child;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">//3.</span></span><br><span class="line">  <span class="hljs-comment">//加入實作的方法</span></span><br><span class="line">  <span class="hljs-comment">//用迴圈查找所有方法，加到 Child 的原型之中</span></span><br><span class="line">  <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> props) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (props.hasOwnProperty(i)) &#123;</span><br><span class="line">      Child.prototype[i] = props[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-comment">// 回傳Class</span></span><br><span class="line">  <span class="hljs-keyword">return</span> Child;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 讀書筆記 </tag>
            
            <tag> JSDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【讀書筆記】JavaScript Design Pattern Chapter05 物件建立模式（下）</title>
      <link href="/javascript-design-pattern-object02/"/>
      <url>/javascript-design-pattern-object02/</url>
      
        <content type="html"><![CDATA[<p>模組模式提供了結構化，所以被廣泛使用，JavaScript 沒有專給套件用的特殊語法，而模組模式提供工具，來建立自成一體且去耦合的程式碼。</p><a id="more"></a><h2 id="模組模式"><a href="#模組模式" class="headerlink" title="模組模式"></a>模組模式</h2><p>模組模式提供了結構化，所以被廣泛使用，JavaScript 沒有專給套件用的特殊語法，而模組模式提供工具，來建立自成一體且去耦合的程式碼。</p><p>模組模式是數種模式的組合：</p><ul><li>命名模式</li><li>立即函式</li><li>Private 成員和特權方法</li><li>宣告相依性</li></ul><p>第一步：建立命名空間——參考之前使用 namespace() 建立出 utility 模組範例：</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> MYAPP = namespace(<span class="hljs-string">'MYAPP.utilities.array'</span>);</span><br></pre></td></tr></table></figure></p><p>第二步：定義模組。此模組使用一個立即執行函式，如果需要隱私權就提供 private 作用域，立即函式會回傳一個物件：真正的模組，有自己 public 介面，給模組的客戶使用：</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line">MYAPP.utilities.array = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> &#123;</span><br><span class="line">    <span class="hljs-comment">//...</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p>接著新增一些 public 方法：</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line">MYAPP.utilities.array = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> &#123;</span><br><span class="line">    inArray: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">needle, haystack</span>) </span>&#123;</span><br><span class="line">      <span class="hljs-comment">//...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    isArray: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>) </span>&#123;</span><br><span class="line">      <span class="hljs-comment">//...</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><h3 id="揭示模組模式"><a href="#揭示模組模式" class="headerlink" title="揭示模組模式"></a>揭示模組模式</h3><p>前面介紹隱私權模式的時候已經討論過揭露模式，請參考前面範例，就是讓縮有方法保持 private 而僅在最後建立 public API。</p><h3 id="產生建構式的模組"><a href="#產生建構式的模組" class="headerlink" title="產生建構式的模組"></a>產生建構式的模組</h3><p>有時候建構式建立物件會更方便，唯一的差別就是包裝模組的立即函式回傳的不是物件，是函式。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line">MYAPP.utilities.array = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// 宣告相依性</span></span><br><span class="line">  <span class="hljs-keyword">var</span> uobj = MYAPP.utilities.object,</span><br><span class="line">    ulang = MYAPP.utilities.lang,</span><br><span class="line">    <span class="hljs-comment">// private 屬性跟方法</span></span><br><span class="line">    Constr;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">//Public API —— 建構式</span></span><br><span class="line">  Constr = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.elements = <span class="hljs-keyword">this</span>.toArray(o);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="hljs-comment">//Public API —— 原型</span></span><br><span class="line">  Constr.prototype = &#123;</span><br><span class="line">    consturctor: MYAPP.utilities.Array,</span><br><span class="line">    version: <span class="hljs-string">'2.0'</span>,</span><br><span class="line">    toArray: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>&#123;</span><br><span class="line">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, a = [], len = obj.length; i &lt; len; i += <span class="hljs-number">1</span>) &#123;</span><br><span class="line">        a[i] = obj[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="hljs-keyword">return</span> a;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="hljs-comment">// 回傳建構式</span></span><br><span class="line">  <span class="hljs-comment">// 給新的命名空間</span></span><br><span class="line">  <span class="hljs-keyword">return</span> Constr;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> MYAPP.utilities.Array(obj);</span><br></pre></td></tr></table></figure></p><h3 id="引進全域物件"><a href="#引進全域物件" class="headerlink" title="引進全域物件"></a>引進全域物件</h3><p>你可以傳遞參數給包裝模組的建構式，通常是全域變數的參考，甚至是全域物件的本身，引入全域物件可以幫忙加速立即函式的執行，因為引入的變數對函式來說而言已經是區域的。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line">MYAPP.utilities.module = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">app, global</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">//全域物件的參考</span></span><br><span class="line">  <span class="hljs-comment">//還有全域命名空間的物件</span></span><br><span class="line">  <span class="hljs-comment">//現在都為區域</span></span><br><span class="line">&#125;)(MYAPP, <span class="hljs-keyword">this</span>);</span><br></pre></td></tr></table></figure></p><h2 id="沙盒模式"><a href="#沙盒模式" class="headerlink" title="沙盒模式"></a>沙盒模式</h2><p>沙盒模式提供一個環境讓模組執行，此環境不會影響其他模組或沙盒。</p><p>除此之外，也解決了命名模式的缺點：</p><ul><li>命名模式依賴一個全域變數，不可能在同一頁面上讓同一個函式庫或程式的兩種版本同時執行，因為他們都需要全域符號。</li><li>命名空間需要輸入很長的明稱，執行時需要解析多層的命名。</li></ul><h3 id="一個全域建構式"><a href="#一個全域建構式" class="headerlink" title="一個全域建構式"></a>一個全域建構式</h3><p>全域物件的差別：</p><ul><li>命名空間模式：全域物件。</li><li>沙盒模式：全域建構式。</li></ul><p>利用這個建構式來建立物件，並同時傳遞一個回呼函式，此函式會讓沙盒看起來像一個孤立的環境。此建構式看起來像上個 MYAPP 範例。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">new</span> Sandbox(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">box</span>))</span>&#123;</span><br><span class="line"><span class="hljs-comment">//here is the code</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>再新增兩個特性：</p><ul><li>建立物件時可以使用 new ，也可以不用。</li><li>建構式可以額外接受一些設定值參數，來指定該物件實體所需要的模組名稱。</li></ul><p>略過 new 並用虛構的「ajax」、「event」模組來建立：</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line">Sandbox([<span class="hljs-string">'ajax'</span>, <span class="hljs-string">'event'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">box</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">//console.log(box);</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>拆成個別參數傳遞的用法：</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line">Sandbox(<span class="hljs-string">'ajax'</span>, <span class="hljs-string">'dom'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">box</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">//console.log(box);</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>當沒有傳遞任何模組的時候：</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line">Sandbox(<span class="hljs-string">'*'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">box</span>) </span>&#123;</span><br><span class="line"><span class="hljs-comment">//console.log(box);</span></span><br><span class="line">&#125;</span><br><span class="line">Sandbox(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">box</span>) </span>&#123;</span><br><span class="line"><span class="hljs-comment">//console.log(box);</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>巢狀化：</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line">Sandbox(<span class="hljs-string">'dom'</span>, <span class="hljs-string">'dom'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">box</span>) </span>&#123;</span><br><span class="line">  Sandbox(<span class="hljs-string">'ajax'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">box</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//兩邊的 box 物件是不同的</span></span><br><span class="line">    <span class="hljs-comment">// ajax</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="hljs-comment">//這邊的程式不會有 ajax 模組</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>這邊可以看到，程式碼被包進回呼函式來保護全域命名空間。除此之外也可以利用函式也是物件的特性，將資料用靜態屬性的方式儲存在沙盒建構式中。</p><h3 id="新增模組"><a href="#新增模組" class="headerlink" title="新增模組"></a>新增模組</h3><p>沙盒建構式也是物件，可以新增一個名為 modules 的靜態屬性，這屬性又是另一個物件：</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line">Sandbox.modules = &#123;&#125;;</span><br><span class="line">Sandbox.modules.dom = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">box</span>) </span>&#123;</span><br><span class="line">  box.getElement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;</span><br><span class="line">  box.getStyle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;</span><br><span class="line">  box.foo = <span class="hljs-string">'bar'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Sandbox.modules.event = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">box</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// box.constructor.prototype.m = "mm"</span></span><br><span class="line">  <span class="hljs-comment">// 如有必要則存取沙盒的原型</span></span><br><span class="line">  box.attachEvent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;</span><br><span class="line">  box.dettachEvent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>這個範例中加入了 dom 模組與 event 模組，每個函式都接受 box 實體為參數，可能會新增屬性或方法到這個 box 裡面。</p><h3 id="實作建構式"><a href="#實作建構式" class="headerlink" title="實作建構式"></a>實作建構式</h3><p>沙盒建構式實作範例：</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sandbox</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">//將參數轉為陣列</span></span><br><span class="line">  <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(argument),</span><br><span class="line">    callback = args.pop(),</span><br><span class="line">    modules = (atgs[<span class="hljs-number">0</span>] &amp;&amp; <span class="hljs-keyword">typeof</span> atgs[<span class="hljs-number">0</span>] === <span class="hljs-string">"string"</span>) ? args : args[<span class="hljs-number">0</span>],</span><br><span class="line">    i;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 確保函式是建構式呼叫</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Sandbox)) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Sandbox(modules, callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 依照需要為 this 增加屬性</span></span><br><span class="line">  <span class="hljs-keyword">this</span>.a = <span class="hljs-number">1</span>;</span><br><span class="line">  <span class="hljs-keyword">this</span>.b = <span class="hljs-number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 現在將模組新增至核心的 this 物件</span></span><br><span class="line">  <span class="hljs-comment">// 沒有指定模組或是用 * 來表示所有模組</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">module</span> || modules === <span class="hljs-string">'*'</span>) &#123;</span><br><span class="line">    modules = [];</span><br><span class="line">    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> Sandbox.modules) &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span> (Sandbox.modules.hasownProperty(i)) &#123;</span><br><span class="line">        modules.push(i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="hljs-comment">//初始所需要的模組</span></span><br><span class="line">      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; modules.length; i += <span class="hljs-number">1</span>) &#123;</span><br><span class="line">        Sandbox.modules[modules[i]](<span class="hljs-keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="hljs-comment">//執行回呼</span></span><br><span class="line">      callback(<span class="hljs-keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">Sandbox.prototype = &#123;</span><br><span class="line">name: <span class="hljs-string">"My App"</span>,</span><br><span class="line">version: <span class="hljs-number">1.0</span>,</span><br><span class="line">getName: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>檢查 this 是否為 Sandbox 的實體，如果不是，表示呼叫 Sandbox 沒有加 new ，那麼就以建構式的方式再呼叫函式。</li><li>可以在建構式中，新增屬性到 this ，也可以新增屬性到此函式的原型。</li><li>Sandbox 中所使用的模組名稱可以用陣列、個別參數、* 字號，或不填入參數。</li><li>你可以只載入最基礎的模組，所需的模組都可以用命名慣例找到外部檔案並載入。</li><li>如果已經知道所需模組便可初始化，意思是呼叫所有模組的實作函式。</li><li>建構式最後一個參數是回呼，會在新被建立好的實體中呼叫，這個回呼就是 Sandbox ，他會取得一個裝好全部所需功能的 box 物件。</li></ul><h2 id="靜態成員"><a href="#靜態成員" class="headerlink" title="靜態成員"></a>靜態成員</h2><ul><li>靜態的屬性和方法不會在實體之間有所改變。</li><li>以 class 為基礎的語言，靜態成員使用特別的語法建立並使用，也可以有 private 成員。</li></ul><h3 id="Public-靜態成員"><a href="#Public-靜態成員" class="headerlink" title="Public 靜態成員"></a>Public 靜態成員</h3><p>JavaScript 沒有特別的語法來表達靜態成員，但你可以使用建構式，並新增屬性到建構式中， 這樣如同擁有 class 語言的語法，因為建構式跟函式一樣都是物件，也可以擁有屬性，新增屬性可參考上一章記憶模式。</p><p>這個例子定義了一個建構式，有一個靜態方法和一個實體方法，靜態方法不需要 Gadget 物件就可以運作，但實體方法則需要。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">//建構式</span></span><br><span class="line"><span class="hljs-keyword">var</span> Gadget = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="hljs-comment">//靜態方法</span></span><br><span class="line">Gadget.isShiny = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-string">'u bet'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">//加在原型中的一般方法</span></span><br><span class="line">Gadget.prototype.setPrice = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">price</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.price = price;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>一般的方法要透過實體呼叫，而靜態方法可以直接透過建構式呼叫。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 呼叫靜態方法</span></span><br><span class="line">Gadget.isShiny(); <span class="hljs-comment">// "u bet"</span></span><br><span class="line"><span class="hljs-comment">// 建立一個實體然後呼叫方法</span></span><br><span class="line"><span class="hljs-keyword">var</span> iphone = <span class="hljs-keyword">new</span> Gadget();</span><br><span class="line">iphone.setPrice(<span class="hljs-number">500</span>);</span><br></pre></td></tr></table></figure></p><p>無法試圖用靜態方法呼叫實體，也同樣不能用實體呼叫靜態方法。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">typeof</span> Gadget.setPrice; <span class="hljs-comment">// "undefined"</span></span><br><span class="line"><span class="hljs-keyword">typeof</span> iphone.isShiny; <span class="hljs-comment">// "undefined"</span></span><br></pre></td></tr></table></figure></p><p>有時候讓實體也使用靜態方法會很方便，只要在原型新增就可以了，並以此方法作為外觀，指向原本的靜態方法。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line">Gadget.pototype.isShiny = Gadget.isShiny;</span><br><span class="line">iphone.isShiny(); <span class="hljs-comment">// "u bet"</span></span><br></pre></td></tr></table></figure></p><p><strong>小心！呼叫 <code>Gadget.isShiny()</code> 會將 this 指向建構式；呼叫 <code>iphone.isShiny();</code> 而 this 將指向 iphone。</strong></p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">//建構式</span></span><br><span class="line"><span class="hljs-keyword">var</span> Gadget = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">price</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.price = price;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">//一個靜態方法</span></span><br><span class="line">Gadget.isShiny = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">//這裡永遠都會運作</span></span><br><span class="line">  <span class="hljs-keyword">var</span> msg = <span class="hljs-string">'u bet'</span>;</span><br><span class="line">  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Gadget) &#123;</span><br><span class="line">    msg += <span class="hljs-string">', it costs $'</span> + <span class="hljs-keyword">this</span>.price + <span class="hljs-string">'!'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> msg;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//將一個一般的方法加到原型</span></span><br><span class="line">Gadget.prototype.isShiny = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> Gadget.isShiny.call(<span class="hljs-keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">//測試呼叫靜態方法</span></span><br><span class="line">Gadget.isShiny(); <span class="hljs-comment">// "u bet"</span></span><br><span class="line"><span class="hljs-comment">//測試一個實體，並非用靜態的方式呼叫</span></span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> Gadget(<span class="hljs-string">'499.99'</span>);</span><br><span class="line">a.isShiny(); <span class="hljs-comment">// "u bet , it costs $499.99!"</span></span><br></pre></td></tr></table></figure></p><h3 id="Private-靜態成員"><a href="#Private-靜態成員" class="headerlink" title="Private 靜態成員"></a>Private 靜態成員</h3><ul><li>由同個建構式建立的物件之間都可分享的成員</li><li>建構式之外不可存取的成員</li></ul><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> Gadget = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log((counter += <span class="hljs-number">1</span>));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(); <span class="hljs-comment">// 立即執行</span></span><br></pre></td></tr></table></figure></p><p>這個範例有一個靜態屬性名稱 <code>counter</code> ，參考前面討論過的 private 屬性，現在也是需要建立一個閉包來裝 private 成員，讓函式執行並回傳一個函式。將回傳的函式指派給變數 Gadget。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> g1 = <span class="hljs-keyword">new</span> Gadget(); <span class="hljs-comment">//logs 1</span></span><br><span class="line"><span class="hljs-keyword">var</span> g2 = <span class="hljs-keyword">new</span> Gadget(); <span class="hljs-comment">//logs 2</span></span><br><span class="line"><span class="hljs-keyword">var</span> g3 = <span class="hljs-keyword">new</span> Gadget(); <span class="hljs-comment">//logs 3</span></span><br></pre></td></tr></table></figure></p><p>因為每個物件都讓 counter 值增加，這種靜態屬性就成為一個 ID ，這種唯一識別符非常有用。</p><p>接下來承上範例，來試看看特權方法</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">//建構式</span></span><br><span class="line"><span class="hljs-keyword">var</span> Gadget = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">//靜態變數/屬性</span></span><br><span class="line">  <span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>;</span><br><span class="line">  NewGadget;</span><br><span class="line">  <span class="hljs-comment">//新的實作</span></span><br><span class="line">  NewGadget = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    counter += <span class="hljs-number">1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="hljs-comment">//特權方法</span></span><br><span class="line">  NewGadget.prototype.getLastId = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> counter;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="hljs-comment">//覆蓋原本的建構式</span></span><br><span class="line">  <span class="hljs-keyword">return</span> NewGadget;</span><br><span class="line">&#125;)(); <span class="hljs-comment">// 立即執行</span></span><br></pre></td></tr></table></figure></p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> iphone = <span class="hljs-keyword">new</span> Gadget();</span><br><span class="line">iphone.getLastId(); <span class="hljs-comment">// 1</span></span><br><span class="line"><span class="hljs-keyword">var</span> ipod = <span class="hljs-keyword">new</span> Gadget();</span><br><span class="line">ipod.getLastId(); <span class="hljs-comment">// 2</span></span><br><span class="line"><span class="hljs-keyword">var</span> ipad = <span class="hljs-keyword">new</span> Gadget();</span><br><span class="line">ipad.getLastId(); <span class="hljs-comment">//3</span></span><br></pre></td></tr></table></figure></p><p>無論 public 還是 private ，他們可以包含非特定於實體的方法和資料，且不會隨著新的實體又重新建立，這種靜態屬性實作有點類似之後會講的單體建構式。</p><h2 id="物件常數"><a href="#物件常數" class="headerlink" title="物件常數"></a>物件常數</h2><p>JavaScript 沒有常數，一種常見的變通方法就是使用命名慣例將變數全部大寫。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">Math</span>.PI;</span><br><span class="line"><span class="hljs-built_in">Math</span>.SQRT2;</span><br><span class="line"><span class="hljs-built_in">Number</span>.MAX_VALUE;</span><br></pre></td></tr></table></figure></p><p>你也可以為你的常數使用相同命名慣例，並讓他們變成建構式靜態屬性。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> Widget = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">//實作</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget.MAX_HEIGHT = <span class="hljs-number">320</span>;</span><br><span class="line">Widget.MAX_WIDTH = <span class="hljs-number">480</span>;</span><br></pre></td></tr></table></figure></p><p>假設真的需要一個不可變動的值，可以建立 private 屬性，並提供一個 getter 方法且不要有 setter。</p><p>一個泛用的 constant 物件實作，提供這些方法：</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">set</span>(name, value);</span><br><span class="line">//用來定義一個新的常數</span><br><span class="line">isDefined(name);</span><br><span class="line">//檢查常數是否存在</span><br><span class="line"><span class="hljs-keyword">get</span>(name);</span><br><span class="line">//取得常數值</span><br></pre></td></tr></table></figure></p><p>下面這份實作允許原始型別為常數值，且採用額外的保護措施（hasOwnProperty），以確保是用內建屬性的名稱來宣告屬性，並每個常數名稱再額外隨機產生一個前綴詞。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> constant = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> constants = &#123;&#125;,</span><br><span class="line">    ownProp = <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty,</span><br><span class="line">    allowed = &#123;</span><br><span class="line">      string: <span class="hljs-number">1</span>,</span><br><span class="line">      number: <span class="hljs-number">1</span>,</span><br><span class="line">      boolean: <span class="hljs-number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    prefix = (<span class="hljs-built_in">Math</span>.random() + <span class="hljs-string">'_'</span>).slice(<span class="hljs-number">2</span>);</span><br><span class="line">  <span class="hljs-keyword">return</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">set</span>: function(name, value) &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isDefined(name)) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="hljs-keyword">if</span> (!ownProp.call(allowed, <span class="hljs-keyword">typeof</span> value)) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      constants[prefix + name] = value;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    isDefined: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>&#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> ownProp.call(constants, prefix + name);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="hljs-keyword">get</span>: function(name) &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isDefined(name)) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> constants[prefix + name];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>實作範例：</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">//檢查是否定義過</span></span><br><span class="line">constant.isDefined(<span class="hljs-string">'maxwidth'</span>); <span class="hljs-comment">//false</span></span><br><span class="line"><span class="hljs-comment">//定義常數</span></span><br><span class="line">constant.set(<span class="hljs-string">'maxwidth'</span>, <span class="hljs-number">480</span>); <span class="hljs-comment">//true</span></span><br><span class="line"><span class="hljs-comment">//再檢查一次</span></span><br><span class="line">constant.isDefined(<span class="hljs-string">'maxwidth'</span>); <span class="hljs-comment">//true</span></span><br><span class="line"><span class="hljs-comment">//嘗試重新定義</span></span><br><span class="line">constant.set(<span class="hljs-string">'maxwidth'</span>, <span class="hljs-number">320</span>); <span class="hljs-comment">//false</span></span><br><span class="line"><span class="hljs-comment">//確認常數值</span></span><br><span class="line">constant.get(<span class="hljs-string">'maxwidth'</span>); <span class="hljs-comment">//480</span></span><br></pre></td></tr></table></figure></p><h2 id="鏈接模式"><a href="#鏈接模式" class="headerlink" title="鏈接模式"></a>鏈接模式</h2><p>鏈接模式允許你讓物件一個接著一個呼叫多個方法，既不需要將前一次操作賦值給變數，也不需要將你的呼叫拆成多行。</p><p>當建立的方法不具有意義的回傳值時，你可以讓他們回傳 this ，也就是方法所運作的實體物件，這樣就能讓物件的使用者直接呼叫下一個方法：</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> obj = &#123;</span><br><span class="line">  value: <span class="hljs-number">1</span>,</span><br><span class="line">  increment: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.value += <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  add: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.value += v;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  shout: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="hljs-keyword">this</span>.value);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">//鏈接呼叫</span></span><br><span class="line">obj</span><br><span class="line">  .increment()</span><br><span class="line">  .add(<span class="hljs-number">3</span>)</span><br><span class="line">  .shout(); <span class="hljs-comment">//5</span></span><br><span class="line"><span class="hljs-comment">//逐一呼叫</span></span><br><span class="line">obj.increment();</span><br><span class="line">obj.add(<span class="hljs-number">3</span>);</span><br><span class="line">obj.shout(); <span class="hljs-comment">//5</span></span><br></pre></td></tr></table></figure></p><h3 id="鏈接模式的優點與缺點"><a href="#鏈接模式的優點與缺點" class="headerlink" title="鏈接模式的優點與缺點"></a>鏈接模式的優點與缺點</h3><p>優點：</p><ul><li>少打字</li><li>幫助思考，看能不能建立更小更專門的函式，可提升維護性</li></ul><p>缺點：</p><ul><li>debug 困難（又稱為火車事故）</li></ul><h2 id="method-方法（sugar-method）"><a href="#method-方法（sugar-method）" class="headerlink" title="method() 方法（sugar method）"></a>method() 方法（sugar method）</h2><p>對於習慣 method() 思考，JS 可能會讓他們困惑，這就是為什麼有些程式員會把 JS 寫得 class-like，提出 method() 的作者（Douglas Crockford）承認這個方法並不是推薦的方式，但可能會在未來某些應用程式中碰到。</p><p>使用建構式就像在 Java 中使用 class ，也讓你可以在建構式本體中，新增實體的屬性到 this，但在 this 上新增方法非常沒效率，會造成每個實體都重新建立，這就是為什麼可重用的方法需要新增在 prototype 上。</p><p>定義一個 class 的方法類似這樣：</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> Person = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">  .method(<span class="hljs-string">'getName'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;</span><br><span class="line">  &#125;)</span><br><span class="line">  .method(<span class="hljs-string">'setName'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p><p><strong>注意建構式是如何鏈接 <code>method</code> 的呼叫，這用到鏈接模式，幫助你單一敘述定義整個 class。</strong></p><p>這個 method 接受兩個參數：</p><ul><li>新方法的名稱</li><li>新方法的實作</li></ul><p>這些鏈接的新方法就會新增到 Person 的 class 裡面，而方法的實作也就是一個函式，內部的 this 會指向 Person 所建立的物件。</p><p>用 Person() 建立新物件：</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'Adam'</span>);</span><br><span class="line">a.getName(); <span class="hljs-comment">//'Adam'</span></span><br><span class="line">a.setName(<span class="hljs-string">'Eve'</span>).getName(); <span class="hljs-comment">// 'Eve'</span></span><br></pre></td></tr></table></figure></p><p>注意範例的 setName，可以這樣是因為 setName 回傳 this。</p><p>最後這是 method 模式實作的方法：</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Function</span>.prototype.method !== <span class="hljs-string">'function'</span>) &#123;</span><br><span class="line">  <span class="hljs-comment">//先檢查是否已經建立過了</span></span><br><span class="line">  <span class="hljs-built_in">Function</span>.prototype.method = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, implementation</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.prototype[name] = implementation;</span><br><span class="line">    <span class="hljs-comment">//將 implementation 傳遞的函式加到建構式的原型中，this 會指向建構式</span></span><br><span class="line">    <span class="hljs-comment">//原型就會被擴充</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 讀書筆記 </tag>
            
            <tag> JSDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【讀書筆記】JavaScript Design Pattern Chapter05 物件建立模式（上）</title>
      <link href="/javascript-design-pattern-object01/"/>
      <url>/javascript-design-pattern-object01/</url>
      
        <content type="html"><![CDATA[<p>可以降低全域變數的需求量，幫忙避免命名衝突和過度的名稱前綴詞。JavaScript 沒有內建的命名空間，為了避免一堆函式、變數、物件污染全域空間，應該要建立一個全域物件。</p><a id="more"></a><h2 id="命名空間"><a href="#命名空間" class="headerlink" title="命名空間"></a>命名空間</h2><p>可以降低全域變數的需求量，幫忙避免命名衝突和過度的名稱前綴詞。JavaScript 沒有內建的命名空間，為了避免一堆函式、變數、物件污染全域空間，應該要建立一個全域物件。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> MYAPP = &#123;&#125;;</span><br><span class="line"><span class="hljs-comment">//全域物件</span></span><br><span class="line">MYAPP.Parent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="hljs-comment">//建構式</span></span><br><span class="line">MY.somevar = =<span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-comment">//變數</span></span><br><span class="line">MYAPP.modules.modules1 = &#123;&#125;;</span><br><span class="line">MYAPP.modules.modules1.data = &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>&#125;;</span><br><span class="line"><span class="hljs-comment">//巢狀物件</span></span><br></pre></td></tr></table></figure></p><p>應該用全大寫表示全域變數，讓他特別明顯（另外注意常數也是全大寫）。</p><p>缺點：</p><ul><li>越長的巢狀名稱表示更長</li><li>唯一的全域實體代表任何程式碼都可以變更這個實體，而接下來的功能也都會使用變更後的狀態。</li><li>要多打一點字，它相當於在每個變數和函數之前加上前綴詞。</li></ul><h4 id="泛用的命名空間函式"><a href="#泛用的命名空間函式" class="headerlink" title="泛用的命名空間函式"></a>泛用的命名空間函式</h4><p>有些你正要加入命名空間的屬性也許早已存在了，於是會不小心覆蓋它，因此最好建立命名空間和新增屬性前，先檢查是否存在。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> MYAPP === <span class="hljs-string">'undefined'</span>) &#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> MYAPP = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 檢查全域</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> MYAPP = MYAPP || &#123;&#125;;</span><br><span class="line"><span class="hljs-comment">//簡短寫法</span></span><br></pre></td></tr></table></figure></p><p>但如果遇到巢狀物件，必須對每個物件或屬性檢查，此時需要一個函數幫忙做檢查細節。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line">MYAPP.namespace(<span class="hljs-string">'MYAPP.module.module2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//效果等同於：</span></span><br><span class="line"><span class="hljs-comment">//var MYAPP = &#123;</span></span><br><span class="line"><span class="hljs-comment">//module: &#123;</span></span><br><span class="line"><span class="hljs-comment">//module2: &#123;&#125;</span></span><br><span class="line"><span class="hljs-comment">//&#125;</span></span><br><span class="line"><span class="hljs-comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> MYAPP = MYAPP || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">MYAPP.namespace = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ns_str</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> parts = ns_str.split(<span class="hljs-string">'.'</span>),</span><br><span class="line">    parent = MYAPP,</span><br><span class="line">    i;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">//去除最前投多餘的全域名稱</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (parts[<span class="hljs-number">0</span>] === <span class="hljs-string">'MYAPP'</span>) &#123;</span><br><span class="line">    parts = parts.slice(<span class="hljs-number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; parts.length; i += <span class="hljs-number">1</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> parent[parts[i]] === <span class="hljs-string">'undefined'</span>) &#123;</span><br><span class="line">      parent[parts[i]] = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    parent = parent[parts[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>允許下列做法：</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> m2 = MYAPP.namespace(<span class="hljs-string">'MYAPP.module.module2'</span>);</span><br><span class="line">m2 === MYAPP.module.module2; <span class="hljs-comment">//true</span></span><br><span class="line"><span class="hljs-comment">//將回傳值指派給區域變數</span></span><br><span class="line">MYAPP.namespace(<span class="hljs-string">'module.module2'</span>);</span><br><span class="line"><span class="hljs-comment">//忽略開頭的MYAPP</span></span><br><span class="line">MYAPP.namespace(<span class="hljs-string">'MYAPP.once.upon.the.time'</span>);</span><br><span class="line"><span class="hljs-comment">//很長的命名空間</span></span><br></pre></td></tr></table></figure></p><h2 id="宣告相依性"><a href="#宣告相依性" class="headerlink" title="宣告相依性"></a>宣告相依性</h2><p>JavaScript 通常會使用命名空間，並讓良好的模組化，讓你可以只引用你需要的模組。</p><p>將與你程式碼相依的模組，宣告在函式或是模組頂端，這樣意味者建立唯一一個區域變數，並指向所需的模組。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> myFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> event = YAHOO.util.Event,</span><br><span class="line">    dom = YAHOO.util.Dom;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">//使用event, dom</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>好處：</p><ul><li>宣告相依性，揭示你程式碼的使用者可以了解他們需要哪些相依模組需要引用</li><li>宣告在函式頂端，較容易找到並解決相依性</li><li>使用區域變數比找全域變數快，更比起全域變數的巢狀屬性快。採用相依性模式，只需要在函式使用全域變數一次就好。</li><li>有些最小化工具會重新命名區域變數，但不會去更改全域變數，因為不安全。</li></ul><p>比較：</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">//未使用</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">oldFn</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  alert(MYAPP.modules.m1);</span><br><span class="line">  alert(MYAPP.modules.m2);</span><br><span class="line">  alert(MYAPP.modules.m3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//最小化</span></span><br><span class="line">alert(MYAPP.modules.m1);</span><br><span class="line">alert(MYAPP.modules.m2);</span><br><span class="line">alert(MYAPP.modules.m3);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//使用</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newFn</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> modules = MYAPP.modules;</span><br><span class="line">  alert(m1);</span><br><span class="line">  alert(m2);</span><br><span class="line">  alert(m3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//最小化</span></span><br><span class="line"><span class="hljs-keyword">var</span> a = MYAPP.modules;</span><br><span class="line">alert(a.m1);</span><br><span class="line">alert(a.m2);</span><br><span class="line">alert(a.m3);</span><br></pre></td></tr></table></figure></p><h2 id="Private-屬性與方法"><a href="#Private-屬性與方法" class="headerlink" title="Private 屬性與方法"></a>Private 屬性與方法</h2><p>JavaScript 所有的物件成員都是 Public。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> myobj = &#123;</span><br><span class="line">  myprop: <span class="hljs-number">1</span>,</span><br><span class="line">  getProp: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.myprop;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(myobj.myprop); <span class="hljs-comment">// myprop 可被 public 存取</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(myobj.getProp()); <span class="hljs-comment">// getProp() 也是 public</span></span><br></pre></td></tr></table></figure></p><h4 id="Private-成員"><a href="#Private-成員" class="headerlink" title="Private 成員"></a>Private 成員</h4><p>雖然語言本身沒有提供特殊語法，但可以用閉包來實作，任何屬於閉包作用域的變數都不會暴露在建構式之外，以下舉例：</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Gadget</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">//private 成員</span></span><br><span class="line">  <span class="hljs-keyword">var</span> name = <span class="hljs-string">'iPod'</span>;</span><br><span class="line">  <span class="hljs-comment">//public 方法</span></span><br><span class="line">  <span class="hljs-keyword">this</span>.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> name;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> toy = <span class="hljs-keyword">new</span> Gadget();</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(tou.name); <span class="hljs-comment">//undefined</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(toy.getName()); <span class="hljs-comment">//"iPod"</span></span><br></pre></td></tr></table></figure></p><p>在 JavaScript 表現隱私權很容易，將想要保持 Private 的資料用函式包起來，且確保他是函式的區域變數，為了是不要讓他在函式外被存取。</p><h4 id="特權方法"><a href="#特權方法" class="headerlink" title="特權方法"></a>特權方法</h4><p>存取 private 成員的 public 方法的一個名字。</p><p>上一個 <code>getName()</code> 就是一個特權函式，因為他對 name 屬性有特別的存取權。</p><h4 id="隱私權錯誤"><a href="#隱私權錯誤" class="headerlink" title="隱私權錯誤"></a>隱私權錯誤</h4><p>當你直接從特權函式回傳一個 private 變數，且這個變數是個物件或陣列時，外圍的程式碼仍可以更改 private 變數，因為傳遞的是變數的參考。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Gadget</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> specs = &#123;</span><br><span class="line">    screen_width: <span class="hljs-number">320</span>,</span><br><span class="line">    screen_height: <span class="hljs-number">480</span>,</span><br><span class="line">    color: <span class="hljs-string">'white'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">this</span>.getSpecs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> specs;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> toy = <span class="hljs-keyword">new</span> Gadget(),</span><br><span class="line">  specs = toy.getSpecs();</span><br><span class="line">specs.color = <span class="hljs-string">'black'</span>;</span><br><span class="line">specs.price = <span class="hljs-string">'free'</span>;</span><br><span class="line"><span class="hljs-built_in">console</span>.dir(toy.getSpecs());</span><br></pre></td></tr></table></figure></p><ul><li><p>小心！不要回傳想要保持 private 的物件或陣列參考。</p></li><li><p>讓 <code>getSpecs()</code> 回傳一個新的物件，物件中僅需要使用者所需要的資料(最低授權原則)。</p></li><li><p>建立一個 specs 物件的複本，你可以使用常用的的複製物件函式。</p></li></ul><p>之後會提到 <code>extend</code> ，它會對物件做一個淺層複製（只複製最上一層的參數），另一個為 <code>extendDeep</code> 他會以遞迴的方式複製所有的屬性和他們所擁有的巢狀屬性。</p><p>最低授權原則：以這個範例來說，假設 Gadget 的使用者對於此元件的大小是否符合感興趣，那僅需要的只有大小而已。因此你給全部，不如新的函式，讓函式回傳包含寬和高的物件，甚至你可能都不需要 getSpecs 方法。</p><h4 id="物件實字與隱私權"><a href="#物件實字與隱私權" class="headerlink" title="物件實字與隱私權"></a>物件實字與隱私權</h4><p>前面的範例都是使用建構式，那如果使用物件實字仍可能使用 private 成員嗎？</p><p>你所需要只是要將 private 成員用函式包起來，如果是物件實字可以使用立即函式來建立閉包。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> myobj;</span><br><span class="line">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> name = <span class="hljs-string">'oh, mygod'</span>;</span><br><span class="line"></span><br><span class="line">  myobj = &#123;</span><br><span class="line">    getName: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> name;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">myobj.getName(); <span class="hljs-comment">// "oh, mygod"</span></span><br></pre></td></tr></table></figure></p><p>用另一個相同概念的方法寫：</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> myobj = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> name = <span class="hljs-string">'oh, mygod'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> &#123;</span><br><span class="line">    getName: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> name;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">myobj.getName(); <span class="hljs-comment">// "oh, mygod"</span></span><br></pre></td></tr></table></figure></p><h4 id="Prototypes-與隱私權"><a href="#Prototypes-與隱私權" class="headerlink" title="Prototypes 與隱私權"></a>Prototypes 與隱私權</h4><p>使用建構式所產生的 private 成員，他們在每次建構式呼叫產生新物件時都重新建立，這是建構式每個 this 成員都有的缺點。</p><p>解法：將共同屬性和方法加到 prototype 屬性中，如此所有相同建構式的實例都會共享，實體之間也能共享隱藏的 private 成員。</p><p>可以用建構式中的 private 屬性和物件實字的 private 屬性來組合，因為 prototype 也是物件，所以可以用物件實字來建立。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Gadget</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> name = <span class="hljs-string">'iPod'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">this</span>.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> name;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Gadget.prototype = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> browser = <span class="hljs-string">'mobile webkit'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> &#123;</span><br><span class="line">    getBrowser: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> toy = <span class="hljs-keyword">new</span> Gadget();</span><br><span class="line"><span class="hljs-built_in">console</span>.log(toy.getName());</span><br><span class="line"><span class="hljs-built_in">console</span>.log(toy.getBrowser());</span><br></pre></td></tr></table></figure></p><h4 id="將-Private-函式揭露成-Public"><a href="#將-Private-函式揭露成-Public" class="headerlink" title="將 Private 函式揭露成 Public"></a>將 Private 函式揭露成 Public</h4><p>揭露模式：將 private 方法揭露為 public 方法的模式。</p><p>假設物件中的所有功能都對物件來說很關鍵，於是你可能想盡可能保護此物件，但同時希望 public 方法來存取他的一些功能，就很適合用揭露模式。</p><p>當揭露方法是 public ，物件會變得很脆弱，時時暴露在可能不小心被修改的風險之下。</p><p>先來第一種範例，建立在其中一種私有權模式上物件實字的 private 成員模式：</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> myarr;</span><br><span class="line"></span><br><span class="line">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> astr = <span class="hljs-string">'[object Array]'</span>,</span><br><span class="line">    toString = <span class="hljs-built_in">Object</span>.prototype.toString;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isArray</span>(<span class="hljs-params">a</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> toString.call(a) === astr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">indexOf</span>(<span class="hljs-params">haystack, needle</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,</span><br><span class="line">      max = haystack.length;</span><br><span class="line">    <span class="hljs-keyword">for</span> (; i &lt; max; i += <span class="hljs-number">1</span>) &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span> (haystack[i] === needle) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  myarr = &#123;</span><br><span class="line">    isArray: isArray,</span><br><span class="line">    indexOf: indexOf,</span><br><span class="line">    inArray: indexOf,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p>astr 和 toString 為 private 變數，isArray 和 indexOf 為 private 函式，結尾出現 myarr 物件，裡面包含允許揭露的 public 功能。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line">myarr.isArray([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]); <span class="hljs-comment">// true</span></span><br><span class="line">myarr.isArray(&#123;</span><br><span class="line">  <span class="hljs-number">0</span>: <span class="hljs-number">1</span>,</span><br><span class="line">&#125;); <span class="hljs-comment">// false</span></span><br><span class="line">myarr.indexOf([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'z'</span>], <span class="hljs-string">'z'</span>); <span class="hljs-comment">// 2</span></span><br><span class="line">myarr.inArray([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'z'</span>], <span class="hljs-string">'z'</span>); <span class="hljs-comment">// 2</span></span><br></pre></td></tr></table></figure></p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line">myarr.indexOf = <span class="hljs-literal">null</span>;</span><br><span class="line">myarr.inArray([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'z'</span>], <span class="hljs-string">'z'</span>); <span class="hljs-comment">// 2</span></span><br></pre></td></tr></table></figure></p><p>現在如果發生預料之外的事在 public 的 indexOf 上，但 private 的 indexOf 函式仍然是安全的，所以 inArray() 仍然可以運作。</p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 讀書筆記 </tag>
            
            <tag> JSDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【讀書筆記】JavaScript Design Pattern Chapter04 函式（下）</title>
      <link href="/javascript-design-pattern-function02/"/>
      <url>/javascript-design-pattern-function02/</url>
      
        <content type="html"><![CDATA[<p>另一種類似立即函式且避免全域污染的方式，此模式建立一個物件，並帶有 <code>init</code> 方法，建立物件後立即執行 <code>init</code> 做初始化。</p><a id="more"></a><h2 id="立即物件初始化"><a href="#立即物件初始化" class="headerlink" title="立即物件初始化"></a>立即物件初始化</h2><p>另一種類似立即函式且避免全域污染的方式，此模式建立一個物件，並帶有 <code>init</code> 方法，建立物件後立即執行 <code>init</code> 做初始化。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line">(&#123;</span><br><span class="line">maxwidth: <span class="hljs-number">500</span>,</span><br><span class="line">maxheight: <span class="hljs-number">30</span>,</span><br><span class="line">gimmeMax:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.maxwidth + <span class="hljs-string">"x"</span> + <span class="hljs-keyword">this</span>.maxheight</span><br><span class="line">&#125;,</span><br><span class="line">init:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.gimmeMax();)</span><br><span class="line">&#125;</span><br><span class="line">&#125;).init();</span><br></pre></td></tr></table></figure></p><p>用括號包起物件實字，關閉括號之後立即呼叫 <code>init</code> ，意思就是下方兩種寫法都成立。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line">(&#123;...&#125;).init();</span><br><span class="line">(&#123;...&#125;.init());</span><br></pre></td></tr></table></figure></p><p>優點：</p><ul><li>與立即函式相同，執行一次性初始化工作，也不會汙染全域物件</li><li>適合一次性工作</li></ul><h2 id="初始階段的分支"><a href="#初始階段的分支" class="headerlink" title="初始階段的分支"></a>初始階段的分支</h2><p>將功能分開測試，並使用初始化分支做唯一一次檢查。</p><h2 id="函式屬性——記憶模式"><a href="#函式屬性——記憶模式" class="headerlink" title="函式屬性——記憶模式"></a>函式屬性——記憶模式</h2><p>任何函式都具有<code>length</code>屬性，用來表示預期接收的參數數量。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params">a, b</span>)</span>&#123; ... &#125;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(func.length); <span class="hljs-comment">//2</span></span><br></pre></td></tr></table></figure></p><p>可以隨時將你的函式新增屬性，一種自訂屬性的案例是用它來快取函式的運算結果（回傳值），快取函式的結果也被稱為記憶模式。</p><p>假設限定函式只接受原始型別的參數，如果有更複雜的參數，可以將參數序列化，化為一個 JSON 字串，並用此字串作為 catch 物件的鍵值。</p><p>序列化後，物件的識別會消失，如果有兩個不同物件但剛好有相同屬性，這兩個物件會共用同一個快取項目。</p><h2 id="設定值物件"><a href="#設定值物件" class="headerlink" title="設定值物件"></a>設定值物件</h2><p>設定值模式是提供乾淨 API 的一種方式，在建立函式庫或是給其他開發者使用的程式，此模式會特別有效。</p><p>在編寫函式時需要傳遞大量參數，有一種更好的方法，就是將所有參數替換成唯一一個，讓此參數變成一個物件來表示設定值。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> conf = &#123;</span><br><span class="line">  username: <span class="hljs-string">'batman'</span>,</span><br><span class="line">  first: <span class="hljs-string">'Bruce'</span>,</span><br><span class="line">  last: <span class="hljs-string">'Wayne'</span>,</span><br><span class="line">&#125;;</span><br><span class="line">addPerson(conf);</span><br></pre></td></tr></table></figure></p><p>設定設定值的優點：</p><ul><li>不需要記住參數和順序</li><li>可以更安全略過選用參數</li><li>更容易閱讀和維護</li><li>更容易新增和移除參數</li></ul><p>缺點：</p><ul><li>需要知道參數名稱</li><li>設定值物件的屬性名稱無法被最小化</li></ul><h2 id="Curry"><a href="#Curry" class="headerlink" title="Curry"></a>Curry</h2><h3 id="函式的應用"><a href="#函式的應用" class="headerlink" title="函式的應用"></a>函式的應用</h3><p>在純函式的程式語言中，函式並不是被呼叫而是被應用，因為 JavaScript 的函式其實是物件而且有自己的方法。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 定義函式</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">who</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello'</span> + (who ? <span class="hljs-string">','</span> + who : <span class="hljs-string">''</span>) + <span class="hljs-string">'!'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 呼叫函式</span></span><br><span class="line"></span><br><span class="line">sayHi(); <span class="hljs-comment">// "Hello"</span></span><br><span class="line">sayHi(<span class="hljs-string">'world'</span>); <span class="hljs-comment">// 'Hello, world'</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 應用函式</span></span><br><span class="line">sayHi.apply(<span class="hljs-literal">null</span>, [<span class="hljs-string">'hello'</span>]); <span class="hljs-comment">//Hello, hello</span></span><br></pre></td></tr></table></figure></p><p>呼叫函式和應用函式的結果都相同，<code>apply()</code> 需要兩個參數，第一個參數是物件，用來綁定函式內部的 this，第二個參數是參數陣列，會成為函式內可使用的類陣列 arguments 物件。如果第一個參數值是 null ，則 this 會指向全域物件，這正是當你呼叫一個非物件內方法的函式時會發生的事。</p><p>如果函式是某物件的方式，就不會像前面例子傳遞 null 參考，而物件會成為 apply 的第一個參數。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> alien = &#123;</span><br><span class="line">sayHi : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">who</span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-string">"Hello"</span> + (who ? <span class="hljs-string">","</span> + who : <span class="hljs-string">""</span>) + <span class="hljs-string">"!"</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHi.apply(alien, [<span class="hljs-string">"hello"</span>]);</span><br></pre></td></tr></table></figure></p><p><strong>除了 apply 之外，有另一個 call 方法，可省下建立陣列的工作。</strong></p><h3 id="部分應用"><a href="#部分應用" class="headerlink" title="部分應用"></a>部分應用</h3><p>程式碼的執行過程：</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 定義函式</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>)</span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 知道參數並呼叫</span></span><br><span class="line">add(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//程式執行：步驟一</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params"><span class="hljs-number">5</span>, y</span>)</span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">5</span> + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//程式執行：步驟二</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params"><span class="hljs-number">5</span>, <span class="hljs-number">4</span></span>)</span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">5</span> + <span class="hljs-number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此階段步驟一可稱為部分應用，意思是用第一個參數替換函式中的未知數，但我們並沒有得到結果（解答），而是得到另一個函式。</p><p>現在讓我們假想一個函式叫做 <code>partialApply()</code>。（以下為非正規用法）</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//全應用</span></span><br><span class="line">add(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//部分應用</span></span><br><span class="line"><span class="hljs-keyword">var</span> newadd = add.partialApply(<span class="hljs-literal">null</span>, [<span class="hljs-number">5</span>]);</span><br><span class="line">newadd.apply(<span class="hljs-literal">null</span>, [<span class="hljs-number">4</span>]); <span class="hljs-comment">//9</span></span><br></pre></td></tr></table></figure></p><p>部分運用給了另一個函式，該函式可以在之後用別的參數呼叫，等同於 <code>add(5, 4);</code> ，因為 <code>add(5)</code> 會回傳一個函式，於是可以用 <code>(4)</code> 呼叫，換句話說 <code>add(5, 4);</code> 只是 <code>add(5)(4)</code> 的語法糖。</p><p>這種單一輸入、單一輸出並讓函式可以理解，並處理部分應用的過程，稱為 curry 化。</p><h4 id="Curry-1"><a href="#Curry-1" class="headerlink" title="Curry"></a>Curry</h4><p>curry 是一種轉換的過程——我們在轉換函式。<br>（拆解函式）</p><p>泛用的 curry 化函式：</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> slice = <span class="hljs-built_in">Array</span>.prototype.slice,</span><br><span class="line">    stored_args = slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);</span><br><span class="line">  <span class="hljs-comment">// arguments : curry 的參數。因為傳進參數的第一個參數值是 function 必須刪除，</span></span><br><span class="line">  <span class="hljs-comment">// 但因為參數是類陣列，無法用陣列的方法，因此用 call 將 slice 指向 arguments，使arguments 為陣列，以使用陣列的方法，並刪除第一個參數。</span></span><br><span class="line">  <span class="hljs-comment">// 如同：arguments.slice(1);</span></span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> new_args = slice.call(<span class="hljs-built_in">arguments</span>),</span><br><span class="line">      <span class="hljs-comment">// 第二組傳入的參數，同上，將參數轉陣列</span></span><br><span class="line">      args = stored_args.concat(new_args);</span><br><span class="line">    <span class="hljs-comment">//將第一組和第二組傳入的參數合併</span></span><br><span class="line">    <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-literal">null</span>, args);</span><br><span class="line">    <span class="hljs-comment">//將合併的新參數傳入 fn</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>承上，新解釋範例如下：</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> newadd = curry(add, <span class="hljs-number">5</span>);</span><br><span class="line">newadd(<span class="hljs-number">4</span>); <span class="hljs-comment">//9</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//另一種寫法</span></span><br><span class="line">curry(add, <span class="hljs-number">6</span>)(<span class="hljs-number">7</span>); <span class="hljs-comment">//13</span></span><br></pre></td></tr></table></figure></p><p>第二個範例：</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b, c, d, e</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> a + b + c + d + e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//可以轉換任何數量的參數</span></span><br><span class="line">curry(add, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//兩步驟的 curry 也可以。</span></span><br><span class="line"><span class="hljs-keyword">var</span> addOne = curry(add, <span class="hljs-number">1</span>);</span><br><span class="line">addOne(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>); <span class="hljs-comment">//41</span></span><br></pre></td></tr></table></figure></p><h2 id="使用-Curry-的時機"><a href="#使用-Curry-的時機" class="headerlink" title="使用 Curry 的時機"></a>使用 Curry 的時機</h2><p>當呼叫某個函式，發現傳入的參數大多相同，這時可以用柯里化，可以運用部分應用的方式，傳入一些參數給函式，並動態產生新的函式，新函式幫你保留重複的那些參數，於是不用每次都傳遞，並用他們預先填入原始函式，預期接受完整的參數列。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">//不使用柯里化</span></span><br><span class="line">add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">'abby'</span>);</span><br><span class="line">add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">'leia'</span>);</span><br><span class="line">add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">'jammy'</span>);</span><br><span class="line">add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">'lisa'</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//使用柯里化</span></span><br><span class="line"><span class="hljs-keyword">var</span> curryFn = curry(add, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</span><br><span class="line">curryFn(<span class="hljs-string">'abby'</span>);</span><br><span class="line">curryFn(<span class="hljs-string">'leia'</span>);</span><br><span class="line">curryFn(<span class="hljs-string">'jammy'</span>);</span><br><span class="line">curryFn(<span class="hljs-string">'lisa'</span>);</span><br></pre></td></tr></table></figure></p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><ul><li>JavaScript 是第一級物件，他們可以和原始型別值）一樣作為參數傳遞，也可以擴充屬性和方法。</li><li>函式提供區域作用域，而大括號產生的區塊則沒有，區域變數的宣告會被提升到區域作用的頂端。</li></ul><p>建立函式的語法：</p><ul><li>具名函式表示式</li><li>函式表示式：和上一個相同，只是缺少名字，也稱為匿名函式</li><li>韓式宣告式：類似其他語言</li></ul><p>好用的函式模式：</p><ul><li>API 模式：使函式介面更簡潔 - 回呼模式：將函式作為參數傳遞 - 設定值物件：幫助你讓函式的參數數量 - 回傳函式：函式的回傳值是另一個函式 - curry 化：用現有的函式加上部分參數列產生新的函式</li><li>初始化模式：結構化的方式來執行初始和設定，不會因暫時變數污染全域 - 立即函式：定義後立即執行 - 立即物件初始化：結構化初始工作被包進一個匿名函式中，此模式提供一個立即呼叫的方法。 - 初始階段的分支：初始階段執行唯一一次分支，而不是在應用程式的生命週期中執行許多次。</li><li>效能模式： - 記憶模式：使函式屬性暫存，運算過的值不必重複運算 - 自我定義函式：函式使用新的定義覆蓋自己，在第二次呼叫過後省下工作</li></ul>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 讀書筆記 </tag>
            
            <tag> JSDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【讀書筆記】JavaScript Design Pattern Chapter04 函式（上）</title>
      <link href="/javascript-design-pattern-function01/"/>
      <url>/javascript-design-pattern-function01/</url>
      
        <content type="html"><![CDATA[<p>接下來會學習到不同定義的函式，首先是函式表達式和函式宣告式，接著看函式作用域與 hosting 如何運作。</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>JavaScript 有兩個主要特色：</p><ul><li>函式屬於 JavaScript 第一級物件（first-class object）</li><li>函式提供作用域</li></ul><p>函式也是物件：</p><ul><li>可在執行期、程式執行的過程中動態建立</li><li>可以指定給變數，也可將參考複製給其他變數，可以被擴充，而且除了少數其他狀況外，也可以被刪除</li><li>可以作為參數傳遞給其他韓式，也可以作為其他函式的回傳值</li><li>可以有自己的屬性和方法</li></ul><p>使用 Function 建構式跟使用 eval 一樣糟糕，因為程式碼使用字串的形式傳遞並執行，就必須跳脫字元，如此讀寫都很不方便。</p><p>JavaScript 中沒有大括號內的區域作用域，沒有區塊範圍，區塊並不產生有效的作用域，JavaScript 只有函式作用域，任何在函式裡面宣告的 var 變數 都是區域變數。</p><h2 id="釐清術語的差別"><a href="#釐清術語的差別" class="headerlink" title="釐清術語的差別"></a>釐清術語的差別</h2><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>具名的函式表示式，又稱匿名函式，與函式宣告式的差別是函式物件的 name 屬性會是個空字串，具名的函式表示式和函式宣告式看起來類似，但表示式在結尾需要分號，而表達式不用。</p><p>函式實字也是常用的術語，但他可能代表函式表示式也可能代表具名韓式表示式，模凌兩可，最好不要用此術語。</p><h2 id="宣告式-v-s-表示式：命名與-Hoisiting"><a href="#宣告式-v-s-表示式：命名與-Hoisiting" class="headerlink" title="宣告式 v.s. 表示式：命名與 Hoisiting"></a>宣告式 v.s. 表示式：命名與 Hoisiting</h2><p>那該使用函數宣告式還是表示式呢？當語法不能使用宣告式就可以使用表示式，例如：將函式物件作為參數傳遞、物件實字內定義方法。</p><p>函式宣告式只能出現在 program code 裡面，意思是函式本體或全域空間中，他們定義無法賦值給變數或其他屬性，或作其他函式的參數。</p><h2 id="函式的-name-屬性"><a href="#函式的-name-屬性" class="headerlink" title="函式的 name 屬性"></a>函式的 name 屬性</h2><p>對函式宣告式和具名函式表達式，name 屬性都有定義。對匿名函式表達式說，name 可能為 undefined 或空字串。<br>name 屬性也會用來遞迴呼叫自己，或是在除錯工具中顯示函式名稱，如果這兩種狀況都沒有需要，用不具名表達式會比較簡單也不囉唆。</p><p>技術上來說可以將一個具名函式表示式指派給另一個名稱的變數，但不是所有瀏覽器都支援，因此不建議這樣做。</p><h2 id="函式的-Hoisting"><a href="#函式的-Hoisting" class="headerlink" title="函式的 Hoisting"></a>函式的 Hoisting</h2><p>所有變數無論被定義在函式中哪處，都會在幕後被提升到函式最前端。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'global foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'global bar'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hoistMe</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> foo); <span class="hljs-comment">// 'function'</span></span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> bar); <span class="hljs-comment">//'undefined'</span></span><br><span class="line"></span><br><span class="line">  foo(); <span class="hljs-comment">// local foo</span></span><br><span class="line">  bar(); <span class="hljs-comment">// TypeError:bar is not function</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'local foo'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-comment">// 變數 foo 和實作都被提升</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">var</span> bar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'local bar'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="hljs-comment">// 僅有變數 bar 被提升，不包含實作，所以是 undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hoistMe();</span><br></pre></td></tr></table></figure></p><h2 id="回呼模式"><a href="#回呼模式" class="headerlink" title="回呼模式"></a>回呼模式</h2><p>函數是物件，意思就是可以作為參數傳遞給其他函式。</p><h2 id="回呼與作用域"><a href="#回呼與作用域" class="headerlink" title="回呼與作用域"></a>回呼與作用域</h2><p>回呼並非是一次性的匿名函式或者全域函式，而是某個物件的方法，如果回呼的方法使用了 this 去參考其所屬的物件，this 會參考到全域物件，解決方法是除了傳遞回呼函式，額外傳遞回呼函式所屬物件，並使用 call 改變 this 的指向。</p><h2 id="逾時"><a href="#逾時" class="headerlink" title="逾時"></a>逾時</h2><p>當使用 <code>setTimeout</code> 或 <code>setInterval</code> ，函數在作為變數傳遞時沒有加上括號，因為你不是想立刻執行它，而是指向它，讓 <code>setTimeout</code> 或 <code>setInterval</code> 稍後可以使用。</p><h2 id="回傳函式"><a href="#回傳函式" class="headerlink" title="回傳函式"></a>回傳函式</h2><p>有個函式做了一個工作，可能是一些初始化，接著就對其回傳值工作，回傳值剛好是另一個函式：</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> setup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="hljs-number">1</span>);</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="hljs-number">2</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> my = setup();</span><br><span class="line">my();</span><br></pre></td></tr></table></figure></p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> setup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> (count += <span class="hljs-number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> next = setup();</span><br><span class="line">next(); <span class="hljs-comment">//1</span></span><br><span class="line">next(); <span class="hljs-comment">//2</span></span><br><span class="line">next(); <span class="hljs-comment">//3</span></span><br><span class="line">next(); <span class="hljs-comment">//4</span></span><br></pre></td></tr></table></figure></p><h2 id="自我定義函式"><a href="#自我定義函式" class="headerlink" title="自我定義函式"></a>自我定義函式</h2><p>函式可以動態建立，且可以指派給變數。建立新函式，並指派給同一個變數，此變數原本指向的舊函數就會被覆蓋成新的。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> scareMe = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="hljs-string">'boo!'</span>);</span><br><span class="line">  scareMe = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="hljs-string">'double boo!'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">scareMe();</span><br><span class="line">scareMe();</span><br></pre></td></tr></table></figure></p><p>使用這種模式可以顯著提升效能，當函式一部份不需要的狀況下，就可以使用自我定義的函式更新自身的實作。這個模式另一個名字叫做懶惰的函式定義，因為這種函式在第一次使用之前都沒有正確定義，而之後就會變得懶惰。</p><p>此函數的缺點在它重新定義自身之前你加到原始函式的屬性都會遺失，如果使用不同名稱，例如新函式指派給另一個變數或是物件的另一個方法，那重新定義的部分就不會執行，而原始的函式本體就會執行。</p><p>以另一個例子來說，這次 <code>scareMe()</code> 函式要用第一級物件的使用方式：</p><ul><li>加入一個新的屬性</li><li>將函式物件指派給新變數</li><li>函式也作為方法使用</li></ul><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 1.加入一個新屬性</span></span><br><span class="line">scareMe.property = <span class="hljs-string">'properly'</span>;</span><br><span class="line"><span class="hljs-comment">// 2.賦值給一個不同名稱</span></span><br><span class="line"><span class="hljs-keyword">var</span> prank = scareMe;</span><br><span class="line"><span class="hljs-comment">// 3.作為一個方法來使用</span></span><br><span class="line"><span class="hljs-keyword">var</span> spooky = &#123;</span><br><span class="line">  boo: scareMe,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 用新的名稱呼叫</span></span><br><span class="line"></span><br><span class="line">prank(); <span class="hljs-comment">//boo</span></span><br><span class="line">prank(); <span class="hljs-comment">//boo</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(prank.property); <span class="hljs-comment">// properly</span></span><br><span class="line"><span class="hljs-comment">// 用方法呼叫</span></span><br><span class="line"></span><br><span class="line">spooky.boo(); <span class="hljs-comment">//boo</span></span><br><span class="line">spooky.boo(); <span class="hljs-comment">//boo</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(spooky.boo.property); <span class="hljs-comment">// properly</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 用自我定義函式呼叫</span></span><br><span class="line">scareMe(); <span class="hljs-comment">//double boo!</span></span><br><span class="line">scareMe(); <span class="hljs-comment">//double boo!</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(scareMe.property); <span class="hljs-comment">//undefined</span></span><br></pre></td></tr></table></figure></p><p>當自我定義函式被賦值給一個新變數時，他沒有照你預期，每一次呼叫 <code>prank();</code> 都會印出 <code>boo</code>，同時覆蓋全域的 <code>scareMe();</code> 函式，但 <code>prank();</code> 自己仍保有舊有的定義，包含 property 屬性。</p><p>這些每次的呼叫都會重新覆蓋 <code>scareMe();</code> 的指標，所以最終呼叫它，它擁有的是第一次就被更新的主體，會印出 <code>double boo!</code> ，同時也沒有 property 屬性。</p><h2 id="立即函式"><a href="#立即函式" class="headerlink" title="立即函式"></a>立即函式</h2><p>此模式本質上是一個函數表示式，並在定義後立刻執行。<br>立即函式由下面部分所組成：</p><ul><li>用函式表示式定義函式</li><li>在函式最後加上括號，這樣會讓函式立刻執行</li><li>整個函式包在括號中（如果不將函式賦予給一個值才需要）</li></ul><p>立即函式可以賦予程式碼作用域，有時候通常工作只要執行一次，沒有理由再去寫具名函式，有時候工作會需要暫時性變數，初始化後，變數會被洩露為全域變數，立即函式可以避免這個狀況。</p><h3 id="立即函式的參數"><a href="#立即函式的參數" class="headerlink" title="立即函式的參數"></a>立即函式的參數</h3><p>立即函式可以傳遞參數，但不應該傳太多，這樣容易造成理解時的負擔。</p><h3 id="立即函式的回傳值"><a href="#立即函式的回傳值" class="headerlink" title="立即函式的回傳值"></a>立即函式的回傳值</h3><p>立即函式可以有回傳值，而這些函式可以賦值給變數：</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> result = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p>或是省略包著函式的括號，因為將立即函式的回傳值賦值給變數時不需要括號。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> result = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> + <span class="hljs-number">2</span>; <span class="hljs-comment">//4</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p>但可能會誤導，因為沒注意函式後面的括號，可能會以為 result 指向的是函式，但其實 result 是立即函式的回傳值。</p><p>但除了原始型別外，立即函式可以回傳任何型別的值，包含回傳函式，如此就可以利用立即函式私有的作用域儲存 private 資料。</p><p>這個範例中，立即函式回傳是一個函式，他會賦值給變數 getResult ，作用是簡單回傳 res ，它已經預先算好，存在立即函式的 closure。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> getResult = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> res = <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p>立即函式也可以用來定義物件屬性，假設你需要一個屬性，但在定義之前需要一些運算才能得到正確的值，而立即函式的回傳值就成為該屬性的值。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> o = &#123;</span><br><span class="line">  msg: (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> who = <span class="hljs-string">'me'</span>;</span><br><span class="line">    what = <span class="hljs-string">'call'</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> what + <span class="hljs-string">' '</span> + who;</span><br><span class="line">  &#125;)(),</span><br><span class="line">  getMsg: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.msg;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">o.msg; <span class="hljs-comment">//call me</span></span><br><span class="line">o.getMsg; <span class="hljs-comment">//call me</span></span><br></pre></td></tr></table></figure></p><h3 id="優點及用法"><a href="#優點及用法" class="headerlink" title="優點及用法"></a>優點及用法</h3><ul><li>將運算包裝，不必留下全域變數</li><li>將程式模組化，包裝到立即函式中</li></ul>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 讀書筆記 </tag>
            
            <tag> JSDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【讀書筆記】JavaScript Design Pattern Chapter03 實字與建構式</title>
      <link href="/javascript-design-pattern-construction/"/>
      <url>/javascript-design-pattern-construction/</url>
      
        <content type="html"><![CDATA[<p>此章解釋為何實字標記會比內建建構式（<code>new Object()</code>、<code>new Array()</code>）還好，主要傳達就是訊息的延伸（避免用建構式並用實字替代）。</p><a id="more"></a><h2 id="物件實字"><a href="#物件實字" class="headerlink" title="物件實字"></a>物件實字</h2><ul><li>名值對的雜湊表，類似其他語言的關聯式陣列。</li><li>值可以是原始型別或另一個物件，稱之屬性；值可以是函式，稱為方法。</li><li>JavaScript 允許任何時刻改變、移除、增加屬性和方法。</li></ul><h2 id="物件實字語法"><a href="#物件實字語法" class="headerlink" title="物件實字語法"></a>物件實字語法</h2><ul><li>將物件用大括號（<code>{}</code>）包起來</li><li>以逗號分格每個屬性和函式</li><li>分號分隔屬性名稱和屬性值</li><li>將物件賦予給變數，記得右大括號後要加上分號</li></ul><h2 id="用建構式創造物件"><a href="#用建構式創造物件" class="headerlink" title="用建構式創造物件"></a>用建構式創造物件</h2><p>JavaScript 沒有 class，但有建構函式，它使用非常類似其他語言以 class 為基礎的物件建立語法。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> car = &#123; <span class="hljs-attr">goes</span>: <span class="hljs-string">'far'</span> &#125;;</span><br><span class="line"><span class="hljs-comment">// 實字</span></span><br><span class="line"><span class="hljs-keyword">var</span> car = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();</span><br><span class="line">car.goes = <span class="hljs-string">'far'</span>;</span><br><span class="line"><span class="hljs-comment">//建構式</span></span><br></pre></td></tr></table></figure></p><p>實字是更好的物件建立模式，程式碼比較短，且實字不需要作用域的判斷，意思就是你可能會創造其他相同名稱的區域建構式，而解譯器需要你從呼叫的 <code>Object()</code> 所在的作用域，一路向外查找整個作用域鍊，直到找到 <code>Object()</code> 建構式。</p><h2 id="自訂建構式"><a href="#自訂建構式" class="headerlink" title="自訂建構式"></a>自訂建構式</h2><p>以 <code>new</code> 來呼叫建構式，會經過以下流程：</p><ul><li>建立一個空物件，參考至 this 變數，並繼承此函式的原型</li><li>藉由 this 的參考，將屬性和方法加入到此物件</li><li>這個 this 所參考的物件，會隱晦地回傳出去</li></ul><p>如下</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> Person = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// 使用物件實字</span></span><br><span class="line">  <span class="hljs-comment">// 建立一個空物件</span></span><br><span class="line">  <span class="hljs-comment">// var this = &#123;&#125;;</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">  <span class="hljs-keyword">this</span>.say = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"I'm"</span> + <span class="hljs-keyword">this</span>.name;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">//return this;</span></span><br><span class="line">  <span class="hljs-comment">//隱晦回傳</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>將 <code>say()</code> 方法加入 this ，每次呼叫 <code>new Person()</code> 一次，一個新的函式就會建立在記憶體中，這樣是非常消耗效能的，較好的方法是加入到原型中：</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line">Person.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-string">'I am'</span> + <span class="hljs-keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>只要可重複利用的成員，例如方法，都應該放入原型。<br>上述的<code>建立空物件</code>，並不是真的空，比較像是：<code>var this = Object.create(Person.prototype);</code>。</p><h2 id="建構式的回傳值"><a href="#建構式的回傳值" class="headerlink" title="建構式的回傳值"></a>建構式的回傳值</h2><p>在建構函式中，沒有使用 <code>return</code> 的敘述，預設就是回傳 <code>this</code> 所參考的物件，另外你也可以自由回傳任何物件，只要是物件就好，如果回傳的不是物件就會被忽略，回傳就會是 <code>this</code> 所參考的物件。</p><h2 id="強制-new-模式"><a href="#強制-new-模式" class="headerlink" title="強制 new 模式"></a>強制 new 模式</h2><p>建構式只是用 <code>new</code> 呼叫，但本質還是函式，如果忘記加上 <code>new</code>，建構式中的 <code>this</code> 會指向全域物件，例如在瀏覽器中會指向 window ，這樣的行為如同替全域物件加上屬性，因此必須要使用 <code>new</code> 呼叫建構式。</p><h2 id="命名慣例"><a href="#命名慣例" class="headerlink" title="命名慣例"></a>命名慣例</h2><p>建構式的名字首部大寫，其他一般函式則首字小寫。</p><h2 id="使用-that"><a href="#使用-that" class="headerlink" title="使用 that"></a>使用 that</h2><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Wattle</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> that = &#123;&#125;;</span><br><span class="line">  that.tasts = <span class="hljs-string">'yummy'</span>;</span><br><span class="line">  <span class="hljs-keyword">return</span> that;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>等同於</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Wattle</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> &#123;</span><br><span class="line">that.tasts = <span class="hljs-string">'yummy'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 that 輸出結果與一般建構式結果無異，但如果使用 that 方法，會讓建構式失去原本繼承的 prototype 屬性，物件實體會和原型本身失去連結。</p><h2 id="自我呼叫的建構式"><a href="#自我呼叫的建構式" class="headerlink" title="自我呼叫的建構式"></a>自我呼叫的建構式</h2><p>為了解決前一個模式的問題，讓物件實體可以使用原型可以考慮以下方法：</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Waffle</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Waffle)) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Waffle();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">this</span>.tastes = <span class="hljs-string">'yummy'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Waffle.prototype.wantAnother = <span class="hljs-literal">true</span>;</span><br></pre></td></tr></table></figure></p><h2 id="令人好奇的陣列實字"><a href="#令人好奇的陣列實字" class="headerlink" title="令人好奇的陣列實字"></a>令人好奇的陣列實字</h2><p>當你傳入單一數值給 <code>new Array()</code> 該數值不會變成陣列的第一個元素，而是變成陣列的長度，如果傳入一個符點數，就會造成錯誤。</p><h2 id="檢查陣列"><a href="#檢查陣列" class="headerlink" title="檢查陣列"></a>檢查陣列</h2><p>陣列的型別是物件，但如果要檢查一個值是不是陣列，可以用程式檢查 <code>length</code> 屬性是否存在，更健全的方法是使用 <code>isArray</code> 方法，但如果環境不支援此方法，可對陣列呼叫 <code>toString</code> 的 <code>call</code> 方法，應會回傳<code>[Object Array]</code>。</p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON 和物件實字在語法上唯一不同是 JSON 屬性名稱須用引號包起來，對於物件實字，屬性名稱只有在不合法的狀況下才需要包，例如中間穿插空格。在 JSON 中不可以使用函式及正規表示式實字。</p><h2 id="正規表示式實字"><a href="#正規表示式實字" class="headerlink" title="正規表示式實字"></a>正規表示式實字</h2><p>JavaScript 的正規表示式也是一種物件，可以透過兩種方式建立：</p><ul><li>使用 new RegExp() 建構式</li><li>使用正規表示式實字</li></ul><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> re = <span class="hljs-regexp">/\\/gm</span>;</span><br><span class="line"><span class="hljs-comment">//實字</span></span><br><span class="line"><span class="hljs-keyword">var</span> re = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'\\\\'</span>, <span class="hljs-string">'gm'</span>);</span><br></pre></td></tr></table></figure></p><p>使用正規表示式實字符號需要跳脫字元，甚至經常需要兩個反斜線。</p><h2 id="正規表示式實字語法"><a href="#正規表示式實字語法" class="headerlink" title="正規表示式實字語法"></a>正規表示式實字語法</h2><p>正規實字符號使用斜線（”/“）來包住檢查對應的正規表示格式，第二個斜線後面可以加入格式的修飾詞，修飾詞的格式是不加引號的字母：</p><ul><li>g：全域檢查</li><li>m：檢查多行</li><li>i：不分大小寫</li></ul><p>使用實字和建構式之間的差異：</p><ul><li>遇到接受正規表示物件的函數（String.prototype.replace()），使用實字可以讓程式碼更簡潔</li><li>正規表示格式無法事先得知，而是要在執行階段才能知道，可使用建構式。</li><li>實字在語法解析時就已產生，而且只產生一個物件。如果在迴圈中使用同樣的正規表示式，前面建立的物件就會回傳，而且保留已設定過的所有屬性。</li><li>如果不使用 new 呼叫 RegExp() ，行為如同有使用 new。</li></ul><h2 id="原始型別包裹"><a href="#原始型別包裹" class="headerlink" title="原始型別包裹"></a>原始型別包裹</h2><p>JavaScript 有五種原始型別：數值、布林、字串、物件、null、undefined ，除了最後兩種，其餘型別皆有原始型別包裹物件。包裹物件可使用建構式來建立。</p><p>包裹物件（new Number()…）擁有一些屬性和方法可以使用，但原始數值在呼叫方法時，會在背後暫時轉型為一個物件，因此可以表現得像物件一樣使用那些屬性和方法。</p><p>使用包裹物件唯一理由是，你想要擴充並保持狀態，因為原始物件不是物件，他們無法擴充以新增屬性，但擴充字串、布林、數字，這些狀況很少用到，狀況如下：</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> greeting = <span class="hljs-string">'hello'</span>;</span><br><span class="line"><span class="hljs-comment">//原始字串</span></span><br><span class="line">greeting.split(<span class="hljs-string">' '</span>)[<span class="hljs-number">0</span>]; <span class="hljs-comment">//hello</span></span><br><span class="line"><span class="hljs-comment">//暫時轉型成物件，可使用方法</span></span><br><span class="line">greeting.smile = <span class="hljs-literal">true</span>;</span><br><span class="line"><span class="hljs-comment">//企圖擴充原始型別不會產生錯誤</span></span><br><span class="line"><span class="hljs-keyword">typeof</span> greeting.smile; <span class="hljs-comment">//undefined</span></span><br><span class="line"><span class="hljs-comment">//但其實沒有用</span></span><br></pre></td></tr></table></figure></p><h2 id="錯誤物件"><a href="#錯誤物件" class="headerlink" title="錯誤物件"></a>錯誤物件</h2><p>JavaScript 有數個內建的錯誤物件，隨著 thorow 敘述一起使用：Error()、SyntaxError()、TypeError() 等等，這些錯誤物件具有下列屬性：</p><ul><li>name：建立錯誤物件的建構式函式名稱</li><li>message：建立錯誤物件時傳遞給建構式的字串</li></ul><p>throw 可以跟任何物件一起運作，不一定是錯誤物件，可搭配 <code>catch</code> 敘述去處理資訊，錯誤物件的建構式如果沒有用 new 呼叫，結果會跟使用建構式呼叫一樣。</p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 讀書筆記 </tag>
            
            <tag> JSDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【讀書筆記】JavaScript Design Pattern Chapter02 精要</title>
      <link href="/javascript-design-pattern-chapter02/"/>
      <url>/javascript-design-pattern-chapter02/</url>
      
        <content type="html"><![CDATA[<h2 id="撰寫可維護的程式碼"><a href="#撰寫可維護的程式碼" class="headerlink" title="撰寫可維護的程式碼"></a>撰寫可維護的程式碼</h2><p>容易維護的程式碼必須具備下列條件：</p><ul><li>可讀性</li><li>一致性</li><li>可預料的</li><li>看起來像同個人寫的</li><li>文件化</li></ul><a id="more"></a><h2 id="減少全域變數"><a href="#減少全域變數" class="headerlink" title="減少全域變數"></a>減少全域變數</h2><p>JavaScript 使用函數來管理作用域。</p><ul><li>區域變數：在函式內的變數對於該函數來說為區域變數。</li><li>全域變數：定義在函式作用域之外，或者沒被宣告就直接使用的變數。</li></ul><p>每種 JavaScript 執行環境都有全域物件，在函式作用域之外用<code>this</code>就可以存取得到，所有建立的全域變數都會成為全域物件的屬性。</p><h2 id="全域變數的問題"><a href="#全域變數的問題" class="headerlink" title="全域變數的問題"></a>全域變數的問題</h2><p>因為都存在在相同的全域命名空間，會有命名衝突的問題，之後會學習到命名空間模式，和自我執行的立即執行函式。</p><p>不小心建立全域變數的兩個狀況</p><ul><li>未宣告就使用變數，會自動為全域物件的屬性。</li><li>連續賦值（<code>var a = b = 0;</code>，a 為區域變數，b 為全域變數）。</li></ul><h2 id="遺漏-var-的副作用"><a href="#遺漏-var-的副作用" class="headerlink" title="遺漏 var 的副作用"></a>遺漏 var 的副作用</h2><p>明確定義的全域變數和隱含的全域變數有個微小差別，就是是否能用<code>delete</code>運算子將變數刪除。</p><ul><li>用 var 創造出的全域變數不可刪除</li><li>不使用 var 隱含創造出的全域變數可以刪除</li></ul><p>意思是說隱含創造出的全域變數並不是真的變數，而是全域物件的屬性，屬性可以透過<code>delete</code>運算子刪除，但是變數不行。</p><h2 id="存取全域物件"><a href="#存取全域物件" class="headerlink" title="存取全域物件"></a>存取全域物件</h2><p>在瀏覽器上，任何程式碼都可以透過 window 屬性存取全域物件。</p><h2 id="單一-var-模式"><a href="#單一-var-模式" class="headerlink" title="單一 var 模式"></a>單一 var 模式</h2><p>在函式最開頭使用單一 var 述句是個非常有用的模式：</p><ul><li>再找所有函式所需的變數，只需找一個地方就好。</li><li>避免未宣告就使用變數所造成的邏輯錯誤。</li><li>盡少使用全域變數</li><li>較少的程式碼</li></ul><p>用單一 var 述句宣告多個變數，並用逗號隔開，同時也賦予初始值，可避免邏輯錯誤。</p><h2 id="Hosting：分散的-var-所製造的問題"><a href="#Hosting：分散的-var-所製造的問題" class="headerlink" title="Hosting：分散的 var 所製造的問題"></a>Hosting：分散的 var 所製造的問題</h2><p>JavaScript 允許一個函式內有多個 var 述句，並放在任何位置，他們的行為跟在函式頂端宣告一樣，此行為叫做 Hosting（提升）。</p><p>程式碼會進行兩個處理：</p><ul><li>第一階段：語法分析和讀取內容，將產生變數、函數宣告，以及函式參數。</li><li>第二階段：執行時期，將產生函式表達式和不合格識別字。但為特殊目的，有時我們仍可以採用 hosting 概念。</li></ul><h2 id="for-迴圈"><a href="#for-迴圈" class="headerlink" title="for 迴圈"></a>for 迴圈</h2><p>使用迴圈可以重複整個陣列或類似陣列的物件，如果可以最好是預先計算陣列的長度。</p><p>遵照單一 var 模式，可以將 var 提出迴圈外：</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">looper</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line"><span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>,</span><br><span class="line">max,</span><br><span class="line">myarray=[];</span><br><span class="line"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>,max=myarray.length;i&lt;max;i++)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>優點：一致性<br>缺點：重構時，若要將迴圈複製，要確認有把<code>i</code>及<code>max</code>複製過去。<br>調整：將<code>i++</code>替換為<code>i=i+1</code>、<code>i+=1</code>。<br>（JSLint 對<code>++</code>及<code>--</code>提示「過度使用伎倆」）</p><h2 id="for-in-迴圈"><a href="#for-in-迴圈" class="headerlink" title="for-in 迴圈"></a>for-in 迴圈</h2><p><code>for-in</code>應該使用在重複非陣列物件，又稱為列舉，而陣列應該使用<code>for</code>迴圈。</p><p>在列舉屬性很重要的是使用<code>hasOwnProperty()</code>方法來過濾掉原型鍊的屬性。</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> man = &#123;</span><br><span class="line">  hands: <span class="hljs-number">2</span>,</span><br><span class="line">  legs: <span class="hljs-number">2</span>,</span><br><span class="line">  head: <span class="hljs-number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Object</span>.prototype.clone === <span class="hljs-string">'undefined'</span>) &#123;</span><br><span class="line">  <span class="hljs-built_in">Object</span>.prototype.clone = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hi'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> man) &#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (man.hasOwnProperty(i)) &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(i, <span class="hljs-string">':'</span>, man[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// hands : 2</span></span><br><span class="line"><span class="hljs-comment">// legs : 2</span></span><br><span class="line"><span class="hljs-comment">// head : 1</span></span><br><span class="line"><span class="hljs-comment">//</span></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> man) &#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(i, <span class="hljs-string">':'</span>, man[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// hands : 2</span></span><br><span class="line"><span class="hljs-comment">// legs : 2</span></span><br><span class="line"><span class="hljs-comment">// head : 1</span></span><br><span class="line"><span class="hljs-comment">// clone : ƒ ()&#123; console.log('hi')&#125;</span></span><br></pre></td></tr></table></figure></p><p>意思就是假設你有自訂<code>prototype</code>，使用<code>for-in</code>也會將<code>prototype</code>的屬性列舉出來，不使用檢查也沒問題，只要你可以預期你的程式碼，但如果你不確定的話，最好還是加上去。</p><p>另一種過濾方法</p><p><figure class="highlight jsx hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> i,</span><br><span class="line">hasOwn = <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty;</span><br><span class="line"><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> man)&#123;</span><br><span class="line"><span class="hljs-keyword">if</span>(hasOwn.call(man, i)&#123;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(i, <span class="hljs-string">':'</span>, man[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="不要擴充內建型別的原型"><a href="#不要擴充內建型別的原型" class="headerlink" title="不要擴充內建型別的原型"></a>不要擴充內建型別的原型</h2><p>如果擴充<code>Object()</code>、<code>Array()</code>，或是<code>Function()</code>，可能會讓程式碼難以預測。</p><p>以下可破例的狀況：</p><ul><li>可預期 ECMA 將你新增的方法實作為未來瀏覽器可能有用的功能</li><li>你確定你的方法在原生的 prototype 不存在，也沒有在其他程式碼中被實作過。</li><li>你已經清楚與你的團隊溝通這個變更並文件化</li></ul><h2 id="switch-模式"><a href="#switch-模式" class="headerlink" title="switch 模式"></a>switch 模式</h2><ul><li>將每個 case 與 switch 並排（這是大括號規則的例外）</li><li>將每個 case 內的程式碼縮排</li><li>用清楚的<code>break;</code>結束每個 case</li><li>避免未完結的 case （意思就是特別刪除<code>break</code>），如果堅決如此，應該寫文件說明</li><li>用一個<code>default:</code>結束 switch ，以確保都有合理的結果</li></ul><h2 id="避免隱含的型別轉換"><a href="#避免隱含的型別轉換" class="headerlink" title="避免隱含的型別轉換"></a>避免隱含的型別轉換</h2><p>JavaScript 在比較變數時會做隱含的型別轉換，例如：<code>false == 0</code>或<code>&quot;&quot; == 0</code>皆會回傳 true 。</p><p>建議皆使用 <code>===</code> 和 <code>!==</code> 以維持程式碼的一致性，也可以減少一些精神閱讀。</p><h3 id="避免使用-eval"><a href="#避免使用-eval" class="headerlink" title="避免使用 eval()"></a>避免使用 eval()</h3><p>eval 會將傳入的字串當作程式碼執行，同樣傳遞字串給 <code>setInterval()</code>、<code>setTimeOut()</code> 和 <code>Function()</code>也是如此。</p><p>為了避免安全性的問題，應避免使用 <code>eval()</code>。</p><p><code>new Function()</code> 建構式和 <code>eval()</code> 非常接近，假設真的非用 <code>eval()</code> 那不如使用 <code>new Function()</code> 建構式取代，優點是在函式作用域中執行，只要使用 <code>var</code> 宣告的變數都不會自動變成全域變數，而使用 <code>eval()</code> 則是在全域的環境執行。</p><p>另外注意：<code>Function</code> 與 <code>new Function()</code> 是不同的。</p><h2 id="使用-parseInt-轉型成數值"><a href="#使用-parseInt-轉型成數值" class="headerlink" title="使用 parseInt() 轉型成數值"></a>使用 parseInt() 轉型成數值</h2><p>使用 <code>parseInt()</code> 將一個字串轉換成數值，第二個參數是轉型用的基數，第二個參數通常會被忽略，然而不該如此。<br>如果當要轉換的字串開頭為 0 時，而又忽略第二個參數，基數可能為 <code>10</code> 或 <code>8</code> ，具體狀況則要根據瀏覽器環境而決定。</p><p>將字串轉為數值也可使用<code>Number()</code>。</p><h2 id="編碼規範"><a href="#編碼規範" class="headerlink" title="編碼規範"></a>編碼規範</h2><h3 id="縮排"><a href="#縮排" class="headerlink" title="縮排"></a>縮排</h3><p>不統一的縮排比沒縮排更糟糕。</p><h3 id="大括號"><a href="#大括號" class="headerlink" title="大括號"></a>大括號</h3><p>在 <code>if</code> 或 <code>for</code> 的單行敘述，不加大括號可以執行，但應該加上大括號，以避免新增新的一行導致錯誤。</p><h3 id="左括號的位置"><a href="#左括號的位置" class="headerlink" title="左括號的位置"></a>左括號的位置</h3><p>有些狀況下會因為括號的位置造成程式執行結果不同，影響原因是因為<strong>分號插入機制</strong>，如果在行尾遺漏分號，JavaScript 會自動補齊，但應該永遠在行尾加入分號，避免 JavaScript 隱晦的補上，而導致程式碼有含糊之處。</p><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><p>建議使用空格的地方：</p><ul><li>區隔 for 迴圈各部分分號之後</li><li>for 迴圈，初始化多個變數之間</li><li>區隔 array 物件的逗號之後</li><li>物件屬性間的逗號之後，以及區隔 key/value 的分號之後</li><li>區隔參數的逗號之後</li><li>區隔函式宣告的左括號之前</li><li>匿名函式的 function 之後</li><li>區隔所有運算元及運算子</li><li>在左大括號（<code>{</code>）之前</li></ul><h2 id="命名慣例"><a href="#命名慣例" class="headerlink" title="命名慣例"></a>命名慣例</h2><h3 id="讓建構式字母為大寫"><a href="#讓建構式字母為大寫" class="headerlink" title="讓建構式字母為大寫"></a>讓建構式字母為大寫</h3><p>將建構式命名為大寫，可快速辨別是建構式還是普通函式。</p><h3 id="字詞的分隔方式"><a href="#字詞的分隔方式" class="headerlink" title="字詞的分隔方式"></a>字詞的分隔方式</h3><p>針對建構式可用大駝峰寫法，一般函式使用小駝峰寫法，非函式的變數也可以用全小寫，中間底線區隔。</p><h3 id="其他命名模式"><a href="#其他命名模式" class="headerlink" title="其他命名模式"></a>其他命名模式</h3><p>在整個程式的生命週期都不會變動的常數，可採用全大寫的命名方式。<br>還有一種 private 成員命名慣例是在屬性和方法前面加上底線，以表示為 private 。</p><p>下方為其他 _private 規範的變化：</p><ul><li>在變數尾巴加上底線表示。</li><li>用一個底線的前綴作為 _protected 屬性、用兩個底線作為 __private 屬性。</li><li>Firefox 有一些內部屬性命名前後都會加上兩個底線。</li></ul><h3 id="撰寫註解"><a href="#撰寫註解" class="headerlink" title="撰寫註解"></a>撰寫註解</h3><p>通常要為每個函式的參數、回傳值以及不常見的技術編寫註解。假設你有五到六行的程式碼來執行一個工作，用一行簡單敘述程式碼的目的為何寫在此，之後閱讀程式碼的人就不用詳讀細節。</p><p><strong>持續更新註解，過時的註解比沒註解更糟</strong></p><h2 id="撰寫-API-文件"><a href="#撰寫-API-文件" class="headerlink" title="撰寫 API 文件"></a>撰寫 API 文件</h2><p>推薦工具：</p><ul><li>JSDoc Toolkit</li><li>YUIDoc</li></ul><p>API 文件生成</p><ul><li>發布工具產生的結果（通常是 HTML 頁面）</li><li>撰寫特別格式的程式碼</li><li>執行工具來分析程式碼和註解</li></ul><p>練習寫註解區塊：</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 反轉一個字串</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;String&#125; 輸入字串來做反轉</span><br><span class="line"> * @return &#123;String&#125; 反轉後的字串</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">var reverse = function (input)&#123;</span><br><span class="line">// ...</span><br><span class="line">return output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 讀書筆記 </tag>
            
            <tag> JSDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【讀書筆記】JavaScript Design Pattern Chapter01 介紹</title>
      <link href="/javascript-design-pattern-introduce/"/>
      <url>/javascript-design-pattern-introduce/</url>
      
        <content type="html"><![CDATA[<p>Javascript 是一個不尋常的語言，他沒有 class，而函式是他的第一級物件（firstclass）。</p><a id="more"></a><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>定義：反覆出現的事件或物件，它可以用來產生事物，可能是模板或樣板。</p><p>本書討論以下幾種模式：</p><ul><li>設計模式：設計模式的研究起初以強型別語言為主，但以 js 來說可能有更簡單的選擇。</li><li>編碼模式：JavaScript 特有的模式，為本書的精華重點。</li><li>反模式：反模式和程式錯誤不同，他只是常見的糟糕實踐方法，讓你乍似解決問題，但最後得不償失。</li></ul><h2 id="JavaScript-的重要觀念"><a href="#JavaScript-的重要觀念" class="headerlink" title="JavaScript 的重要觀念"></a>JavaScript 的重要觀念</h2><h3 id="物件導向"><a href="#物件導向" class="headerlink" title="物件導向"></a>物件導向</h3><p>任何在 JavaScript 中看到的都非常可能是物件，只有五種原始型別不是：數值、字串、布林、null 和 undefined，而前三者都有其對應原始型別包裹。</p><p>定義變數時，該變數自動變成內部物件的一個屬性，內部物件又稱為 Activation Object（保存函式作用域內的區域變數和物件，還有函式參數)。</p><p>物件：一堆具名屬性的集合，屬性可以是函式，稱為方法。物件創造後可以隨時修改。<br>有兩種最主要的物件：</p><ul><li>Native（原生物件）：ECMA 標準中描述，可以被歸類為內建物件或使用者定義物件（var o = {}）。</li><li>Host（宿主物件）：定義在 host 環境中，例如：網頁瀏覽器（window、DOM）。如果不確定可在非瀏覽器環境下執行，如果執行成功，應該就只用到原生物件。</li></ul><h3 id="沒有-Class"><a href="#沒有-Class" class="headerlink" title="沒有 Class"></a>沒有 Class</h3><p>JavaScript 沒有 Class ，JavaScript 只處理物件。四人幫書中提到：「多用物件複合，少用類別繼承。」</p><p>意思就是你可以用現有的材料創造新的物件，會比建立出冗長的父子類別繼承鍊或類別系統來得更好。</p><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>原型（prototype）是一個物件，建立的每個函式都會指向一個新的空白物件。此物件和使用物件實字或 Object() 建構式創造出的新物件幾乎一樣，除了它的 constructor 屬性會指向剛建立的函式而不是內建的 Object() 。可以為空白物件新增成員，而之後繼承此物件的新物件可以把這些屬性當作自己的來使用。</p><p>原型是一種屬性，且每個函式都有<code>prototype</code>。</p><h3 id="執行環境"><a href="#執行環境" class="headerlink" title="執行環境"></a>執行環境</h3><p>JavaScript 的原生環境就是瀏覽器，接下來列出的模式大多直接與 JavaScript 核心相關，所以可以忽略環境的差別。</p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 讀書筆記 </tag>
            
            <tag> JSDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【讀書筆記】圖解 HTTP Chapter 09 基於 HTTP 的功能追加協議</title>
      <link href="/graphic-http-chapter09/"/>
      <url>/graphic-http-chapter09/</url>
      
        <content type="html"><![CDATA[<p>當初在制定 HTTP 協議，主要是希望把 HTTP 當作傳輸 HTML 文件的協議，但根據時代演變，網站的用途越來越多樣，像是購物網站、SNS 等（社交網路服務 Social Networking Service），HTTP 協議即使已經滿足需求，但加上本身協議的限制和自身效能的限制，就效能來看不一定是最好的。</p><p>因為現在網路瀏覽器的使用已經佈及全世界，已經完全沒辦法離開 HTTP，因此在其他功能上的不足，會需要建立全新的協議來彌補。</p><a id="more"></a><h2 id="基於-HTTP-協議"><a href="#基於-HTTP-協議" class="headerlink" title="基於 HTTP 協議"></a>基於 HTTP 協議</h2><p>當初在制定 HTTP 協議，主要是希望把 HTTP 當作傳輸 HTML 文件的協議，但根據時代演變，網站的用途越來越多樣，像是購物網站、SNS 等（社交網路服務 Social Networking Service），HTTP 協議即使已經滿足需求，但加上本身協議的限制和自身效能的限制，就效能來看不一定是最好的。</p><p>因為現在網路瀏覽器的使用已經佈及全世界，已經完全沒辦法離開 HTTP，因此在其他功能上的不足，會需要建立全新的協議來彌補。</p><h2 id="消除-HTTP-瓶頸的-SPDY"><a href="#消除-HTTP-瓶頸的-SPDY" class="headerlink" title="消除 HTTP 瓶頸的 SPDY"></a>消除 HTTP 瓶頸的 SPDY</h2><p>Google 在 2010 年發佈了 SPDY，開發宗旨是要解決 HTTP 的效能瓶頸，縮短頁面的載入時間。</p><p><a href="http://www.chromium.org/spdy/" target="_blank" rel="noopener">http://www.chromium.org/spdy/</a></p><h3 id="HTTP-的瓶頸"><a href="#HTTP-的瓶頸" class="headerlink" title="HTTP 的瓶頸"></a>HTTP 的瓶頸</h3><p>在 SNS 網站上，可以看到海量的用戶所發佈的內容，這使網站需要短時間的大量更新內容，為了盡量顯示內容，伺服器內容有更新就馬上回靠到客戶端的頁面上，但這項任務對於 HTTP 來說卻相當困難，因為需要頻繁地從客戶端到伺服端進行確認，如果伺服器上的內容沒更新，就會有多餘的傳輸動作。</p><p>希望網站實現所需要的功能，HTTP 目前遇到下面的瓶頸：</p><ul><li>一條連接只能發送一個請求</li><li>請求只能從客戶端開始，客戶端不能接收除了響應以外的指令</li><li>請求 / 響應首部未經壓縮就發送，首部訊息越多延遲越大</li><li>發送冗長的首部，每次互相發送相同首部造成的浪費較多。</li></ul><h4 id="AJAX-解決方法"><a href="#AJAX-解決方法" class="headerlink" title="AJAX 解決方法"></a>AJAX 解決方法</h4><p>AJAX 是一種利用 JavaScript 和 DOM 的做，已達到局部網站頁面替換的非同步手段，和以前同步通訊相比，由於他只更新頁面的一部份，響應傳輸量會因此減少。</p><p>AJAX 的核心技術是 XMLHttpRequest 的 API ，透過 JavaScript 的呼叫就可以讓伺服器進行 HTTP 通訊，利用 AJAX 從伺服器取得內容，有可能導致大量請求產生，還是沒辦法解決 HTTP 根本的問題。</p><h4 id="Comet-解決方法"><a href="#Comet-解決方法" class="headerlink" title="Comet 解決方法"></a>Comet 解決方法</h4><p>只要伺服器有更新，Comet 不會讓請求等待，而是直接給客戶端響應，這是透過一個延遲應答，模擬伺服器向客戶端推播的功能。</p><p>伺服器收到請求，處理完就會馬上回傳響應，但為了實現推播的功能，Comet 會掛起一個連結，當伺服器更新的時候再回傳響應，因此在伺服端有更新就可以立即回傳給客戶端。</p><p>在內容上雖然可以做到實際的更新，但為了保留響應，一次連續時間也變成，過程中消耗的效能也更多，所以 Comet 也沒有解決 HTTP 協議存在的問題。</p><h3 id="SPDY-的設計與功能"><a href="#SPDY-的設計與功能" class="headerlink" title="SPDY 的設計與功能"></a>SPDY 的設計與功能</h3><p>處於持續開發狀態中的 SPDY 協議，就是為了消除 HTTP 所遭遇的瓶頸。</p><p>SPDY 沒有改寫 HTTP 協議，而是在 TCP/IP 的應用層與傳輸層之間通過新加會一層形式，同時考慮到安全性，SPDY 規定在通訊中必須使用 SSL。SPDY 以會議層的形式加入，控制對資料的流動，但還是採用了 HTTP 建立通訊的連接，可照常使用 HTTP 的方法等。</p><p>使用 SPDY 可以獲得以下功能：</p><ul><li>多路復用流<br>透過單一 TCP 連接，可以無限制處理多個 HTTP 請求，所有請求都在一條 TCP 完成，效率因此提高。</li><li>賦予請求優先順序<br>SPDY 不僅無限制地處理請求，還能分配優先順序，因此解決了頻寬導致的響應變慢的問題。</li><li>壓縮 HTTP 首部<br>壓縮 HTTP 首部，讓封包數量和字串數變少。</li><li>推播功能<br>支援伺服器向客戶端推波資料，因此伺服器可發送資料，也不需要等客戶端的請求。</li><li>伺服器提示服務<br>伺服器可以主動提示客戶端所需要的資料，因此客戶端發現資料之前就可以知道其存在，因此在緩存的狀況下可以避免發送不需要的請求。</li></ul><h3 id="SPDY-消除-Web-的瓶頸了嗎"><a href="#SPDY-消除-Web-的瓶頸了嗎" class="headerlink" title="SPDY 消除 Web 的瓶頸了嗎"></a>SPDY 消除 Web 的瓶頸了嗎</h3><p>希望使用 SPDY 時，希望網站的內容不要做特別的變動，而網站的瀏覽器和伺服器都要為對應的 SPDY 做一定程度的變動，有很多瀏覽器廠商針對 SPDY 做了相對應的調整，但進展不太好。</p><p>因為 SPDY 只是將單個域名（IP 位置）的通訊多路復用，所以當一個網站使用多個域名資料的狀況下，改善效果就會被受到限制。</p><p>SPDY 確實可以消除 HTTP 的瓶頸，但很多網站的問題不僅僅是因為 HTTP 的瓶頸所導致的，對網站效能的提升應該從其他可鑽研的地方下手。</p><h2 id="使用瀏覽器進行全雙工的-WebSocket"><a href="#使用瀏覽器進行全雙工的-WebSocket" class="headerlink" title="使用瀏覽器進行全雙工的 WebSocket"></a>使用瀏覽器進行全雙工的 WebSocket</h2><p>利用 AJAX 和 Comet 的通訊技術可以提升網站的瀏覽速度，但如果使用 HTTP 協議就無法徹底解決問題，而 WebSocket 就是為了解決這些問題而實現的新協議及 API。</p><h3 id="WebSocket-的設計與功能"><a href="#WebSocket-的設計與功能" class="headerlink" title="WebSocket 的設計與功能"></a>WebSocket 的設計與功能</h3><p>WebSocket 就是網站瀏覽器和伺服器之間的全雙工通訊標準。當中 WebSocket 協議由 IETF 所提供，由 W3C 訂定標準，仍在開發中的 WebSocket 技術主要為了解決 AJAX 和 Comet 之中 XMLHttpRequest 附帶的缺陷所引起的問題。</p><h3 id="WebSocket-協議"><a href="#WebSocket-協議" class="headerlink" title="WebSocket 協議"></a>WebSocket 協議</h3><p>一旦伺服器和客戶端之間建立起 WebSocket 協議的通訊，之後的通訊都是靠這個協議在進行，通訊過程可以發送任何格式的資料。由於是建立在 HTTP 基礎上的協議，因此發起端還是客戶端，只要 WebSocket 連接到了，無論伺服器還是客戶端，任何一方都可以直接向對方發起 HTTP 報文。</p><p>主要特點：</p><ul><li><p>推播功能：<br>支援由伺服器對客服端推送資料的推播功能，這樣伺服端就可以直接發送資料，而不用等客戶端的請求。</p></li><li><p>減少通訊量<br>只要建立連接後，就會希望持續下去，和 HTTP 比，不但每次連接的消耗變小，而且因為 WebSocket 的首部訊息很少，通訊量也相對變小了。</p><p>為了做 WebSocket 通訊，在 HTTP 連結建立之後，還需要完成一次握手（Handshaking）的步驟。</p><ul><li><p>握手。請求：為了實現 WebSocket 通訊，需要 HTTP 的 Upgrade 首部字串，告訴伺服器產生改變，已達到握手的目的。</p><ul><li><code>Sec-WebSocket-Key</code>字串裡紀錄握手過程必須的鍵值。</li><li><code>Sec-WebSocket-Protocol</code> 記錄使用的子協議。子協議按 WebSocket 協議標準在連結分開時使用，定義那些連接的名稱。</li></ul></li><li><p>握手。響應：對於之前的請求，返回狀態碼 101 的響應。</p><ul><li><p><code>Sec-WebSocket-Accept</code> 的字串是由請求中的<code>Sec-WebSocket-Key</code>的字串產生。</p><p>成功建立 WebSocket 連接後，通訊就不再使用 http 資料幀。</p></li></ul></li><li><p>WebSocket API：JavaScript 可呼叫「The WebSocket API」來實現 WebSocket 協議下的全雙工通訊。</p></li></ul></li></ul><h2 id="期盼已久的-HTTP-2-0"><a href="#期盼已久的-HTTP-2-0" class="headerlink" title="期盼已久的 HTTP/2.0"></a>期盼已久的 HTTP/2.0</h2><ul><li>http 2.0 的特點：http 2.0 的目標是改善用戶在網站上的使用速度體驗。<ul><li>SPDY</li><li>HTTPSpeed + Mobility（Speed + Mobility）：微軟公司發起，用於提升移動裝置的通訊速度和性能，他建立在 SPDY 與 WebSocket 的基礎。</li><li>Network-Friendly HTTP Upgrade（Friendly）：主要是改善 HTTP 效能的標準。</li></ul></li><li>HTTP/2.0 的七項紀錄與討論<ul><li>壓縮：SPDY、Friendly</li><li>多路復用：SPDY</li><li>TLS 義務化：Speed + Mobility</li><li>協商：Speed + Mobility, Friendly</li><li>客戶端拉曳、伺服端推播：Speed + Mobility</li><li>流量控制：SPDY</li><li>WebSocket：Speed + Mobility</li></ul></li></ul><h2 id="Web-伺服器管理文件的-WebDAV"><a href="#Web-伺服器管理文件的-WebDAV" class="headerlink" title="Web 伺服器管理文件的 WebDAV"></a>Web 伺服器管理文件的 WebDAV</h2><p>WebDAV 是一個可對伺服器上的內容進行文件的複製、編輯等操作的分布式文件系統，除了新增、刪除文件等基本功能，還對文件建立者管理、文件編輯過程中禁止其他用戶內容覆蓋的加鎖功能，以及對文件內容修改的版本控制功能。</p><p>使用 http/1.1 的 put 和 delete 方法，就對伺服器上的文件進行新增和刪除，但基於安全和便利性，一般不使用。</p><h3 id="擴展-http-1-1-的-WebDAV"><a href="#擴展-http-1-1-的-WebDAV" class="headerlink" title="擴展 http/1.1 的 WebDAV"></a>擴展 http/1.1 的 WebDAV</h3><ul><li>集合：是一種統一管理資源的概念</li><li>資源：把文件或集合稱為資源</li><li>屬性：定義資源的屬性</li><li>鎖：把文件設置為無狀態，多人編輯可以防止同一時間寫入。</li></ul><h3 id="WebDAV-內新增的方法及狀態碼"><a href="#WebDAV-內新增的方法及狀態碼" class="headerlink" title="WebDAV 內新增的方法及狀態碼"></a>WebDAV 內新增的方法及狀態碼</h3><p>為了實踐遠端文件管理，在 http 1.1 中也新增了以下這些方法：</p><ul><li>PROPFIND：獲取屬性。</li><li>PROPPATCH：修改屬性。</li><li>MKCOL：建立集合。</li><li>COPY：複製資源及屬性。</li><li>MOVE：移動資源。</li><li>LOCK：資源加鎖。</li><li>UNLOCK：資源解鎖。</li></ul><p>為了配合拓展，狀態碼也隨之新增：</p><ul><li>102：可正常處理請求，但處理中。</li><li>207：存在多種狀態。</li><li>422：格式正確，內容有誤。</li><li>423：資源已被加鎖。</li><li>424：處理與請求關聯的請求失敗，因此不再維持依賴關係。</li><li>507：保存空間不足。</li></ul><blockquote><p>為什麼不一直用 HTTPS 就好？其實只要與個人資訊相關等敏感資料再做加密通訊就好，除了上述缺點外，節約開銷也是重點。<br>資料來源：《圖解 HTTP》 上野宣 人民郵電出版社<br>筆記純屬推廣及分享，如有侵權，請告知。<br>Please advise to remove immediately if any infringement caused.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 圖解 HTTP </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【讀書筆記】圖解 HTTP Chapter 08 確認訪問用戶身份認證</title>
      <link href="/graphic-http-chapter08/"/>
      <url>/graphic-http-chapter08/</url>
      
        <content type="html"><![CDATA[<p>電腦本身沒辦法判斷正在使用電腦的人是誰，為了確認是否為本人，需要核對只有登入者本人才知道的訊息，核對訊息通常是以下：</p><ul><li>密碼（password）：本人才知道的字串。</li><li>動態令牌（dynamic token）：僅限本人擁有設備的一次性密碼。</li><li>數位憑證：本人（終端）所有的訊息。</li><li>生物辨識：指紋或虹膜的生理訊息。</li><li>IC 卡：本人所有的訊息。</li></ul><a id="more"></a><h2 id="何謂認證"><a href="#何謂認證" class="headerlink" title="何謂認證"></a>何謂認證</h2><p>電腦本身沒辦法判斷正在使用電腦的人是誰，為了確認是否為本人，需要核對只有登入者本人才知道的訊息，核對訊息通常是以下：</p><ul><li>密碼（password）：本人才知道的字串。</li><li>動態令牌（dynamic token）：僅限本人擁有設備的一次性密碼。</li><li>數位憑證：本人（終端）所有的訊息。</li><li>生物辨識：指紋或虹膜的生理訊息。</li><li>IC 卡：本人所有的訊息。</li></ul><p>HTTP 所使用的認證方式：</p><ul><li>BASIC 認證 基本認證</li><li>DIGEST 認證 摘要認證</li><li>SSL 認證 客戶端認證</li><li>FormBase 認證 基於表單認證</li></ul><h2 id="BASIC-認證"><a href="#BASIC-認證" class="headerlink" title="BASIC 認證"></a>BASIC 認證</h2><p>這個認證方法是從 HTTP/1.0 就定義的，現在還有一部分網站會用這種認證方法，就伺服器和客戶端進行的認證。</p><h3 id="BASIC-認證步驟"><a href="#BASIC-認證步驟" class="headerlink" title="BASIC 認證步驟"></a>BASIC 認證步驟</h3><ol><li><p>請求資料需要 BASIC 認證時，伺服器會隨著 401 狀態，回傳帶<code>WWW-Authenticate</code>的字串，這個字段包含認證方式，以及 Request-URI 安全域字串。</p></li><li><p>接收到狀態 401 的客戶端為了通過驗證，需要把客戶 ID 及密碼傳送給伺服器，發送字串由 ID 及密碼組成，兩者中間以冒號連接後，再以 Base 64 編碼處理。</p><p>如果客戶 ID 是 guest，密碼是 guest，那連接後就是<code>guest:guest</code>，再經過 Base64 編碼，最後再把編碼後的字串寫入首部字串<code>Authenticate</code>後發送請求。當客戶代理為瀏覽器時，客戶僅輸入用戶 ID 和密碼即可，瀏覽器就會自動完成 Base64 編碼轉換的工作。</p></li><li><p>接收首部字串<code>Authenticate</code>請求的伺服器，會對訊息的正確性進行驗證，通過驗證就會回傳包含一條 Request-URI 的資料回應。</p></li></ol><h4 id="問題點"><a href="#問題點" class="headerlink" title="問題點"></a>問題點</h4><ol><li>雖然採用 Base64 編碼方式，但這不算加密處理，不需要附加訊息就可以對其解碼，解碼後就是用戶 ID 和密碼，所以被竊取的機率極高</li><li>如果要再進行 BASIC 認證，一般瀏覽器沒辦法實現認證註銷操作。</li></ol><p>因此這個認證達不到一般網站對於安全性的需求。</p><h2 id="DIGEST-認證"><a href="#DIGEST-認證" class="headerlink" title="DIGEST 認證"></a>DIGEST 認證</h2><p>為了彌補 BASIC 認證的弱點，在 HTTP/1.1 就有 DIGEST 認證，使用質詢/回應的方式，不像 BASIC 認證直接發送明文。</p><p>質詢/回應：一方會先發認證給對方，接著從對方那邊接收到質詢碼計算產生回應碼，最後將回應碼回傳給對方進行認證。</p><h3 id="DIGEST-認證步驟"><a href="#DIGEST-認證步驟" class="headerlink" title="DIGEST 認證步驟"></a>DIGEST 認證步驟</h3><ol><li><p>請求需認證的資料，伺服器會隨著狀態碼 401，回傳帶<code>WWW-Authenticate</code>的字串，這個字段包含質詢回應方式認證所需的臨時質詢碼（隨機）。</p><ul><li>WWW-Authenticate：必須包含 realm 和 nonce 兩個訊息，客戶端就是靠這兩個字串進行認證</li><li>nonce：是每次隨著 401 回應產生的任意隨機字串，通常是由 Base 64 編碼的十六進制組成。</li></ul></li><li><p>接收到 401 的客戶端，回傳回應包含 DIGEST 認證必要的字串 <code>Authenticate</code> 訊息。</p><p>Authenticate：必須包含 username、realm、nonce、uri 和 response 字串。</p><ul><li>username：realm 限定範圍可進行認證的用戶名。</li><li>uri：Request-URI 的值，考慮經代理轉發 Request-URI 的值可能被修改，因此會先儲存一份在 uri 中。</li><li>response：也可以叫做 Response-Digest，經過 MD5 計算後的密碼字串，詳細閱 RFC 2617。</li></ul></li><li><p>接收到包含<code>Authenticate</code>請求的伺服器，會確認認證訊息的正確性，認證通過後再回傳含有 Request-URI 的資料回應，並在這時候回傳包含<code>Authenticate-Info</code> 的字串，裡面寫了一些認證相關訊息。</p></li></ol><p>DIGEST 認證提供了高於 BASIC 認證的安全等級，但和 HTTPS 的客戶端認證相比，還是很薄弱，DIGEST 認證提供防止密碼被竊聽的機制，但他和 BASIC 認證一樣不敏捷，再來網站高度安全性的要求，還是有所落差，而且適用範圍也有限制。</p><h2 id="SSL-認證"><a href="#SSL-認證" class="headerlink" title="SSL 認證"></a>SSL 認證</h2><p>以 ID 和密碼的認證來說，只要兩者都正確，就可以確認是本人行為，但是如果用戶 ID 和密碼被盜，就可能冒充，利用 SSL 客戶端認證就可以避免這種狀況。</p><p>SSL 客戶端認證是藉由 HTTPS 的客戶端憑證完成認證，伺服器就可以確認是否來自自己登入的客戶端。</p><h3 id="SSL-客戶端認證步驟"><a href="#SSL-客戶端認證步驟" class="headerlink" title="SSL 客戶端認證步驟"></a>SSL 客戶端認證步驟</h3><p>為了能讓 SSL 客戶端認證，需要將客戶端憑證分發給客戶端，且客戶端需要安裝此憑證。</p><ol><li>接收到需要認證資源的請求，伺服器會發送 Certificate Request 訊息，要求客戶端提供客戶端憑證。</li><li>用戶選擇將發送的客戶端憑證後，客戶端會把客戶端憑證訊息以 Client Certificate 訊息方式分發給伺服器。</li><li>伺服器檢驗客戶端憑證，通過後就可以領憑證裡面客戶端的公鑰，即開始 HTTP 加密通訊。</li></ol><h3 id="SSL-客戶端認證採用雙因素認證"><a href="#SSL-客戶端認證採用雙因素認證" class="headerlink" title="SSL 客戶端認證採用雙因素認證"></a>SSL 客戶端認證採用雙因素認證</h3><p>在多數狀況下，SSL 不會只依靠憑證，還跟後續會說到的表單驗證一起做，以達成雙因素認證，就可以確認是用戶本人的電腦在訪問伺服器。</p><p>雙因素認證：認證過程不僅需要密碼一個因素，還需要申請認證者提供其他持有訊息，當作另一個因素，一起結合使用的認證方式。</p><h3 id="SSL-客戶端認證必要的費用"><a href="#SSL-客戶端認證必要的費用" class="headerlink" title="SSL 客戶端認證必要的費用"></a>SSL 客戶端認證必要的費用</h3><p>SSL 客戶端認證需要用到客戶端憑證，而憑證需要支付費用才能使用，每個認證機構的費用不盡相同，要維持安全的營運需要產生相應的費用。</p><h2 id="基於表單認證"><a href="#基於表單認證" class="headerlink" title="基於表單認證"></a>基於表單認證</h2><p>表單驗證方法不是在 HTTP 協議中定義的，客戶端會向伺服端的網站發送登入訊息，按登入訊息的驗證結果認證。</p><h3 id="認證多半基於表單認證"><a href="#認證多半基於表單認證" class="headerlink" title="認證多半基於表單認證"></a>認證多半基於表單認證</h3><p>雖然 HTTP 有提供 BASIC 認證和 DIGEST 認證，但幾乎不怎麼使用，但又由於 SSL 客戶端認證雖然有高度安全性，可是因為導入及費用的關係，還未普及。</p><p>以 SSH 和 FTP 協議來說，服務器與客戶端之間的認證是合乎標準，也滿足了基本功能的需求上的安全級別，因此這些協議可以直接拿來使用，由於網站的認證功能，能夠滿足安全級別的標準規範幾乎不存在，所以只好由網站各自實現表單的認證。</p><p>不具備共同標準的表單驗證，在每個網站上都有不一樣的方式，如果全面考慮安全性的表單驗證，也夠具備高度的安全等級，可是也有很多網站的表單驗證是有問題的。</p><h3 id="Session-管理及-Cookie-應用"><a href="#Session-管理及-Cookie-應用" class="headerlink" title="Session 管理及 Cookie 應用"></a>Session 管理及 Cookie 應用</h3><p>由於表單驗證沒有一定的規範，一般會用 Cookie 來管理 Session。</p><p>基於表單驗證本身是通過伺服端的網站，將客戶端發送的用戶 ID 和密碼與之前登入的訊息座配對來進行認證，但有鑒於 HTTP 是無狀態協定，之前以經任正成功的用戶狀態沒有辦法保存下來，表示用戶下次訪問也沒辦法特別區隔，所以會用 Cookie 來管理 Session，以彌補 HTTP 協議中不存在的狀態管理功能。</p><ol><li><p>客戶端把用戶 ID 和密碼等登入訊息放在 HTTP 訊息的實體，通常以 POST 方法把請求發送給伺服器，會使用 HTPPS 來進行 HTML 表單畫面的顯示和用戶輸入資料的發送。</p></li><li><p>伺服器會發放以用來識別用戶的 SessionID，通過驗證從客戶端發送過來的登入訊息進行身份驗證，接著把認證狀態和 SessionID 綁定後記錄在伺服端。</p><p>客戶端回傳回應時，會在首部字串<code>Set-Cookie</code>內寫入 Session ID，你可以想像 Session ID 是一個用來區分不同用戶的等位號。如果 Session ID 被第三方盜走，那麼對方可能會偽裝你的身份來進行惡意操作，為了預防這種狀況發生，Session ID 應該要用難以預測的字串，伺服端也要進行有效期的管理來保障安全。另外為了減輕 XSS 造成的損失，建議在 Cookie 上加上 httponly 的屬性</p></li><li><p>客戶端接收從伺服端發來的 SessionID 後，會把這個當作 Cookie 保存在本地，下次伺服器發送請求時，瀏覽器會自動發送 Cookie，所以 SessionID 也會發送到伺服器，伺服端就可以驗證接收的 SessionID 以識別用戶跟狀態。</p></li></ol><p>不僅基於表單認證的登入訊息和認證過程都沒有標準化，伺服端應該要如何保存用戶提交的密碼等登入訊息也沒有標準化。</p><p>通常安全地保存是給密碼加鹽（就是隨機產生字串讓他和密碼串相連）的方式增加額外的訊息，再使用散列（hash）函數去計算散列值之後保存，當然也有明文儲存密碼的方法，不過就可能會有風險。</p><blockquote><p>為什麼不一直用 HTTPS 就好？其實只要與個人資訊相關等敏感資料再做加密通訊就好，除了上述缺點外，節約開銷也是重點。<br>資料來源：《圖解 HTTP》 上野宣 人民郵電出版社<br>筆記純屬推廣及分享，如有侵權，請告知。<br>Please advise to remove immediately if any infringement caused.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 圖解 HTTP </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【讀書筆記】圖解 HTTP Chapter 07 確保 Web 安全的 HTTPS</title>
      <link href="/graphic-http-chapter07/"/>
      <url>/graphic-http-chapter07/</url>
      
        <content type="html"><![CDATA[<p>缺點</p><ul><li>通訊使用不加密明文，內容可能會被竊聽</li><li>不驗證通訊方身放，可能遭到偽裝</li><li>無法證明訊息的完整性，可能會遭到竄改</li></ul><p>以上缺點在其他未加密協定也會存在。</p><a id="more"></a><p>缺點</p><ul><li>通訊使用不加密明文，內容可能會被竊聽</li><li>不驗證通訊方身放，可能遭到偽裝</li><li>無法證明訊息的完整性，可能會遭到竄改</li></ul><p>以上缺點在其他未加密協定也會存在。</p><h3 id="通訊使用不加密明文，內容可能會被竊聽"><a href="#通訊使用不加密明文，內容可能會被竊聽" class="headerlink" title="通訊使用不加密明文，內容可能會被竊聽"></a>通訊使用不加密明文，內容可能會被竊聽</h3><ul><li>TCP / IP 是可能被竊聽</li></ul><p>根據 TCP / IP 的工作機制，通訊不加密表示所有通訊線路上的資料都有可能被窺視。</p><p>網路是連接到全世界的網路組成，因此通訊線路上的電腦、光纖及其他網路上都不可能是個人所有，所以可能在某個環節上被遭到窺視。</p><p>即使經過加密處理，也會被窺視到通訊內容，跟未加密的訊息差別在於，加密的訊息有可能讓人無法理解 HTTP 訊息含義，但加密過後的訊息還是有可能被看到。</p><ul><li>加密處理防止被竊聽<br>在目前大家研究如何防止竊聽的對策，最普及的就是加密技術： - 通訊的加密：將通訊加密，HTTP 協議中沒有加密機制，但可以通過 SSL 或 TLS 的組合使用，加密 HTTP 通訊內容。用 SSL 建立安全通訊後，就可以在這條線路上進行 HTTP 通訊，稱之 HTTPS。 - 內容的加密：將 HTTP 訊息內容作加密，而客戶端和伺服端都要同時具備加密及解密機制。不同於 SSL 或 TLS ，內容仍然有被竄改的風險。</li></ul><h3 id="不驗證通訊方的身份就會遭到偽裝"><a href="#不驗證通訊方的身份就會遭到偽裝" class="headerlink" title="不驗證通訊方的身份就會遭到偽裝"></a>不驗證通訊方的身份就會遭到偽裝</h3><p>HTTP 協議中的請求與回應不會對通訊方進行確認，也就是可能會發生伺服端或客戶端的其中一方是偽造的狀況。</p><ul><li><p>任何人都可發送請求<br>在 HTTP 通訊中，由於不存在確認通訊方的處理步驟，在 IP 位置和埠號沒限制的狀況下，無論是誰發送請求，伺服端都會接收請求，所以可能有以下的隱患：</p><pre><code>- 無法確認發送請求的對象是否為目標伺服端。- 無法確認接收請求的對象是否為目標客戶端。- 無法確認正在進行通訊的那方是否有具備訪問權限。</code></pre></li><li><p>查明對方的憑證<br>雖然 HTTP 無法確認對方身份，可是 SSL 可以，而且使用了憑證的方法來確認。憑證由第三方機構頒發，來證明客戶端和伺服端是真實存在。因為偽造憑證很困難，所以確認對方的憑證就可以判斷，而且對使用者來說可以減少訊息洩漏的危險。</p></li></ul><h3 id="無法證明訊息完整性，可能已遭竄改"><a href="#無法證明訊息完整性，可能已遭竄改" class="headerlink" title="無法證明訊息完整性，可能已遭竄改"></a>無法證明訊息完整性，可能已遭竄改</h3><p>這邊的完整性講的是訊息的準確度。</p><ul><li>接收到的內容可能有誤<br>由於無法證明 HTTP 訊息的完整性，因此在請求（或回應）後到對方接收的這段時間，如果內容被竄改也沒辦法知道。意思就是你送出的請求（回應）和另一端接收到的請求（回應），在傳輸過程中可能會遭人篡改，像這樣的模式叫做 MITM（Man-in-the-Middle attack）。</li><li>如何防止竄改<br>雖然有使用 HTTP 協議確認 HTTP 訊息的完整性，但事實上並不可靠，比較常用的是 MD5 和 SHA-1 等散列值檢驗來確認文件的數位簽名。</li></ul><h2 id="HTTP-加密-認證-完整性保護-HTTPS"><a href="#HTTP-加密-認證-完整性保護-HTTPS" class="headerlink" title="HTTP + 加密 + 認證 + 完整性保護 = HTTPS"></a>HTTP + 加密 + 認證 + 完整性保護 = HTTPS</h2><h3 id="HTTP-加上加密處理與認證等完整保護就是-HTTPS"><a href="#HTTP-加上加密處理與認證等完整保護就是-HTTPS" class="headerlink" title="HTTP 加上加密處理與認證等完整保護就是 HTTPS"></a>HTTP 加上加密處理與認證等完整保護就是 HTTPS</h3><p>如果在傳輸過程中使用未加密明文，那麼在頁面上串金流就也可能會被竊聽，那一些金融資料就可能會被曝露，另外沒辦法確認對方身份也很麻煩，所以為了統一解決上述問題，就需要在 HTTP 上做加密處理，因此把加密及認證機制稱作 HTTPS。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">https://...</span><br></pre></td></tr></table></figure></p><h3 id="HTTPS-是身披-SSL-外殼的-HTTP"><a href="#HTTPS-是身披-SSL-外殼的-HTTP" class="headerlink" title="HTTPS 是身披 SSL 外殼的 HTTP"></a>HTTPS 是身披 SSL 外殼的 HTTP</h3><p>HTTPS 不算是在應用層的新協議，只是通訊端用 SSL 和 TLS 協議替代，通常使用 HTTP 是直接和 TCP 層通訊，但 HTTPS 使用 SSL ，就變成 SSL 在跟 TCP 通訊，這樣的感覺就像在 TCP 和 HTTP 中間多了一層 SSL。</p><p>SSL 是獨立於 HTTP 協議，所以應用層的 SMTP 和 Telent 等等協議都可以配合。</p><h3 id="相互交換密鑰的公開密鑰加密技術"><a href="#相互交換密鑰的公開密鑰加密技術" class="headerlink" title="相互交換密鑰的公開密鑰加密技術"></a>相互交換密鑰的公開密鑰加密技術</h3><p>SSL 採用公開密鑰加密的加密處理方式，現在的加密方法是公開的，但是密鑰是保密的，加密和解密都會用到密鑰，換句話說有密鑰就可以解密。</p><ul><li>共享密鑰加密的困境</li></ul><p>加密和解密共用同個密鑰叫做共享密鑰加密，又稱為密鑰加密。</p><p>以共享密鑰加密的方式把密鑰傳送給對方，但在傳送的過程也可能會被遭到攻擊，如果密鑰被攻擊者知道就失去意義，那我們該如何安全傳輸密鑰呢？</p><ul><li><p>使用兩把密鑰的公開密鑰加密<br>公開密鑰加密的方式解決了共享密鑰加密的困難。</p><p>公開密鑰加密：有一把非對稱的密鑰，一把叫做私有密鑰（私鑰），一把叫做公開密鑰（公鑰），意思就是私有密鑰不能給別人知道，公開密鑰可以讓任何人知道。</p><p>過程：發送密文的那方使用接收方的密鑰進行加密處理，對方收到加密的訊息再用自己的私鑰進行解密。</p><p>這樣的方式就不用擔心訊息被竊盜，另外如果想根據密文和公鑰來解密是非常困難的，因為解密的過程就是對離散數學求值，密碼還是有機會遭到破解，但就現在的技術而言是不太可能的。</p></li><li><p>HTTPS 採用混合加密機制<br>HTTPS 採用共享密鑰加密和公開密鑰加密兩者並用的混合加密機制，如果密鑰能夠安全交換，那麼就有可能會用公開密鑰的方式來進行通訊，但公開密鑰比共享密鑰加密的方式還慢。</p></li></ul><h3 id="證明公開密鑰正確性的證書"><a href="#證明公開密鑰正確性的證書" class="headerlink" title="證明公開密鑰正確性的證書"></a>證明公開密鑰正確性的證書</h3><p>公開密鑰還是有問題，就是無法證明公開密鑰本身的真實性，舉例來說：</p><p>準備和某台主機建立公開密鑰加密的方式，來進行通訊傳輸，如何確認公開密鑰就是原本那台伺服器發送的公開密鑰，因為有可能在公開密鑰傳輸的過程中被攻擊者替換。</p><p>為了解決上述問題，可以使用數位憑證認證機構，與相關機關頒發的公開密鑰證書。</p><ul><li>數位憑證認證機構：客戶端與伺服端雙方都可信任的第三方機構。</li><li>流程：伺服器的營運人員先向第三方申請公開密鑰的申請，數位憑證機構判明提出申請者的身份，在對已申請的公開密鑰做數字簽名，然後再分配這個已簽名的公開密鑰，並將公開密鑰放入公鑰證書後並綁定。</li><li>伺服端：伺服端會把這份數位憑證機構頒發的公鑰發送給客戶端，以做公鑰密鑰加密的方式通訊，公鑰憑證也可以叫做數位憑證。</li><li>客戶端：接收到數位憑證的客戶端，可以使用公鑰對數位憑證進行驗證，驗證通過即可證明認證伺服器的身份以及其公鑰是可以信賴。</li></ul><p>數位憑證的公鑰要安全地交給客戶端是困難的事，因此瀏覽器商在發布版本的時候，會事先在內部植入常用的數位憑證機構的公鑰。</p><p>客戶端作業順序：</p><ol><li>使用瀏覽器植入的公開密鑰</li><li>拿到伺服器的數位憑證後，用瀏覽器的公開密鑰做驗證</li><li>驗證過後使用公開密鑰對 HTTP 訊息做加密後傳輸</li></ol><p>伺服端作業流程：</p><ol><li>伺服器把自己的公開密鑰登錄到數位憑證機構</li><li>接收到請求方的請求後，伺服端用私鑰對加密的請求進行解密</li></ol><ul><li>可證明組織真實性的 EV SSL 證書</li></ul><p>憑證是來證明其中一方的身份，再來就是確認伺服器規模。擁有該特性的憑證就是 EV SSL 憑證。</p><p>EV SSL 數位憑證基於國際標準，嚴格規定了對營運組織的確認方針，因此通過的網站可以獲得比較高的認可度。擁有 EV SSL 數位憑證的瀏覽器，在瀏覽器 URL 欄位的背景色是綠色，為的是防止釣魚攻擊。</p><ul><li><p>用以確認客戶端的客戶端證書</p><p>HTTPS 中還可以使用客戶端憑證，證實伺服器正在通訊的那方是預期的客戶端，作用和伺服端憑證相同，但仍然有幾個問題點：</p><ul><li>憑證的頒發與獲得：要拿到證書意味要付費購買，讓不同用戶自行安裝憑證這件事就具有很大的挑戰。現況是安全性比較高的憑證機構可以頒發客戶端憑證，但僅限於特殊用途，像是可以支付憑證的業務。像是網路銀行就常使用客戶端憑證。</li><li>無法獲得用戶本人的真實性：就算確認了電腦，但不能代表使用電腦的人就是擁有憑證的本人。</li></ul></li><li><p>認證機構信譽第一<br>SSL 機制之所以可行，是因為認證機構是可被信賴的，之前在荷蘭有被爆出憑證機構被駭客入侵。雖然現在有將憑證吊銷的機制，以及從客戶端刪除憑證發布機構的對策，但距離完全實現還需要一點時間。</p></li><li><p>由自認證機構頒發的證書稱為自簽名證書<br>使用 Open SSL 每個人可以建立自己的數位憑證，給自己的伺服器憑證，但在網路上是不可以使用，如果瀏覽器訪問該網站就會出現「無法確認連接安全」或「此網站憑證存在問題」等等，主要是因為無法消除偽裝可能性的關係。</p></li></ul><h3 id="HTTPS-的安全通信機制"><a href="#HTTPS-的安全通信機制" class="headerlink" title="HTTPS 的安全通信機制"></a>HTTPS 的安全通信機制</h3><ul><li>SSL 和 TLS<br>IETF 以 SSL 3.0 為基準，後來又制訂了 TLS 1.0 及 TLS 1.1 的版本，目前主流的是 SSL 3.0 和 TLS 1.0。</li><li>SSL 速度慢嗎<ul><li>通訊慢：和 HTTP 比，網路負載會慢 2-10 倍，TCP 連接、發送 HTTP 請求、回應也都要進行 SSL 通訊，所以通訊量也會增加。</li><li>效能慢：因為需要進行加密處理，伺服端和客戶端都需要進行加密和解密的過程，就結果來說 SSL 會消耗更多伺服器和客戶端的硬體資源。</li></ul></li></ul><blockquote><p>為什麼不一直用 HTTPS 就好？其實只要與個人資訊相關等敏感資料再做加密通訊就好，除了上述缺點外，節約開銷也是重點。<br>資料來源：《圖解 HTTP》 上野宣 人民郵電出版社<br>筆記純屬推廣及分享，如有侵權，請告知。<br>Please advise to remove immediately if any infringement caused.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 圖解 HTTP </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【讀書筆記】圖解 HTTP Chapter 06 HTTP 首部（中）</title>
      <link href="/graphic-http-chapter06-2/"/>
      <url>/graphic-http-chapter06-2/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP-1-1-通用首部字串"><a href="#HTTP-1-1-通用首部字串" class="headerlink" title="HTTP / 1.1 通用首部字串"></a>HTTP / 1.1 通用首部字串</h2><p>就是雙方都會用到的字串。</p><a id="more"></a><h2 id="HTTP-1-1-通用首部字串-1"><a href="#HTTP-1-1-通用首部字串-1" class="headerlink" title="HTTP / 1.1 通用首部字串"></a>HTTP / 1.1 通用首部字串</h2><p>就是雙方都會用到的字串。</p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Cache-Control: private, max-age=0, no-cache</span><br></pre></td></tr></table></figure></p><p>操作緩存的工作，多個指令可以透過逗點分隔。</p><p>客戶端：請求緩存<br>伺服端：控制緩存資料</p><h4 id="緩存請求指令表"><a href="#緩存請求指令表" class="headerlink" title="緩存請求指令表"></a>緩存請求指令表</h4><ul><li>no-cache：（無參數）強制跟來源伺服器再認證</li><li>no-store：（無參數）不緩存請求或回應任何內容</li><li>max-age = [ 秒]：（必須）回應的最大 age 值</li><li>max-stale(= [ 秒])：（可省略）接收已過期的回應</li><li>min-fresh：（必須）希望在限定時間內的回應能有效</li><li>no-transform：（無參數）代理不可更改的媒介類型</li><li>only-if-cached：（無參數）從緩存取得資料</li><li>cache-extension：新指令標記</li></ul><h4 id="緩存回應指令表"><a href="#緩存回應指令表" class="headerlink" title="緩存回應指令表"></a>緩存回應指令表</h4><ul><li>public：（無參數）可向任意一方提供任何緩存</li><li>private：（可省略）謹向特別用戶回傳回應資料</li><li>no-cache：（可省略）緩存前必須確認有效性</li><li>no-store：（無參數）不緩存請求或回應內容</li><li>no-transform：（無參數）代理不可以更改媒體類型</li><li>must-revalidate：（無參數）可緩存，但必須向來源伺服器再次確認</li><li>proxy-revalidate：（無參數）要求中間的緩存伺服器對緩存的回應有效性進行再次確認</li><li>max-age = [ 秒]：（必須）回傳最大的 age 值</li><li>s-maxage = [ 秒]：（必須）公共緩存伺服器最大的 age 值</li><li>cache-extension：新指令標記</li></ul><h4 id="public-指令"><a href="#public-指令" class="headerlink" title="public 指令"></a>public 指令</h4><p>表示其他用戶可以利用緩存。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Cache-Control: public</span><br></pre></td></tr></table></figure></p><h4 id="private-指令"><a href="#private-指令" class="headerlink" title="private 指令"></a>private 指令</h4><p>與 public 相反，只回應資料給特定用戶，其他人則不會回傳資料。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Cache-Control: private</span><br></pre></td></tr></table></figure></p><h4 id="no-cache-指令"><a href="#no-cache-指令" class="headerlink" title="no-cache 指令"></a>no-cache 指令</h4><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure></p><p>為了防止從緩存資料裡面回傳過期的資料。</p><p>如果客戶端有包含 no-cache 指令，則表示客戶端不會接受緩存過的回應，因此必須把客戶端的請求轉發到來源伺服器。</p><p>如果伺服端有包含 no-cache 指令，則緩存伺服器不能對資料進行緩存，瀏覽器以後也不能再對緩存伺服器請求中提出資料是否有效的確認，也禁止對回應資料做緩存。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Cache-Control: no-cache=Location</span><br></pre></td></tr></table></figure></p><p>由伺服端回傳的回應中，訊息中的 header 的 Cache-Control 如果在 no-cache 字串指定參數，客戶端在接收這個被指定的參數值所對應的回應訊息後，就不能進行緩存，換句話說就是沒有參數值的 header 字串可以進行緩存。</p><h4 id="控制可以進行緩存的物件的指令"><a href="#控制可以進行緩存的物件的指令" class="headerlink" title="控制可以進行緩存的物件的指令"></a>控制可以進行緩存的物件的指令</h4><h4 id="no-store-指令"><a href="#no-store-指令" class="headerlink" title="no-store 指令"></a>no-store 指令</h4><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Cache-Control: no-store</span><br></pre></td></tr></table></figure></p><p>當使用這個指令，暗示這段通訊（請求或回應）包含機密訊息。<br>有些人以為<code>no-cache</code>是不緩存，但其實是不緩存過期資源，而<code>no-store</code>才是真的不緩存。</p><p>因此這個指令規定不能在本地儲存請求或回應中的任何一部份。</p><h4 id="指定緩存期限和認證指令"><a href="#指定緩存期限和認證指令" class="headerlink" title="指定緩存期限和認證指令"></a>指定緩存期限和認證指令</h4><h4 id="s-maxage-指令"><a href="#s-maxage-指令" class="headerlink" title="s-maxage 指令"></a>s-maxage 指令</h4><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Cache-Control: s-maxage=604800(秒)</span><br></pre></td></tr></table></figure></p><p>這個指令和等等要介紹的<code>max-age</code>指令一樣，差別在於<code>s-maxage</code>只適合給多個使用者使用的公共緩存伺服器，換句話說對於單一使用者重複回應的伺服器來說這個指令是沒用的。</p><p>另外使用這個指令會忽略<code>Expires</code>指令和<code>max-age</code>指令。</p><h4 id="max-age-指令"><a href="#max-age-指令" class="headerlink" title="max-age 指令"></a>max-age 指令</h4><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Cache-Control: max-age=604800(秒)</span><br></pre></td></tr></table></figure></p><p>當客戶端發出的請求有這個指令，如果判定緩存資料的緩存時間比指定的時間數更小，那麼客戶端就會接收緩存的資源，如果指定數值是 0，那緩存伺服器就會把請求轉給來源伺服器。</p><p>當伺服器回傳的回應有這個指令，緩存就不會確認資料是否還具有有效性，而這個指令的數值是代表這個資料能夠緩存的最長時間。</p><p>HTTP / 1.1 版本的緩存服務遇到同時存在<code>Expires</code>指令的情快，會優先處理<code>max-age</code>指令，而忽略<code>Expires</code>指令，但 HTTP / 1.0 則完全相反。</p><h4 id="min-fresh-指令"><a href="#min-fresh-指令" class="headerlink" title="min-fresh 指令"></a>min-fresh 指令</h4><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Cache-Control: min-fresh=60(秒)</span><br></pre></td></tr></table></figure></p><p>這個指定是指說當發出請求後，指定的時間過後的資料都沒辦法再進行回應。<br>以上述來說<code>min-fresh=60</code>是指過超過了 60 秒的資料都沒辦法當作回應回傳。</p><h4 id="max-stale-指令"><a href="#max-stale-指令" class="headerlink" title="max-stale 指令"></a>max-stale 指令</h4><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Cache-Control: max-stale=360(秒)</span><br></pre></td></tr></table></figure></p><p>使用這個指令就算資料已經過期了，還是可以進行緩存。</p><p>如果指令中沒有參數，則表示不管資料過期多久，客戶端都會收到回應；如果有具體數字，那個即使過期，只要在這個指定的時間內，仍然會被客戶端所接收。</p><h4 id="only-if-cached-指令"><a href="#only-if-cached-指令" class="headerlink" title="only-if-cached 指令"></a>only-if-cached 指令</h4><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Cache-Control: only-if-cached</span><br></pre></td></tr></table></figure></p><p>使用這個指令意思是發生請求後，緩存伺服器會不斷載入來源伺服器的回應，也不會重複確認資料的有效性，如果發生請求緩存伺服器，而緩存伺服器的本地沒有來源伺服器給的資料，就會發出 504。</p><h4 id="must-revalidate-指令"><a href="#must-revalidate-指令" class="headerlink" title="must-revalidate 指令"></a>must-revalidate 指令</h4><p>使用這個指令，代理會向來源伺服器再驗證要回傳的回應緩存資料是否有效，如果代理無法透過來源伺服器再次拿到有效的資料，那麼代理就會回傳 504 給客戶端。</p><p>另外使用這個指令也會忽略<code>max-stale</code>的請求。</p><h4 id="proxy-revalidate-指令"><a href="#proxy-revalidate-指令" class="headerlink" title="proxy-revalidate 指令"></a>proxy-revalidate 指令</h4><p>這個指令意思是，如果客戶端傳出帶有這個指令的請求，那麼緩存伺服器在回傳回應資料前，要先再驗證資料的有效性。</p><h4 id="no-transform-指令"><a href="#no-transform-指令" class="headerlink" title="no-transform 指令"></a>no-transform 指令</h4><p>使用這個指令無論在請求或是回應，緩存都不能改變實體的媒體類型，這樣可以防止緩存或代理壓縮圖片等等。</p><h4 id="Cache-Contorl-擴展"><a href="#Cache-Contorl-擴展" class="headerlink" title="Cache-Contorl 擴展"></a><strong>Cache-Contorl 擴展</strong></h4><h4 id="cache-extension-token"><a href="#cache-extension-token" class="headerlink" title="cache-extension token"></a>cache-extension token</h4><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Cache-Control: private, community=&quot;UCI&quot;</span><br></pre></td></tr></table></figure></p><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><p>Connection header 字串有兩個功能：</p><ul><li>控制不再轉發給代理的 header：在客戶端發送請求和伺服器回傳回應，使用 Connection 可以控制不要再轉發給代理 header（hop-by-hop）。</li><li>管理持久連接：HTTP / 1.1 的默認連接都是持久，所以客戶端會在持久連結上持續發送請求，當伺服端要斷開連結時，就會指名 Connection 為 close。</li></ul><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure></p><p>Http / 1.1 之前的版本默認連結都不是持久連結，所以需要指定 Connection 是 Keep-Alive。</p><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>建立 HTTP 訊息的時間和日期，1.1 的版本使用 RFC1123 規定的日期時間格式：</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Date: Tue, 03 Jul 2012 04:40:59 GMT</span><br></pre></td></tr></table></figure></p><h3 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h3><p>Pragma 是為了向後兼容而存在，它只支援 HTTP/1.0 的緩存伺服器，因為當時 HTTP / 1.1 的 Cache-Control 還沒有支援。<br>雖然是通用 header ，但只用在客戶端發送的請求，客戶端會要求所有中介的伺服器不回傳緩存資料。</p><p>如果都使用 HTTP / 1.1 版本，那直接使用<code>Cache-Control: no-cache</code> 是最好，但仍有些無法版本沒有支援，所以發送的請求最好如下：</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br><span class="line">Pragma: no-cache</span><br></pre></td></tr></table></figure></p><h3 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h3><p>Trailer 的作用是讓發送端在分塊發送的訊息後面增加其他訊息。</p><h3 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h3><p>Transfer-Encoding 的作用是規定傳送的 HTTP 訊息是採用哪個編碼方式。</p><h3 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h3><p>這個字串是用來檢測 HTTP 協議與其他協議是否可以用更新的版本來通訊，參數可以用來指定不同的通訊版本。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: TLS/1.0</span><br></pre></td></tr></table></figure></p><p>Connection 要設定為 Upgrade，才能使用 Upgrade 字串。</p><h3 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h3><p>Via 是為了要追蹤客戶端與伺服端之間的請求（回應）的 HTTP 訊息傳輸路徑而存在，另外還能避免回環的狀況。</p><p>當訊息經過代理或閘道，會加上 Via header，再進行轉發，這個和 traceroute 與 Received header 的工作模式很像。</p><p>通常使用 Via 會和 Trace 方法一起使用，例如代理伺服器收到 Trace 方法（Max-Forwards: 0）傳來的請求，代理就不能再轉發這個請求，如此代理會把自己的訊息加上 Via header 再回傳請求要求的回應。</p><h3 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h3><p>這個字串會告知使用者一些與緩存相關的問題警告，HTTP 1.1 制定了七種警告，警告具有擴展性，未來還有可能再新增。</p><ul><li>110 - Response is stale：代理回傳的資料已經過期。</li><li>111 - Revalidate failed：代理再驗證後，資料有效性失效。</li><li>112 - Disconnection operation：代理與網路被蓄意切斷。</li><li>113 - Heuristic expiration：回應使用期間已經超過 24 小時。</li><li>199 - Miscellaneous warning：任何警告內容。</li><li>214 - Transformation applied：代理對內容編碼或媒體類型進行處理。</li><li>299 - Miscellaneous persistent warning：任意警告內容。<blockquote><p>資料來源：《圖解 HTTP》 上野宣 人民郵電出版社<br>筆記純屬推廣及分享，如有侵權，請告知。<br>Please advise to remove immediately if any infringement caused.</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 圖解 HTTP </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【讀書筆記】圖解 HTTP Chapter 06 HTTP 首部（上）</title>
      <link href="/graphic-http-chapter06-1/"/>
      <url>/graphic-http-chapter06-1/</url>
      
        <content type="html"><![CDATA[<p>HTTP 協議的請求和回應一定含有 http header，客戶端和伺服端的 header 內容，針對處理請求和回應有所不同。請求 header 大部分都不需要親自查看。</p><a id="more"></a><h2 id="HTTP-訊息的-header"><a href="#HTTP-訊息的-header" class="headerlink" title="HTTP 訊息的 header"></a>HTTP 訊息的 header</h2><p>HTTP 協議的請求和回應一定含有 http header，客戶端和伺服端的 header 內容，針對處理請求和回應有所不同。請求 header 大部分都不需要親自查看。</p><h3 id="請求-header"><a href="#請求-header" class="headerlink" title="請求 header"></a>請求 header</h3><ul><li>請求列</li><li>請求 header</li><li>通用 header</li><li>實體 header</li></ul><h3 id="回應-header"><a href="#回應-header" class="headerlink" title="回應 header"></a>回應 header</h3><ul><li>狀態列</li><li>回應 header</li><li>通用 header</li><li>實體 header</li></ul><h2 id="HTTP-首部字段"><a href="#HTTP-首部字段" class="headerlink" title="HTTP 首部字段"></a>HTTP 首部字段</h2><h3 id="結構"><a href="#結構" class="headerlink" title="結構"></a>結構</h3><p>由字串和值來形成，例如：</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Content-type: text/html</span><br></pre></td></tr></table></figure></p><p>也有可能一個字串配多個值，例如：</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Keep-Alive: timeout=15, max=100</span><br></pre></td></tr></table></figure></p><h3 id="字串類型"><a href="#字串類型" class="headerlink" title="字串類型"></a>字串類型</h3><ul><li>通用 header：請求訊息和回應訊息都會用的 header</li><li>請求 header：從客戶端對伺服端發出請求訊息所使用的，包含補充請求的附加內容、客戶端訊息等等</li><li>回應 header：從伺服器端回傳給客戶端所需要的，包含回應附加內容，也會要求客戶端附加額外的訊息內容</li><li>實體 header：針對請求和回應訊息的實體使用，包含要補充的資料內容、更新時間等等</li></ul><h3 id="HTTP-1-1-header-字串一覽"><a href="#HTTP-1-1-header-字串一覽" class="headerlink" title="HTTP/1.1 header 字串一覽"></a>HTTP/1.1 header 字串一覽</h3><p>HTTP/1.1 規範了 47 種字串。</p><h4 id="通用-header"><a href="#通用-header" class="headerlink" title="通用 header"></a>通用 header</h4><ul><li>Cache-Control：控制緩存行為</li><li>Connetion：逐跳 header、連接的管理</li><li>Date：創建日期</li><li>Pragma：訊息指令</li><li>Trailer：訊息尾端的 header 一覽</li><li>Transfer-Encoding：指定訊息主體的傳輸編碼方式</li><li>Upgrade：升級為其他協議</li><li>Via：代理伺服器相關訊息</li><li>Warning：錯誤通知</li></ul><h4 id="請求-header-1"><a href="#請求-header-1" class="headerlink" title="請求 header"></a>請求 header</h4><ul><li>Accept：用戶代理可處理的媒體類型</li><li>Accept-Charset：優先的字串集</li><li>Accept-Encoding：優先的內容編碼</li><li>Accept-Language：優先的自然語言</li><li>Authorization：網頁認證訊息</li><li>Expect：期待伺服器的特定行為</li><li>Form：用戶的電子信箱地址</li><li>Host：請求資料的伺服器位置</li><li>If-Match：比較實體標記（ETag）</li><li>If-Modified-Since：比較資料更新時間</li><li>If-None-Match：比較實體標記（與 If-Match 相反）</li><li>If-Range：資料未更新時發送的實體 Byte 的範圍請求</li><li>If-Unmodified-Since：比較資料更新時間（與 If-Modified-Since 相反）</li><li>Max-Forwards：最大傳輸逐格跳</li><li>Proxy-Authorization：代理伺服器要求客戶端的認證訊息</li><li>Range：實體的字串範圍請求</li><li>Referer：對請求的 URI 的原始獲得方</li><li>TE：傳輸編碼的優先級</li><li>User-Agent：HTTP 客戶端程式訊息</li></ul><h4 id="回應-header-1"><a href="#回應-header-1" class="headerlink" title="回應 header"></a>回應 header</h4><ul><li>Accept-Range：是否接受字串範圍請求</li><li>Age：推算資料建立時間</li><li>Etag：資料匹配訊息</li><li>Location：讓客戶端重新導向的 URI</li><li>Proxy-Authenticate：代理伺服器對客戶端的認證訊息</li><li>Retry-After：對再次發請求的時機要求</li><li>Server：HTTP 伺服器的安裝訊息</li><li>Vary：代理伺服器緩存的認證訊息</li><li>WWW-Authenticate：伺服器對客戶端的認證訊息</li></ul><h4 id="實體-header"><a href="#實體-header" class="headerlink" title="實體 header"></a>實體 header</h4><ul><li>Allow：資料可支援的 HTTP 方式</li><li>Content-Encoding：實體適用的編碼方式</li><li>Content-Language：實體的自然語言</li><li>Content-Length：實體的大小（字元）</li><li>Content-Location：代替對應資料的 URI</li><li>Content-MD5：實體的訊息摘要</li><li>Content-Range：實體的位置範圍</li><li>Content-Type：實體的媒體類型</li><li>Expires：實體過期日期時間</li><li>Last-Modified：資料最後修改日期時間</li></ul><h4 id="非-HTTP-1-1-的首部字串"><a href="#非-HTTP-1-1-的首部字串" class="headerlink" title="非 HTTP/1.1 的首部字串"></a>非 HTTP/1.1 的首部字串</h4><p>HTTP 所使用的字串，不限於 RFC2616 定義的 47 種，還有 Cookie、Set-Cookie 和 Content-Desposition 等等。</p><h4 id="End-to-end-header-和-Hop-by-hop-header"><a href="#End-to-end-header-和-Hop-by-hop-header" class="headerlink" title="End-to-end header 和 Hop-by-hop header"></a>End-to-end header 和 Hop-by-hop header</h4><p>HTTP header 定義成緩存代理和非緩存代理兩種類型：</p><ul><li>End-to-end header：分在此類的 header 會轉發給請求 / 回應對應的最後接收目標，且必須保存由緩存所產生的回應中，另外規定他必須要被轉發。</li><li>Hop-by-hop header：分在此類的 header 只會對單次的轉發有效，會因為緩存或代理的關係而不再需要被轉發，HTTP/1.1 和之後的版本，如果要用此類型，需要提供 Connection header 字串。</li></ul><p>以下除了這八個 header 字串之外，其他都算 End-to-end header 字串：</p><ul><li>Connection</li><li>Keep-Alive</li><li>Proxy-Authenticate</li><li>Trailer</li><li>TE</li><li>Transfer-Encoding</li><li>Upgrade</li></ul><blockquote><p>資料來源：《圖解 HTTP》 上野宣 人民郵電出版社<br>筆記純屬推廣及分享，如有侵權，請告知。<br>Please advise to remove immediately if any infringement caused.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 圖解 HTTP </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【讀書筆記】圖解 HTTP Chapter 06 HTTP 首部（下）</title>
      <link href="/graphic-http-chapter06-3/"/>
      <url>/graphic-http-chapter06-3/</url>
      
        <content type="html"><![CDATA[<h2 id="請求首部字段"><a href="#請求首部字段" class="headerlink" title="請求首部字段"></a>請求首部字段</h2><p>請求 header 就是客戶端發送 http 訊息給伺服端所要補充的附加訊息。</p><a id="more"></a><h2 id="請求首部字段-1"><a href="#請求首部字段-1" class="headerlink" title="請求首部字段"></a>請求首部字段</h2><p>請求 header 就是客戶端發送 http 訊息給伺服端所要補充的附加訊息。</p><h3 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h3><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Accept: text/html, application/xhtml+xml...</span><br></pre></td></tr></table></figure></p><p>這個字串可以告訴伺服器，客戶端需要能處理的媒體類型和相對的優先順序。<br>使用的是 type/subtype 型式，可以一次指定多種媒體的方式。</p><ul><li>文字文件<ul><li>text/html, text/plain, text/css …</li></ul></li><li>圖片文件<ul><li>images/jpeg, image/gif …</li></ul></li><li>影音文件<ul><li>video/mpeg, video/quicktime …</li></ul></li><li>應用程序所使用的二進制文件<ul><li>application/zip …</li></ul></li></ul><p>如果需要優先順序，使用 <code>q=</code> 來表示權重，範圍是<code>0~1</code>，可細分至小數點後三位，並用分號分隔，默認權重是 <code>q=1.0</code>。</p><h4 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h4><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Accept-Charset: iso-8859-5, unicode1-1;q=0.8</span><br></pre></td></tr></table></figure></p><p>這個字串用來通知伺服器客戶端所支援的字串集，及相對順序，一樣可以使用 q 值來表示優先順序。</p><h4 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h4><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Accept-Charset: gzip, deflate</span><br></pre></td></tr></table></figure></p><p>這個字串用來通知伺服器客戶端所支援的編碼，及相對順序，可以一次指定多種編碼。</p><h4 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h4><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Accept-Language: zh-cn,zh;q=0.7</span><br></pre></td></tr></table></figure></p><p>這個字串用來通知伺服器客戶端所支援的語言，及相對優先順序，一樣可以使用 q 值來表示優先順序。</p><h3 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h3><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Authorization: Basic dWVde3fs..</span><br></pre></td></tr></table></figure></p><p>這個字串通常是還告訴伺服器，用戶代理的認證訊息。通常想要通過伺服器的用戶代理收到回傳的 401 狀態碼之後，會把<code>Authorization</code> 加入請求中。共用緩存在接收到 Authorization 的請求操作會有所差異。</p><h3 id="Expect"><a href="#Expect" class="headerlink" title="Expect"></a>Expect</h3><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Expect: 100-continue</span><br></pre></td></tr></table></figure></p><p>用戶端用此字串來告訴伺服端，希望伺服端做出某種特別的行為，如果伺服端無法達成就會回傳 417 狀態碼。</p><h3 id="Form"><a href="#Form" class="headerlink" title="Form"></a>Form</h3><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Form: info@hacker.jp</span><br></pre></td></tr></table></figure></p><p>這個字串用來告知伺服器用戶代理的用戶電子郵件地址。通常是為了顯示搜尋引擎等的用戶代理負責人的電子郵件聯繫方式，使用代理時盡量用這個字串，但可能因為代理不同而顯示在 User-Agent 中。</p><h3 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h3><p>這個字串會告訴伺服器，請求的資料所在的網路主機名稱和埠號，在 Http/1.1 中是唯一一個必須要包含在內的字串部。</p><p>Host 對於單台伺服器分配多個域名的虛擬主機工作機制有很密切的關係。<br>請求被發送到伺服器時，請求的主機名會用 IP 位置來替換處理，如果相同 IP 位置下部署多個域名，那個伺服器就會無法了解是哪個對應的域名做請求，因此就需要 host 來指出請求的主機名稱。</p><h3 id="If-Match"><a href="#If-Match" class="headerlink" title="If-Match"></a>If-Match</h3><p>像是以<code>If-</code>開頭的請求字串，皆為條件請求，伺服器接收到附帶條件請求後，只有判斷的條件為真才會執行請求。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">If-Match: &quot;12345&quot;</span><br></pre></td></tr></table></figure></p><p>這個字串會先告訴伺服器 ETag 值，當值與伺服器的相同才會執行請求，如果不同就會回傳 412 狀態碼。</p><p>還可以使用星號(*) 指定 If-Match 字串，這時候就會忽略 ETag 值，只要有資料就會進行處理。</p><h3 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h3><p>這個字串會告訴伺服器，如果 If-Modified-Since 的值早於資料更新的時間，就處理該請求，如果在此日期之後就回傳 304 狀態碼。</p><p>If-Modified-Since 是要確認代理與客戶端所有的本地資料的有效性，獲取資料更新的日期和時間可確認伺服端的 Last-Modified 字串。</p><h3 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h3><p>這個字串和 If-Match 的作用相反，ETag 值不一致才會處理該請求，在 Get 或 HEAD 方法中使用此字串就可以取得最新的資料。</p><h3 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h3><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">If-Range: &quot;132455&quot;</span><br></pre></td></tr></table></figure></p><p>這個字串告訴伺服器如果指定的 If-Range 值（可能是 ETag 或時間）和請求資料的 ETag 或時間相同，就做範圍請求處理，此時伺服端會回傳 Content-Range 及 Content-Length 字串，如果不是的話就回傳全部資料。</p><p>如果不使用 If-Range 的話，伺服器的資料如果更新，那客戶端手上有一部份的資料可能就會無效，這時候伺服端會回傳 412 狀態，目的是催促客戶端再次發送請求。</p><p>比較下來不使用 If-Range ，需要耗費兩倍時間。</p><h3 id="If-Modified-Since-1"><a href="#If-Modified-Since-1" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h3><p>此字串和 If-Modified-Since 相反，他的作用是告訴伺服器，指定的請求資料只能在值指定的時間後，且沒發生更新的狀況才能處理請求，如果在指定時間後發生更新，就以狀態碼 412 回傳。</p><h3 id="Max-Forwards"><a href="#Max-Forwards" class="headerlink" title="Max-Forwards"></a>Max-Forwards</h3><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Max-Forwards: 10</span><br></pre></td></tr></table></figure></p><p>藉由 Trace 或 option 方法，發送包含這個字串的請求時，這個字串以十進位整數的方式指定可經過伺服器最大數目，伺服器在轉發請求給下個伺服器前，會將 Max-Forwards 的值減一之後再重新賦值，當收到 Max-Forwards 的值為 0 後，就不再進行轉發請求。</p><p>需要這樣是因為當 HTTP 通訊的時候，請求可能會經過多台代理伺服器，如果這些代理伺服器因為某些原因而請求轉發失敗，客戶端就無從得知，所以必須通過此字串來追蹤請求。</p><h3 id="Proxy-Authorization"><a href="#Proxy-Authorization" class="headerlink" title="Proxy-Authorization"></a>Proxy-Authorization</h3><p>接到從代理伺服器的憑證，客戶端會發送此字串 Proxy-Authorization 的請求，以告知伺服器憑證所需要的資訊。</p><p>這個動作和客戶端與伺服器之間的 HTTP 訪問認證相似，但差別在這是發生在客戶端與代理之間。</p><h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p>對於要獲取部分資料的範圍請求，Range 可以告訴伺服器指定的範圍。</p><p>接收到 Range 字串請求的伺服器，會在處理請求後回傳 206 狀態碼，如果無法處理就會回傳所有資料及 200 狀態碼。</p><h3 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h3><p>這個字串是告訴伺服器原始資料的 URI。客戶端一般來說都會發送 Referer 字串，但直接在瀏覽器地址輸入 URI，基於安全也可以不發此字串。</p><p>因為原始資料的 URI 的查詢字串也可能含有 ID 和密碼等重要資訊，如果寫進 Referer 轉發給其他伺服器可能會造成保密訊息外洩。</p><h3 id="TE"><a href="#TE" class="headerlink" title="TE"></a>TE</h3><p>這個字串主要告知伺服器，客戶端能夠處理回應的傳輸編碼方式及優先順序，他和 Accept-Encoding 的功能很像，但是用在傳輸編碼。</p><p>除了指定編碼外，他還可以指定伴隨的 trailer 分快傳輸編碼的方式，應用後者只需要把 trailer 賦值給該字串。</p><h3 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h3><p>用於傳達瀏覽器種類，User-Agent 會建立請求瀏覽器和用戶代理等等訊息給伺服端。</p><p>如果由網路爬蟲請求，可能會在這個字串被加上爬蟲作者的電子郵件，如果請求經過代理，那也可能會被加上代理伺服器的名稱。</p><h2 id="響應首部字段"><a href="#響應首部字段" class="headerlink" title="響應首部字段"></a>響應首部字段</h2><p>回應 header 就是伺服端發送 http 訊息給客戶端所要補充的附加訊息。</p><h3 id="Accept-Ranges"><a href="#Accept-Ranges" class="headerlink" title="Accept-Ranges"></a>Accept-Ranges</h3><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Accept-Ranges: byte</span><br></pre></td></tr></table></figure></p><p>此字串是用來告知客戶端是用來告知客戶端是否能進行範圍請求，可處理的話，該值為 <code>byte</code> 不能處理的話該值為 <code>none</code>。</p><h3 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h3><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Age: 600</span><br></pre></td></tr></table></figure></p><p>這個字串可以告訴客戶端，來源伺服器在多久以前建立回應資料。<br>如果建立資料的是緩存伺服器，那麼 Age 值就是指緩存後的回應資料再發出認證到認證完成的時間值，另外代理伺服器如果建立回應資料，一定要加上此字串值。單位為秒。</p><h3 id="Etag"><a href="#Etag" class="headerlink" title="Etag"></a>Etag</h3><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Etag: &quot;82e24848424...&quot;</span><br></pre></td></tr></table></figure></p><p>這個字串可以告訴客戶端實體標記。他是一種把資料已字串形式作為一標記的方式，伺服器會為了每一份資料分配對應的 Etag。</p><p>而當資料更新時，Etag 也必須要更新，產生 Etag 並沒有固定的計算方法，只是由伺服端分配。</p><p>比方說，同個網站可能有中文版和英文版的資料，那他們都是用同個 URI 資料，這時候伺服端就只能依照 Etag 值給客戶端對應的資料。</p><h4 id="強-Etag-與弱-Tag"><a href="#強-Etag-與弱-Tag" class="headerlink" title="強 Etag 與弱 Tag"></a>強 Etag 與弱 Tag</h4><p>而在 Etag 中，有分強 Etag 與弱 Tag。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">E-tag: &quot;usagi-1234&quot;</span><br></pre></td></tr></table></figure></p><p>強 Etag，無論實體發生多細微的變化都會更改值。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">E-tag: &quot;W/usagi-1234&quot;</span><br></pre></td></tr></table></figure></p><p>弱 tag，只用來提示資料是否相同，只有資料發生根本的改變而產生差異才會改變 E-tag 值，這時候就會在前面加上<code>W/</code>。</p><h3 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h3><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Location: http://codingwife.com</span><br></pre></td></tr></table></figure></p><p>Location 可以將回應接收方引導到某個 URL 位置上的不同資料，基本上該字串會配合 <code>3xx: Redirection</code> 的回應來重新導向 URI。</p><p>幾乎所有瀏覽器在接收此字串的回應後，都會強制性嘗試訪問重新導向資料。</p><h3 id="Proxy-Authenticate"><a href="#Proxy-Authenticate" class="headerlink" title="Proxy-Authenticate"></a>Proxy-Authenticate</h3><p>這個字串會把代理伺服器所要求的認證訊息發送給客戶端。</p><p>這個和客戶端與伺服端之間在發送 HTTP 傳輸的模式類似，只不過這個對象換成客戶端與代理伺服器，而在認證時 <code>WWW-Authenticatea</code> 字串也會有一樣的作用。</p><h3 id="Retry-After"><a href="#Retry-After" class="headerlink" title="Retry-After"></a>Retry-After</h3><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Retry-After: 120</span><br></pre></td></tr></table></figure></p><p>這個字串告訴客戶端多久以後再次發送請求，主要是配合 503 或 3xx 狀態一起使用。值可以指定日期，或是建立回應資料後的秒數。</p><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>這個字串告訴客戶端目前伺服器上安裝的 HTTP 伺服器程式的訊息，除了軟體名稱外，還可能包括版本和安裝時的選項。</p><h3 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a>Vary</h3><p>這個字串可以對緩存進行控制，來源伺服器會向代理伺服器傳達關於本地緩存使用方法命令。</p><p>從代理伺服器接收到來源伺服器包含此字串的回應之後，如要再進行緩存，僅對請求含有相同 Vary 的請求回傳緩存。即使對相同資料發起請求，如果 Vary 值不相同，就要重新再從來源伺服器取得資料。</p><h3 id="WWW-Authenticate"><a href="#WWW-Authenticate" class="headerlink" title="WWW-Authenticate"></a>WWW-Authenticate</h3><p>此字串用於 HTTP 訪問，他會告訴客戶端適用於訪問請求 URI 指定資料的認證方案和帶參數提示的質詢。此字串會包含在回傳 401 狀態回應中。</p><h2 id="實體首部字段"><a href="#實體首部字段" class="headerlink" title="實體首部字段"></a>實體首部字段</h2><p>這是包含請求和回應訊息的實體部分，所用來補充內容或相關訊息的字串。</p><h3 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a>Allow</h3><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Allow: GET, HEAD</span><br></pre></td></tr></table></figure></p><p>此字串通知客戶端能夠支援的 Request-URI 指定資料的所有 HTTP 方法。</p><p>當伺服器收到不支援的 HTTP 方法，會回傳 405 狀態碼，除此之外還會把所有支援的 HTTP 方法寫進此字段。</p><h3 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h3><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure></p><p>此字串會告知客戶端伺服器對實體主體的部分選用的內容編碼，內容編碼就是在不遺失實體訊息的狀況下所做的壓縮。</p><p>主要採用以下四種編碼：</p><ul><li>gzip</li><li>compress</li><li>deflate</li><li>identity</li></ul><h3 id="Conten-Language"><a href="#Conten-Language" class="headerlink" title="Conten-Language"></a>Conten-Language</h3><p>此字串告訴客戶端，實體主體主要用的自然語言。</p><h3 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h3><p>此字串表明實體主體的大小（單位字節）。<br>對實體主體進行內容編碼傳輸時，就不能再用此字段，因為主體大小的計算方式比較複雜，詳細可參考 RFC2616 的 4.4。</p><h3 id="Content-Location"><a href="#Content-Location" class="headerlink" title="Content-Location"></a>Content-Location</h3><p>此字段給訊息主體相對應的 URI，與 Location 不同的點在於，此字串表示的是訊息主體回傳資料對應的 URI。</p><p>假設使用 Accept-Language 的伺服器發送請求，而回傳的頁面和實際請求的對象不同時，此字串就會寫明對應的 URI。</p><h3 id="Content-MD5"><a href="#Content-MD5" class="headerlink" title="Content-MD5"></a>Content-MD5</h3><p>此字串的值是由 MD5 算法生成的值，目的在用來檢查主體傳輸過程是否完整，以及再確認是否有傳送到。</p><p>對訊息主體執行 MD5 算法，得到會是 128 位元的二進制數字，再通過 Base 64 編碼後寫進此字段。因為 HTTP 字段沒辦法紀錄二進制值，所以需要通過 Base 64 編碼處理，而客戶端會再對訊息主體執行相同的 MD5 算法，比較過後就可以知道訊息的正確性。</p><p>這種做法的缺點是無法發現內容有偶發性的改變，或是否被惡意竄改。</p><h3 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h3><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Content-Range: bytes 5001-10000/10000</span><br></pre></td></tr></table></figure></p><p>此字串為針對範圍請求，回傳回應所使用，可以告訴客戶端回傳的實體哪個部分符合範圍請求，以字節為單位，表示當前發送部分及整個實體的大小。</p><h3 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h3><p>此字串說明了實體內的媒體類型，與 Accept 相同使用 type/subtype 的形式。</p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>這個字段會告訴客戶端資料的失效日期，緩存伺服器在接收此字串的回應之後，會以緩存來回覆此請求。在此字串值的時間以前，回傳的資料副本會一直留存，而當超過指定的時間後，緩存伺服器會轉向跟來源伺服器來請求有效資料。</p><p>來源伺服器不希望緩存伺服器對資料進行緩存時，最好在此字串內寫和 header 的 Date 一樣的時間，但是當 Cache-Control 有指定 max-age 時，比起此字串，他會先處理 max-age 的指令。</p><h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><p>此字串指定資料最後修改的時間，一般來說就是 Requst-URI 指定資料被修改的時間，但進行動態資料處理時，此字串可能會變成資料最後修改的時間。</p><h2 id="為-Cookie-所服務的首部字段"><a href="#為-Cookie-所服務的首部字段" class="headerlink" title="為 Cookie 所服務的首部字段"></a>為 Cookie 所服務的首部字段</h2><p>管理伺服器和客戶端之間狀態的 Cookie ，雖還沒有被 HTTP / 1.1 的 RFC2616 列為標準，但在一般網站已經有廣泛應用。</p><p>Cookie 的目的是為了用戶識別和狀態管理，網站為了管理客戶狀態，會透過瀏覽器把資料臨時寫到客戶端的電腦，而客戶端再訪問網站時，就可通過通訊方式取回之前發的 Cookie。</p><p>呼叫 Cookie 時，可以檢驗 Cookie 的有效期，以及發送端的網域、路徑等等訊息，所以標準的 Cookie 內的資料不會因來自其他網路和攻擊者的攻擊而洩漏。</p><p>Cookie 規格的標準文件有以下：</p><ul><li>網景公司發布的規格標準</li><li>RFC2109</li><li>RFC2965</li><li>RFC6265</li></ul><p>目前最常用的就是 RFC6265，所以接下來以此規格來說。</p><p>Cookie 有兩個字串：</p><ul><li>Set-Cookie：開始狀態管理所用的 Cookie 訊息。</li><li>Cookie：伺服端收到的 Cookie 訊息。</li></ul><h3 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h3><p>當伺服器開始管理客戶端的狀態，會事先告知各種訊息：<br>|屬性|說明|<br>|—|—|<br>|NAME=VALUE|賦予 Cookie 的名稱和值（必須）|<br>|expires=DATE|Cookie 的有效期（如果沒有指點，默認值就是以瀏覽器關閉為止）|<br>|path=PATH|伺服器上的文件目錄作為 Cookie 適用的物件（如果沒有指點，默認值就是以所在文件的文件目錄）|<br>|domain=域名|Cookie 適用物件的域名（如果沒有指點，默認值就是以創建 Cookie 的伺服器的域名）|<br>|Secure|僅在 HTTP 安全通訊才會發送 Cookie|<br>|HttpOnly|做限制，不能在 JavaScript 腳本訪問|</p><h4 id="expires-屬性"><a href="#expires-屬性" class="headerlink" title="expires 屬性"></a>expires 屬性</h4><ul><li>expires 可以發送 Cookie 的有效期</li><li>沒有指定，默認就是瀏覽器關閉之前</li><li>一旦 Cookie 從伺服器發送到客戶端，伺服器就不存在可以顯示刪除 Cookie 的方法，但可以通過覆蓋已經過期的 Cookie，一樣可以達到對於客戶端 Cookie 刪除的操作。</li></ul><h4 id="path-屬性"><a href="#path-屬性" class="headerlink" title="path 屬性"></a>path 屬性</h4><p>可用於限制指定 Cookie 的發送範圍的文件目錄，不過另外有方法可以避開這個限制。</p><h4 id="domain"><a href="#domain" class="headerlink" title="domain"></a>domain</h4><p>通過 Cookie 的 domain 屬性指定的域名可以做到結尾配對相同。<br>比方說指定 codingwife.com ，<a href="http://www.codingwife.com" target="_blank" rel="noopener">www.codingwife.com</a> 或 www2.codingwife.com 之類的都可以發送 Cookie。</p><p>除了指定多個域名發送 Cookie 之外，不指定 domain 更顯得安全。</p><h4 id="secure"><a href="#secure" class="headerlink" title="secure"></a>secure</h4><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Set-Cookie: name=value; secure</span><br></pre></td></tr></table></figure></p><p>Cookie 的 secure 僅在 HTTPS 或 SSL 安全連接時，才可會被發送到伺服器。</p><h4 id="HttpOnly"><a href="#HttpOnly" class="headerlink" title="HttpOnly"></a>HttpOnly</h4><p>這個屬性主要防止 cookie 的擴展功能，它讓 JavaScript 腳本沒辦法取得 Cookie，主要為了防止 XSS 攻擊對 Cookie 的竊取。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>此字串告訴伺服器，當客戶端想取得 HTTP 狀態管理支援時，就會從請求中包含從伺服器接收到的 Cookie。</p><h2 id="其他首部字段"><a href="#其他首部字段" class="headerlink" title="其他首部字段"></a>其他首部字段</h2><p>HTTP header 可以自行擴展，所以在瀏覽器上會出現一些非標準的字串，以下就幾種最常用的來做說明。</p><h3 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h3><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">X-Frame-Options: DENY</span><br></pre></td></tr></table></figure></p><p>此字串是回應 header，控制網站內容在其他網站的 Frame 標籤的顯示問題，主要為了防止點擊劫持。</p><p>以下有兩個可以指定的值：</p><ul><li>DENY：拒絕</li><li>SAMEORIGIN：僅同源域名下的頁面配對許可。<ul><li>舉例：如果指定 codingwife.com 頁面是 SAMEORIGIN，那麼 codingwife.com 下的 frame 都允許可載入該頁面，而其他域名就不行。</li></ul></li></ul><h3 id="X-XSS-Protection"><a href="#X-XSS-Protection" class="headerlink" title="X-XSS-Protection"></a>X-XSS-Protection</h3><p>此字串是回應 header，這是一個控制 XSS 對策的一個字串，用於控制瀏覽器 XSS 防護機制的開關。</p><ul><li>0：將 XSS 過濾設置成無效狀態</li><li>1：將 XSS 過濾設置成有效狀態</li></ul><h3 id="DNT"><a href="#DNT" class="headerlink" title="DNT"></a>DNT</h3><p>此字串是請求 header，意思是拒絕個人訊息被收集，表示拒絕被精準廣告追蹤的一種方法。</p><ul><li>0：同意被追蹤。</li><li>1：拒絕被追蹤。</li></ul><p>這個字串必須要有伺服端對應的支援。</p><h3 id="P3P"><a href="#P3P" class="headerlink" title="P3P"></a>P3P</h3><p>通過這個技術，可以讓網站上的個人隱私變成一種可以提供程式理解的形式，以保護用戶端隱私。</p><ol><li>建立 P3P 隱私</li><li>建立對照文件後，保存命名在 w3c/p3p.xml 中。</li><li>從 P3P 隱私中建立 Compact policies，輸出到 HTTP 回應中。<blockquote><p>資料來源：《圖解 HTTP》 上野宣 人民郵電出版社<br>筆記純屬推廣及分享，如有侵權，請告知。<br>Please advise to remove immediately if any infringement caused.</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 圖解 HTTP </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【讀書筆記】圖解 HTTP Chapter 05 與 HTTP 協作的網頁伺服器</title>
      <link href="/graphic-http-chapter05/"/>
      <url>/graphic-http-chapter05/</url>
      
        <content type="html"><![CDATA[<p>HTTP / 1.1 開始允許一台伺服器可以建立多個網頁站點。例如：提供網頁寄存服務的公司可以用一台伺服器幫多個客戶服務，以每個客戶持有的域名運作各自的網站，這是利用虛擬主機的關係。</p><p>在網路上域名通過 DNS 來進行域名解析，關聯到 IP 地址再訪問目標網站。如果一台伺服器寄存了兩個域名，當收到請求的時候就要知道需要訪問哪個域名。</p><p>在一樣 IP 地址下，由於虛擬主機可以寄存不同主機名和域名的 URI，在發送請求時，必須在 host 首部內完整指定主機名稱與 URI。</p><a id="more"></a><h2 id="用單台虛擬主機實作多個域名"><a href="#用單台虛擬主機實作多個域名" class="headerlink" title="用單台虛擬主機實作多個域名"></a>用單台虛擬主機實作多個域名</h2><p>HTTP / 1.1 開始允許一台伺服器可以建立多個網頁站點。例如：提供網頁寄存服務的公司可以用一台伺服器幫多個客戶服務，以每個客戶持有的域名運作各自的網站，這是利用虛擬主機的關係。</p><p>在網路上域名通過 DNS 來進行域名解析，關聯到 IP 地址再訪問目標網站。如果一台伺服器寄存了兩個域名，當收到請求的時候就要知道需要訪問哪個域名。</p><p>在一樣 IP 地址下，由於虛擬主機可以寄存不同主機名和域名的 URI，在發送請求時，必須在 host 首部內完整指定主機名稱與 URI。</p><h2 id="通訊資料轉發順序：代理、閘道、隧道"><a href="#通訊資料轉發順序：代理、閘道、隧道" class="headerlink" title="通訊資料轉發順序：代理、閘道、隧道"></a>通訊資料轉發順序：代理、閘道、隧道</h2><p>HTTP 通訊，除了客戶端和伺服端外，還有一些用於通訊資料轉發的程式，例如：代理、閘道、隧道。他們可以將請求轉發給通訊線路上的下一站伺服器，並可以接收從那台伺服器發送的回應再轉發給客戶端。</p><ul><li><p>代理<br>代理是處理轉發的一種程式，他算是伺服端與客戶端的中介站，接收客戶端的請求再轉發給伺服端，也接收伺服端的回應給客戶端。</p></li><li><p>閘道<br>轉發其他伺服器資料的伺服器，接收從客戶端發出的請求時，他就像擁有資料一樣對請求進行處理，有時候客戶端不會知道自己發出的對象是個閘道。</p></li><li><p>隧道<br>隧道是在隔很遠的客戶端和伺服器兩者的中間進行中轉，以保持通訊連接。</p></li></ul><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>代理在接收請求後轉發給其他的伺服器，代理不會改變請求的 URI，會直接轉發給前方持有資源的伺服器，而真正持有資源的伺服器叫做來源伺服器，再從來源伺服器回傳回應，經過代理伺服器再到客戶端。</p><p>每次經過代理伺服器轉發請求或回應，會追加 Via header 訊息來標示經過的主機訊息。在通訊的過程中，可以串連多台代理伺服器，請求和回應會像鍊子一樣被連接起來。</p><p>什麼時候要使用代理伺服器？利用緩存減少網路頻寬的流量，針對特定網站的請求控制等等。</p><p>代理有兩種方式，分為是否使用緩存跟是否修改訊息：</p><ul><li>緩存代理：代理轉發回應時，緩存代理會預先將資料緩存在代理伺服器上，當再接收請求時，就可以不用再對來源伺服器那邊取得資料，而是使用保留在代理伺服器上的資料當作回應回傳。</li><li>透明代理：轉發請求或回覆時，不對訊息做任何加工處理稱為透明代理，反之稱為非透明代理。</li></ul><h3 id="閘道"><a href="#閘道" class="headerlink" title="閘道"></a>閘道</h3><p>閘道和代理非常相似，而閘道可以提供通訊線路上非 HTTP 的服務，利用閘道可以提供通訊的安全性，因此可以在客戶端與閘道之間進行加密，例如閘道連接資料庫使用 SQL 語法來查詢資料，另外在購物網站上做信用卡結算時，閘道可以和信用卡系統做連動。</p><h3 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h3><p>隧道可以依照需求建立與其他伺服器的通訊線路，到時候可以用 SSL 加密進行通訊，隧道主要是能確保客戶端和伺服端進行安全的通訊，隧道不會去解析 HTTP 請求，也就是保持原本的請求中轉給伺服器，隧道會在雙方斷開連結的時候結束。</p><h2 id="保存資訊的緩存"><a href="#保存資訊的緩存" class="headerlink" title="保存資訊的緩存"></a>保存資訊的緩存</h2><p>緩存是指代理伺服器和客戶端本地硬碟保存的資料副本，利用緩存可以減少對來源伺服器的訪問，也就節省了流量和時間。</p><p>緩存伺服器是代理伺服器的一種，歸類在緩存代理中，意思就是說當代理轉發從伺服器的回應時，代理伺服器會保存一份資料的複製。</p><p>緩存伺服器可以利用緩存避免多次從來源伺服器轉發資料，因此客戶端可就近從緩存伺服器取得資料，而來源伺服器也不用多次處理相同請求。</p><h3 id="緩存的有效期限"><a href="#緩存的有效期限" class="headerlink" title="緩存的有效期限"></a>緩存的有效期限</h3><p>即使緩存伺服器裡面有緩存，也不能保證每次都會返回一樣的資料的請求，因為這關係到緩存資料的有效性。當來源伺服器上的資料更新，如果緩存還是一樣，那就會演變成回傳到舊資料。</p><p>即使有緩存，也會因為客戶端的要求、緩存等因素像來源伺服器確認資料的有效性，如果判斷緩存失效，就會再次向來源伺服器取得新資料。</p><h3 id="客戶端的緩存"><a href="#客戶端的緩存" class="headerlink" title="客戶端的緩存"></a>客戶端的緩存</h3><p>緩存可以存在伺服器，也可以存在客戶端的瀏覽器，如果瀏覽器有緩存就不需要再跟伺服器請求相同的資料，可以直接在本地端讀取，再來當判定緩存過期之後，會再跟來源伺服器確認資料的有效性，但判斷失效，瀏覽器會在請求資料。</p><h3 id="在-HTTP-以前的協議"><a href="#在-HTTP-以前的協議" class="headerlink" title="在 HTTP 以前的協議"></a>在 HTTP 以前的協議</h3><ul><li>FTP</li><li>NNTP</li><li>Archie</li><li>WAIS</li><li>Gopher</li></ul><blockquote><p>資料來源：《圖解 HTTP》 上野宣 人民郵電出版社<br>筆記純屬推廣及分享，如有侵權，請告知。<br>Please advise to remove immediately if any infringement caused.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 圖解 HTTP </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【讀書筆記】圖解 HTTP Chapter 04 返回結果的 HTTP 狀態碼</title>
      <link href="/graphic-http-chapter04/"/>
      <url>/graphic-http-chapter04/</url>
      
        <content type="html"><![CDATA[<p>狀態碼是當客戶端對伺服端發送請求後，伺服端敘述回傳請求結果的狀態，狀態碼為三位數字組成。</p><a id="more"></a><h2 id="狀態碼告知伺服端返回的請求結果"><a href="#狀態碼告知伺服端返回的請求結果" class="headerlink" title="狀態碼告知伺服端返回的請求結果"></a>狀態碼告知伺服端返回的請求結果</h2><p>狀態碼是當客戶端對伺服端發送請求後，伺服端敘述回傳請求結果的狀態，狀態碼為三位數字組成。</p><ul><li>1XX 訊息狀態：正在處理請求</li><li>2XX 成功狀態：請求正常處理完成</li><li>3XX 重新導向狀態：需要進行其他行為來完成請求動作</li><li>4XX 客戶端錯誤狀態：伺服器無法處理請求</li><li>5XX 伺服端錯誤狀態：伺服器處理請求中錯誤</li></ul><h2 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h2><h3 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h3><p>請求被正常處理。回傳的詳細訊息會根據方法不同而改變。</p><h3 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h3><p>請求成功，但無資料回傳。在回應的訊息內沒有 Body 的部分。</p><h3 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a>206 Partial Content</h3><p>表示客戶端做範圍請求，而伺服端成功回傳 GET 請求。回傳訊息包含 <code>Content-Range</code> 指定範圍 Body 部分。</p><h2 id="3XX-重新導向"><a href="#3XX-重新導向" class="headerlink" title="3XX 重新導向"></a>3XX 重新導向</h2><h3 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h3><p>永久重新導向，表示請求的資料已經被分配到新的 URI ，應該重新儲存新的 URI。</p><h3 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h3><p>臨時重新導向，表示已經被分配到新的 URI，希望這次能使用新的 URI 訪問。如果不為 GET 或 HEAD 請求，瀏覽器禁止重新導向，必須和客戶端確認是否重發請求。</p><h3 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h3><p>請求對應的資料存在另一個 URI，明確指明應該使用 GET 方法請求資料。</p><h3 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h3><p>表示客戶端發送附有條件的請求，伺服端允許被訪問，但沒被滿足條件。</p><h3 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h3><p>臨時重新導向，表示已經被分配到新的 URI，和 302 的差異是當收到狀態碼後，客戶端應保持請求方法不變向新的地址發出請求。</p><h2 id="4XX-客戶端錯誤"><a href="#4XX-客戶端錯誤" class="headerlink" title="4XX 客戶端錯誤"></a>4XX 客戶端錯誤</h2><h3 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h3><p>請求訊息有語法錯誤，需修正完後重新請求。</p><h3 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h3><p>發送的請求需要有 HTTP 認證，伺服器驗證已被拒絕。</p><blockquote><p>當網站（通常是網站域名）禁止 IP 位址時，有些網站狀態碼顯示的 401，表示該特定位址被拒絕存取網站。<br>—— wikipedia</p></blockquote><h3 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h3><p>伺服器拒絕請求訪問。</p><h3 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h3><p>無法找到請求資源。</p><h2 id="5XX-伺服端錯誤"><a href="#5XX-伺服端錯誤" class="headerlink" title="5XX 伺服端錯誤"></a>5XX 伺服端錯誤</h2><h3 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h3><p>伺服器在執行請求發生錯誤。</p><h3 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h3><p>伺服器超過負載或正在進行停機維護，無法處理請求。</p><blockquote><p>資料來源：《圖解 HTTP》 上野宣 人民郵電出版社<br>筆記純屬推廣及分享，如有侵權，請告知。<br>Please advise to remove immediately if any infringement caused.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 圖解 HTTP </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【讀書筆記】圖解 HTTP Chapter 03 HTTP 訊息內的 HTTP 訊息</title>
      <link href="/graphic-http-chapter03/"/>
      <url>/graphic-http-chapter03/</url>
      
        <content type="html"><![CDATA[<p>訊息分為兩部分，Header 跟 Body。</p><a id="more"></a><h2 id="HTTP-訊息"><a href="#HTTP-訊息" class="headerlink" title="HTTP 訊息"></a>HTTP 訊息</h2><p>訊息分為兩部分，Header 跟 Body。</p><h2 id="HTTP-請求訊息與回應訊息結構"><a href="#HTTP-請求訊息與回應訊息結構" class="headerlink" title="HTTP 請求訊息與回應訊息結構"></a>HTTP 請求訊息與回應訊息結構</h2><p>客戶端發送為請求訊息，伺服端有回應訊息。</p><p>請求訊息的 Header：</p><ul><li>請求列：包含請求方法，請求 URI 和 HTTP 協議版本。</li><li>請求 Header</li></ul><p>回應訊息的 Header：</p><ul><li>狀態列：回應結果的狀態碼，原因字串和 HTTP 協議版本。</li><li>回應 Header</li></ul><p>共同部分：</p><ul><li>通用 Header</li><li>實體 Header</li></ul><h2 id="編碼提升傳輸速率"><a href="#編碼提升傳輸速率" class="headerlink" title="編碼提升傳輸速率"></a>編碼提升傳輸速率</h2><p>HTTP 在傳輸資料可以直接傳輸或透過編碼來提升速率，透過編碼可以大量處理請求訪問，但編碼需要電腦來完成，因此會消耗更多效能。</p><h3 id="訊息主體和實體主體的差異"><a href="#訊息主體和實體主體的差異" class="headerlink" title="訊息主體和實體主體的差異"></a>訊息主體和實體主體的差異</h3><ul><li>訊息：HTTP 通訊的基本單位，以八位元組成。</li><li>實體：請求或回應的補充數據，內容是有 Header 和 Body 組成。</li></ul><h3 id="壓縮傳輸的內容編碼"><a href="#壓縮傳輸的內容編碼" class="headerlink" title="壓縮傳輸的內容編碼"></a>壓縮傳輸的內容編碼</h3><p>在發 email 需要夾帶檔案，我們會將其檔案壓縮。HTTP 協議中有一種被稱為內容編碼的功能，指名應用在實體內容的編碼格式，保持訊息原本的壓縮，伺服端內容編碼後，由客戶端接收並解碼。</p><p>常用的內容編碼：</p><ul><li>gzip</li><li>compress</li><li>deflate</li><li>identity</li></ul><h3 id="分割發送的分塊傳輸編碼"><a href="#分割發送的分塊傳輸編碼" class="headerlink" title="分割發送的分塊傳輸編碼"></a>分割發送的分塊傳輸編碼</h3><p>HTTP 協議在傳訊息的過程中，請求的資料還沒全部被傳送完，瀏覽器沒辦法顯示請求頁面。在傳送大容量資料的時候會把資料分割成多塊，這樣才能讓瀏覽器逐步顯示，稱之為分塊傳輸編碼。</p><p>分塊傳輸編碼會將 Body 分割成多塊，並以十六進制來標記大小，一樣由客戶端進行解碼恢復到原本檔案的樣子。</p><h2 id="發送多種資料的多物件集合"><a href="#發送多種資料的多物件集合" class="headerlink" title="發送多種資料的多物件集合"></a>發送多種資料的多物件集合</h2><p>發送郵件可以在郵件裡面寫文字和夾帶多個檔案，因為採用了 MIME 機制，允許郵件處理多個不同類型的檔案。比如圖片是使用 ASCII 碼的字串編碼標示，利用 MIME 來描述資料類型，而 MIME 會用一種多部分物件集合（multipart） 方法來容納不同類型的資料。</p><ul><li>multipart / form-data：在網頁表單文件上傳時使用。</li><li>multipart / byteranges：狀態碼 206，回應訊息的 Body 包含請求資料的數據區間。</li></ul><h2 id="獲取部分內容的範圍請求"><a href="#獲取部分內容的範圍請求" class="headerlink" title="獲取部分內容的範圍請求"></a>獲取部分內容的範圍請求</h2><p>以前如果下載一個大容量的圖片，只要被中斷了就要重新載入，為了解決這個問題需要一個可以恢復的機制，這種恢復機制是從上次的中斷點再開始恢復下載。</p><p>要實作這個需要指定下載的範圍，指定範圍發送的請求叫做範圍請求。</p><h2 id="內容協商回傳最適合的內容"><a href="#內容協商回傳最適合的內容" class="headerlink" title="內容協商回傳最適合的內容"></a>內容協商回傳最適合的內容</h2><p>一個網站可能存在很多相同內容的頁面，例如中英文版網站，以瀏覽器默認語言為主，訪問 URI 的網頁會顯示對應語言的頁面，這樣稱之為內容協商。</p><p>內容協商機制指客戶端和伺服端就回應的內容進行交涉，然後給客戶端最適合的資料，內容協商會以回應資源的語言、字串等等為判斷基準。</p><p>內容協商的技術有三種：</p><ul><li>伺服器驅動協商：以請求 header 為參考，篩選最好的內容。</li><li>客戶端驅動協商：從瀏覽器顯示的可選項中手動選擇。</li><li>透明協商：結合體。</li></ul><blockquote><p>資料來源：《圖解 HTTP》 上野宣 人民郵電出版社<br>筆記純屬推廣及分享，如有侵權，請告知。<br>Please advise to remove immediately if any infringement caused.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 圖解 HTTP </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【讀書筆記】圖解 HTTP Chapter 02 簡單的 HTTP 協議</title>
      <link href="/graphic-http-chapter02/"/>
      <url>/graphic-http-chapter02/</url>
      
        <content type="html"><![CDATA[<p>請求訪問文字或圖像等資料一端稱為客戶端；提供資料的一端稱為伺服器端。</p><a id="more"></a><h2 id="HTTP-協議用於客戶端和伺服端之間的通訊"><a href="#HTTP-協議用於客戶端和伺服端之間的通訊" class="headerlink" title="HTTP 協議用於客戶端和伺服端之間的通訊"></a>HTTP 協議用於客戶端和伺服端之間的通訊</h2><p>請求訪問文字或圖像等資料一端稱為客戶端；提供資料的一端稱為伺服器端。</p><h2 id="通過請求和回應的交換達成通訊"><a href="#通過請求和回應的交換達成通訊" class="headerlink" title="通過請求和回應的交換達成通訊"></a>通過請求和回應的交換達成通訊</h2><p>請求必定為客戶端發出，最後伺服器端回應資料，換言之，請求一定是客戶端率先發起，在那之前伺服器端不會有動作。</p><p>請求訊息的構成：</p><ul><li>請求方法：訪問伺服器的類型</li><li>請求 URI 字串：請求訪問的相關資料</li><li>HTTP/1.1：客戶端使用的 HTTP 協議。</li><li>請求 header</li><li>請求 body</li></ul><p>伺服器端的回應：</p><ul><li>協議版本</li><li>HTTP 狀態碼</li><li>狀態碼原因</li><li>回應 header</li><li>回應 body</li></ul><h2 id="HTTP-是無狀態協議"><a href="#HTTP-是無狀態協議" class="headerlink" title="HTTP 是無狀態協議"></a>HTTP 是無狀態協議</h2><p>HTTP 是無狀態協議，意思就是 HTTP 本身對於不對請求和回應的狀態做保留，也不做持久連接。</p><p>使用 HTTP 協議，每次有新的請求發送，就會有對應的回應，這樣是為了能更快速大量的處理資料，但如今也遇到了問題，假設我們在一個購物網站登入，我們會希望他在這個網站的其他頁面也保持登錄的狀態，因此引入了 Cookie 的技術。</p><h2 id="請求-URI-定位資源"><a href="#請求-URI-定位資源" class="headerlink" title="請求 URI 定位資源"></a>請求 URI 定位資源</h2><p>當客戶端使用 URI 發送請求，HTTP 也將請求的 URI 放入請求訊息中。<br>如果不是特別請求一個特定的資料，可以用 * 來替代請求 URI 。</p><h2 id="告知伺服器意圖的-HTTP-方法"><a href="#告知伺服器意圖的-HTTP-方法" class="headerlink" title="告知伺服器意圖的 HTTP 方法"></a>告知伺服器意圖的 HTTP 方法</h2><p>HTTP / 1.1 可使用的方法：<br>GET：獲取資料。請求展示指定資源，僅有請求資源。<br>POST：提交指定資源實體，通常會改變伺服器的狀態或副作用。<br>PUT：傳輸文件，文件存在請求訊息的 Body 中，傳送到指定的 URI 的位置。<br>DELETE：刪除文件，請求 URI 刪除特定的資源。<br>HEAD：與 GET 相同，但不回傳訊息 Body 的部分。<br>OPTION：查詢該 URI 支援的資料溝通方法。<br>TRACE：指定資源標明的伺服器之間，執行迴路返回測試。</p><p>發送請求時：會在 <code>Max-Forwards</code> 填入數值，每經過一個代理伺服器數值就<code>-1</code>，而剛好到 <code>0</code> 的時候就停止傳輸，最後接收到請求的伺服器就回傳 <code>200</code> 的 http code。<br>CONNECT：會利用請求資源與代理伺服器啟動一個雙向通訊。</p><h2 id="使用方法下達命令"><a href="#使用方法下達命令" class="headerlink" title="使用方法下達命令"></a>使用方法下達命令</h2><p>客戶端向 URI 發送請求，採用稱為方法的命令。</p><h2 id="持久連接節省通訊量"><a href="#持久連接節省通訊量" class="headerlink" title="持久連接節省通訊量"></a>持久連接節省通訊量</h2><p>在 HTTP 協議的初始版本中，每進行一次通訊就要斷開一次 TCP 連接，當時都是容量小的資料，但如今的狀況，這樣做十分消耗通訊成本。</p><h3 id="持久連接"><a href="#持久連接" class="headerlink" title="持久連接"></a>持久連接</h3><p>為了解決上述問題，HTTP / 1.1 和部分 HTTP / 1.0 想出了持久連接（HTTP persistent connection）的辦法，只要任何一端沒有提出要斷開連接，就保持 TCP 狀態。</p><p>如此減少了 TCP 重複建立和斷開的成本，減輕伺服器端的負擔，頁面的顯示也更加快速。</p><h3 id="管線化"><a href="#管線化" class="headerlink" title="管線化"></a>管線化</h3><p>以前的技術是每發出一個請求，需要接受到回應後，才能進行下一個請求，而管線化是將多個 HTTP 請求整批送出的技術，而在傳送過程中不需先等待伺服端的回應，可以在等待的過程中發出下一個請求。</p><h2 id="使用-Cookie-的狀態管理"><a href="#使用-Cookie-的狀態管理" class="headerlink" title="使用 Cookie 的狀態管理"></a>使用 Cookie 的狀態管理</h2><p>在提到 HTTP 是無狀態協議的時候有講到 Cookie ，Cookie 就是在請求和回應的訊息中寫入 Cookie 的訊息來控制客戶端的狀態。</p><ol><li>客戶端請求</li><li>伺服端會在發送回應訊息中 Header 的 <code>Set-Cookie</code> 欄位填入 Cookie 的訊息通知客戶端保存 Cookie 值。</li><li>客戶端再發送請求的時候會自動在請求訊息中的 Header 加入 Cookie 值。</li><li>伺服端發現客戶端送來的 Cookie 值，比對伺服器的紀錄，最後得到之前的狀態紀錄。</li></ol><blockquote><p>資料來源：《圖解 HTTP》 上野宣 人民郵電出版社<br>筆記純屬推廣及分享，如有侵權，請告知。<br>Please advise to remove immediately if any infringement caused.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 圖解 HTTP </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【讀書筆記】圖解 HTTP Chapter 01 了解 Web 及網路基礎</title>
      <link href="/graphic-http-chapter01/"/>
      <url>/graphic-http-chapter01/</url>
      
        <content type="html"><![CDATA[<p>當在網頁瀏覽器輸入網址之後，瀏覽器會向伺服器請求該網址的資源，並顯示網頁。發送請求取得伺服器資料的網頁瀏覽器，都可以稱為客戶端。</p><p>網頁是透過 HTTP 協議完成傳送資料的流程。</p><a id="more"></a><h2 id="使用-HTTP-協議訪問-Web"><a href="#使用-HTTP-協議訪問-Web" class="headerlink" title="使用 HTTP 協議訪問 Web"></a>使用 HTTP 協議訪問 Web</h2><p>當在網頁瀏覽器輸入網址之後，瀏覽器會向伺服器請求該網址的資源，並顯示網頁。發送請求取得伺服器資料的網頁瀏覽器，都可以稱為客戶端。</p><p>網頁是透過 HTTP 協議完成傳送資料的流程。</p><h2 id="HTTP-的誕生"><a href="#HTTP-的誕生" class="headerlink" title="HTTP 的誕生"></a>HTTP 的誕生</h2><ul><li>HTTP / 1.0：初期標準，現在仍然被廣泛使用。</li><li>HTTP / 1.1：目前主流的 HTTP 協議版本，主要是要解決文字傳輸的困難。</li></ul><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP / IP"></a>TCP / IP</h2><p>目前所使用的網路都是在 TCP / IP 協議的基礎上運作，而 HTTP 是屬於內部的一個子集。</p><h3 id="TCP-IP-協議"><a href="#TCP-IP-協議" class="headerlink" title="TCP / IP 協議"></a>TCP / IP 協議</h3><p>什麼是協議：電腦與網路要互相連接，必須要在連接前確定一些規則才能達成，像是使用哪種語言、如何偵測連結、如何結束等等，而這些規則就稱為協議。</p><p>TCP / IP 就是跟網路連接有關的所有協議的統稱。</p><p>有人認為 TCP / IP 是在說 TCP 協議與 IP 協議，也有人認為 TCP / IP 是在 IP 協議的連結過程中，所使用到的協議統稱。</p><h3 id="TCP-IP-分層管理"><a href="#TCP-IP-分層管理" class="headerlink" title="TCP / IP 分層管理"></a>TCP / IP 分層管理</h3><p>TCP / IP 分為四層：</p><ul><li>應用層：提供為應用軟體而設的埠，以設定與另一應用軟體之間的通訊。例如：HTTP、FTP、DNS 等等</li><li>傳輸層：提供兩台有網路連接的電腦之間的資料傳輸。當中有 TCP 和 UDP。</li><li>網路層：定義網路路由和地址，讓資料可以在網路之間傳遞，資料在傳輸時，協議會把 IP 地址加到傳輸資料內組成封包，又稱「IP 層」。</li><li>資料連結層：處理網路連接硬體的部分（MAC 地址也處於這層）。</li></ul><h3 id="TCP-IP-通訊傳輸流"><a href="#TCP-IP-通訊傳輸流" class="headerlink" title="TCP / IP 通訊傳輸流"></a>TCP / IP 通訊傳輸流</h3><p>兩台電腦在進行網路連接時，會通過分層的順序連接。發送端會從應用層逐步走到資料連結層，而接收端會從資料連結層向回走到應用層。</p><p>發送端在各層傳輸資料時，經過一層就會在該層增加一個 header 資料，接收端接受後每經過一層，就會消除一層，這樣分層的好處是當協議需要改變時，只要將有變動的那層替換就可以了。</p><h2 id="與-HTTP-關係密切的協議：IP、TCP-和-DNS"><a href="#與-HTTP-關係密切的協議：IP、TCP-和-DNS" class="headerlink" title="與 HTTP 關係密切的協議：IP、TCP 和 DNS"></a>與 HTTP 關係密切的協議：IP、TCP 和 DNS</h2><h3 id="負責傳輸的-IP-協議"><a href="#負責傳輸的-IP-協議" class="headerlink" title="負責傳輸的 IP 協議"></a>負責傳輸的 IP 協議</h3><p>有些人會把 IP 跟 IP 位址搞錯。</p><p>IP 協議的作用是把封包傳送給對方，這需要很多條件，其中重要的兩個條件是 IP 位置和 MAC 。</p><p>IP 位置是指節點被分配到的位置，而 MAC 是指網卡上獨特的序號，IP 位置可以跟 MAC 配對，IP 是不固定的，而 MAC 是網卡獨特的序號，是不會改變的。</p><p>IP 之間的連接是依賴 MAC 。</p><p>網路上兩台電腦的連接通常是藉由多台電腦和網路設備轉接，才連接到對方，而在連接時會利用下一站轉接設備的 MAC 來找到這個轉接的目標，這時候會使用 ARP 協議，ARP 協議是一種解析位置的協議，他會根據連接那端的 IP 位置來反查對應的 MAC。</p><p>在到達最後要連結到的目標之前，這中間過程的轉運站，通常叫做路由。</p><h3 id="確保可靠性的-TCP-協議"><a href="#確保可靠性的-TCP-協議" class="headerlink" title="確保可靠性的 TCP 協議"></a>確保可靠性的 TCP 協議</h3><p>為了方便管理，TCP 的功能是把資料流分割成適當長度的訊息段落，並且確認是否有把資料成功傳給對方。</p><p>TCP 協議採用了三向交握（three-way handshaking）策略，意思就是三次訊息的交換，當中會使用 TCP 的註記標誌——SYN、ACK。發送端會先送一個帶有 SYN 標記的封包給對方，接收端收到之後會發送一個帶有 SYN、ACK 標記的封包回去，最後發送端再送一個帶有 ACK 標記的封包，這樣表示訊息傳送完成。</p><h3 id="負責域名解析的-DNS-服務"><a href="#負責域名解析的-DNS-服務" class="headerlink" title="負責域名解析的 DNS 服務"></a>負責域名解析的 DNS 服務</h3><p>DNS 跟 HTTP 一樣在應用層，提供了域名到 IP 之間的解析服務。電腦既然可以有 IP 位置，也可以有主機名稱和域名。例如：<a href="http://www.codingwife.com。" target="_blank" rel="noopener">www.codingwife.com。</a></p><p>一般人在訪問別人的主機通常都是用域名，而不是 IP 位置，因為 IP 比較不符合一般人能記憶的模式。DNS 協議提供通過域名來查找 IP 位置，或是反向從 IP 位置來找域名。</p><h3 id="各協議與-HTTP-協議的關係"><a href="#各協議與-HTTP-協議的關係" class="headerlink" title="各協議與 HTTP 協議的關係"></a>各協議與 HTTP 協議的關係</h3><ul><li>客戶端：訪問 <a href="http://www.codingwife.com。" target="_blank" rel="noopener">www.codingwife.com。</a><ul><li>DNS：查找對應的 IP 位置</li></ul></li><li>發送到伺服器端<ul><li>HTTP：生對目標伺服器的 HTTP 請求訊息</li><li>TCP：把訊息分割成封包，確認每個封包都傳送給對方</li><li>IP：查找對方的位置，一邊轉運、一邊傳送。（路由器）</li><li>TCP：從對方那裡接收到封包並重組。</li><li>HTTP：對請求的內容進行處理。</li></ul></li></ul><p>請求的處理結果也是透過 TCP / IP 通訊協定回傳。</p><h2 id="URI-與-URL"><a href="#URI-與-URL" class="headerlink" title="URI 與 URL"></a>URI 與 URL</h2><p>URI（Uniform Resource Identifier）統一資源標識符。</p><p>以<code>https://codingwife.com/2018/10/16/2018ithome/day01/</code>為例：</p><p><code>https://</code>：協議名稱，Identifier 來表示定位標示符。<br><code>codingwife.com</code>：域名。<br><code>/2018/10/16/2018ithome/day01/</code>：路徑。</p><blockquote><p>資料來源：《圖解 HTTP》 上野宣 人民郵電出版社<br>筆記純屬推廣及分享，如有侵權，請告知。<br>Please advise to remove immediately if any infringement caused.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 圖解 HTTP </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS】Debounce and Throttle</title>
      <link href="/javascript-debounce-throttle/"/>
      <url>/javascript-debounce-throttle/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">* @param delay &#123;<span class="hljs-built_in">Number</span>&#125;  延遲時間，單位毫秒</span><br><span class="line">*</span><br><span class="line">* @<span class="hljs-keyword">return</span> &#123;<span class="hljs-built_in">Function</span>&#125;  <span class="hljs-keyword">return</span> 一個去彈跳的函數</span><br><span class="line">*<span class="hljs-regexp">/</span></span><br><span class="line"><span class="hljs-regexp">function debounce(fn, delay) &#123;</span></span><br><span class="line"><span class="hljs-regexp"></span></span><br><span class="line"><span class="hljs-regexp">  var timer /</span><span class="hljs-regexp">/ 接收一個 setTimeout 的 return 值</span></span><br><span class="line"><span class="hljs-regexp">  /</span><span class="hljs-regexp">/ 返回一个函数，这个函数会在一个时间区间结束后的 delay 毫秒时执行 fn 函数</span></span><br><span class="line"><span class="hljs-regexp">  return function (arguments) &#123;</span></span><br><span class="line"><span class="hljs-regexp"></span></span><br><span class="line"><span class="hljs-regexp">    var context = this /</span><span class="hljs-regexp">/ window</span></span><br><span class="line"><span class="hljs-regexp">    var args = arguments /</span><span class="hljs-regexp">/ event</span></span><br><span class="line"><span class="hljs-regexp">    /</span><span class="hljs-regexp">/ 每次这个返回的函数被调用，就清除定时器，以保证不执行 fn</span></span><br><span class="line"><span class="hljs-regexp">    clearTimeout(timer) /</span><span class="hljs-regexp">/ 清空 setTimeout</span></span><br><span class="line"><span class="hljs-regexp">    /</span><span class="hljs-regexp">/ 当返回的函数被最后一次调用后（也就是用户停止了某个连续的操作），</span></span><br><span class="line"><span class="hljs-regexp">    /</span><span class="hljs-regexp">/ 再过 delay 毫秒就执行 fn</span></span><br><span class="line"><span class="hljs-regexp">    timer = setTimeout(function () &#123;</span></span><br><span class="line"><span class="hljs-regexp">      fn.apply(context, args) /</span><span class="hljs-regexp">/指向初始環境（如果為 window 呼叫，把 function 的指向再轉回 window）</span></span><br><span class="line"><span class="hljs-regexp">    &#125;, delay)</span></span><br><span class="line"><span class="hljs-regexp">  &#125;</span></span><br><span class="line"><span class="hljs-regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * @param fn &#123;Function&#125;   實際執行的函式</span></span><br><span class="line"><span class="hljs-comment"> * @param delay &#123;Number&#125;  執行間隔</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * @return &#123;Function&#125;     return 的節流函數</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, threshhold</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// 记录上次执行的时间</span></span><br><span class="line">  <span class="hljs-keyword">var</span> last;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 定时器</span></span><br><span class="line">  <span class="hljs-keyword">var</span> timer;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 默认间隔为 250ms</span></span><br><span class="line">  threshhold || (threshhold = <span class="hljs-number">250</span>);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 返回的函数，每过 threshhold 毫秒就执行一次 fn 函数</span></span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// 保存函数调用时的上下文和参数，传递给 fn</span></span><br><span class="line">    <span class="hljs-keyword">var</span> context = <span class="hljs-keyword">this</span>;</span><br><span class="line">    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">var</span> now = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 如果距离上次执行 fn 函数的时间小于 threshhold，那么就放弃</span></span><br><span class="line">    <span class="hljs-comment">// 执行 fn，并重新计时</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (last &amp;&amp; now &lt; last + threshhold) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line"></span><br><span class="line">      <span class="hljs-comment">// 保证在当前时间区间结束后，再执行一次 fn</span></span><br><span class="line">      timer = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        last = now;</span><br><span class="line">        fn.apply(context, args);</span><br><span class="line">      &#125;, threshhold);</span><br><span class="line"></span><br><span class="line">      <span class="hljs-comment">// 在时间区间的最开始和到达指定间隔的时候执行一次 fn</span></span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      last = now;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Vue】如何優雅產生動態表單元件</title>
      <link href="/vue-dynamic-components/"/>
      <url>/vue-dynamic-components/</url>
      
        <content type="html"><![CDATA[<p>最近重構一下上個月趕的專案，還有很多地方可以加強優化，現在遇到第一個困難是如何減少 template 的重複性，簡單啊，用一下 v-for 就好了，但是遇到不同表單有各種形式的表現方式（selector、checkbox⋯⋯），我們勢必要使用不同種型態的子元件，但因為型態不同，資料結構就不同，那在這樣的狀況下，我們要如何去使用 v-for 呢？</p><a id="more"></a><blockquote><p>參考文章<br><a href="https://juejin.im/post/5b14a9b46fb9a01e780a4323" target="_blank" rel="noopener">[译]如何优雅地用 Vue 创建数据驱动的用户界面</a> &gt; <a href="https://codesandbox.io/s/61y919wrk3?from-embed" target="_blank" rel="noopener">vue-dynamic-components(codesandbox)</a></p></blockquote><p>強者我朋友花王就貼給我一篇文章，不看還好，看了一下一鳴驚人，完全沒看過這種寫法，接下來根據上面 codesandbox 的連結來討論動態表單元件的運行過程，以 Demo4 為例。</p><p>我們先看一下 <code>DemoFour.vue</code> ， 他在父元件裡面訂了一個 <code>schema</code> 的陣列。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">schema: [</span><br><span class="line">  ...</span><br><span class="line">  &#123;</span><br><span class="line">    fieldType: <span class="hljs-string">"TextInput"</span>,</span><br><span class="line">    placeholder: <span class="hljs-string">"First Name"</span>,</span><br><span class="line">    label: <span class="hljs-string">"First Name"</span>,</span><br><span class="line">    name: <span class="hljs-string">"firstName"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">component</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(field, index) in schema"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">:key</span>=<span class="hljs-string">"index"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">:is</span>=<span class="hljs-string">"field.fieldType"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">v-model</span>=<span class="hljs-string">"formData[field.name]"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">v-bind</span>=<span class="hljs-string">"field"</span></span></span><br><span class="line"><span class="hljs-tag">&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="判斷輸入類型"><a href="#判斷輸入類型" class="headerlink" title="判斷輸入類型"></a>判斷輸入類型</h2><p><img src="/img/vue/vue-dynamic-components/dynamic-01.png" alt></p><p>裡面有不同的物件型態，必要的物件屬性為 <code>fieldType</code>、<code>label</code>及<code>name</code>。<br>fieldType 就是不同 input 的型態判別，例如 selector、 checkbox⋯⋯</p><p>我們使用 <code>v-for</code> 來跑 <code>schema</code> 的物件 現在遇到的第一個問題，明明沒有在 component 定義，那這個 component tag 是從哪出來的，根據 <a href="https://cn.vuejs.org/v2/guide/components.html#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6" target="_blank" rel="noopener">Vue 動態元件</a>的官方說明，我們可以知道那是搭配 <code>is</code> 屬性所使用，<code>is</code> 根據 <code>schema</code> 的 <code>fieldType</code> 來判斷要產生哪個形態的子元件。</p><h2 id="解構賦值繫結至子元件"><a href="#解構賦值繫結至子元件" class="headerlink" title="解構賦值繫結至子元件"></a>解構賦值繫結至子元件</h2><p><img src="/img/vue/vue-dynamic-components/dynamic-02.png" alt></p><p>這邊的 <code>v-bind</code> 使用了解構賦值，被 <code>v-bind</code> 的 component 會以 <code>props</code> 的方式傳值傳進子元件，接下來我們來看看子元件。</p><h2 id="接收-props-及-v-model-的-value"><a href="#接收-props-及-v-model-的-value" class="headerlink" title="接收 props 及 v-model 的 value"></a>接收 props 及 v-model 的 value</h2><p><img src="/img/vue/vue-dynamic-components/dynamic-03.png" alt></p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="line">  name: <span class="hljs-string">'TextInput'</span>,</span><br><span class="line">  props: [<span class="hljs-string">'placeholder'</span>, <span class="hljs-string">'label'</span>, <span class="hljs-string">'name'</span>, <span class="hljs-string">'value'</span>],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>我們傳進了<code>placeholder</code>、<code>label</code>、<code>name</code>、<code>value</code>，疑？value？我們什麼時候傳進了 value ？ 因為我們的父元件有 <code>v-model</code>，<code>v-model</code> 不外乎就是 <code>v-on:input</code> 和 <code>v-bind:value</code>，所以也是 <code>v-bind</code> 解構賦值到子元件，如果綁到空的屬性，<code>value</code> 就會是 undefined，接下來我們看一下 template 。</p><p><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="line"><span class="hljs-tag">      <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span></span></span><br><span class="line"><span class="hljs-tag">      <span class="hljs-attr">:name</span>=<span class="hljs-string">"name"</span></span></span><br><span class="line"><span class="hljs-tag">      <span class="hljs-attr">:value</span>=<span class="hljs-string">"value"</span></span></span><br><span class="line"><span class="hljs-tag">      @<span class="hljs-attr">input</span>=<span class="hljs-string">"$emit('input',$event.target.value)"</span></span></span><br><span class="line"><span class="hljs-tag">      <span class="hljs-attr">:placeholder</span>=<span class="hljs-string">"placeholder</span></span></span><br><span class="line"><span class="hljs-tag"><span class="hljs-string">           "</span></span></span><br><span class="line"><span class="hljs-tag">    /&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="使用者行為修改值"><a href="#使用者行為修改值" class="headerlink" title="使用者行為修改值"></a>使用者行為修改值</h2><p><img src="/img/vue/vue-dynamic-components/dynamic-04.png" alt><br>把 props 傳進來的資料依序綁在 input 上，而我們在父元件 <code>v-model</code> 的資料可以讓 value 變成 input 的預設的輸入文字，當使用者修改文字時，被 <code>v-bind:value</code> 會被修改，且同時 <code>v-on:input</code> 和 <code>emit</code> 通知父元件使用者已經修改資料，但是在父元件裡面我們並沒有接收到任何從 <code>emit</code> 自定義的變數來的事件，那他是如何接收？</p><h2 id="newValue-覆蓋舊-value"><a href="#newValue-覆蓋舊-value" class="headerlink" title="newValue 覆蓋舊 value"></a>newValue 覆蓋舊 value</h2><p><img src="/img/vue/vue-dynamic-components/dynamic-05.png" alt></p><p>其實就是 <code>v-model</code> ，因為 <code>v-model</code> 其實就是 <code>v-bind:value</code>，自然而然 <code>$event.target.value</code> 覆蓋了原本<code>v-model</code>的舊值，而 <code>v-model</code> 又跟 <code>formData</code>綁定。</p><p><strong>另外需要注意，formData 的 屬性值要和 schema 物件的 name 相同，否則沒辦法綁定在一起。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS】原型繼承 Prototype</title>
      <link href="/javascript-prototype/"/>
      <url>/javascript-prototype/</url>
      
        <content type="html"><![CDATA[<p>當我們每次在 console 會看到 javascript 物件底下有個 <code>__proto__</code>，那到底是什麼呢？</p><a id="more"></a><h2 id="先淺談一下建構式"><a href="#先淺談一下建構式" class="headerlink" title="先淺談一下建構式"></a>先淺談一下建構式</h2><p>這是一個點的建構式，有 <code>x</code>、<code>y</code> 的座標，以及一個 <code>position</code> 的 function，我們用建構式先建立兩個 instance。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Point</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.x = <span class="hljs-number">100</span>;</span><br><span class="line">  <span class="hljs-keyword">this</span>.y = <span class="hljs-number">99</span>;</span><br><span class="line">  <span class="hljs-keyword">this</span>.position = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.x, <span class="hljs-keyword">this</span>.y);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">const</span> redPoint = <span class="hljs-keyword">new</span> Point();</span><br><span class="line"><span class="hljs-keyword">const</span> bluePoint = <span class="hljs-keyword">new</span> Point();</span><br></pre></td></tr></table></figure></p><p>接下來我們來對其中一個物件做改變。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">redPoint.x++;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(redPoint);</span><br><span class="line"><span class="hljs-comment">// Point &#123;x: 101, y: 99, position: ƒ&#125;</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(bluePoint);</span><br><span class="line"><span class="hljs-comment">// Point &#123;x: 100, y: 99, position: ƒ&#125;</span></span><br></pre></td></tr></table></figure></p><p><img src="/img/prototype/prototype-01.png" alt></p><p>從上述可以證實兩個物件是獨立的，互不影響，因此他們的狀態可以圖解為上。</p><h2 id="試看看替建構式加上-prototype"><a href="#試看看替建構式加上-prototype" class="headerlink" title="試看看替建構式加上 prototype"></a>試看看替建構式加上 prototype</h2><p>我們把建構式的 function 移除，把他改成 prototype。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Point</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.x = <span class="hljs-number">100</span>;</span><br><span class="line">  <span class="hljs-keyword">this</span>.y = <span class="hljs-number">99</span>;</span><br><span class="line">  <span class="hljs-comment">// this.position = function ()&#123;</span></span><br><span class="line">  <span class="hljs-comment">//   console.log(this.x,this.y);</span></span><br><span class="line">  <span class="hljs-comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">Point.prototype.position = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.x, <span class="hljs-keyword">this</span>.y);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">const</span> redPoint = <span class="hljs-keyword">new</span> Point();</span><br><span class="line"><span class="hljs-keyword">const</span> bluePoint = <span class="hljs-keyword">new</span> Point();</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(redPoint);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(bluePoint);</span><br></pre></td></tr></table></figure></p><p>omg，會發現我們的 function 不見了，打開 <code>console</code>。</p><p><img src="/img/prototype/prototype-02.png" alt></p><p>會發現他在 <code>__proto__</code> 裡面，這中間到底發生什麼事了。</p><p><img src="/img/prototype/prototype-03.png" alt></p><p>我們可以知道，當我們要建立 instance 的時候，他的屬性等等 blabla 會參照建構式，所以 instance 的 <code>__proto__</code> 也會參照建構式的 <code>prototype</code>。</p><p>那既然會參照建構式，那 function 還可以正常執行嗎？</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">redPoint.position();</span><br><span class="line"><span class="hljs-comment">// 100 99</span></span><br></pre></td></tr></table></figure></p><p>可以正常執行，我現在想知道 <code>redPosition</code> 這個物件是不是真的有這些屬性。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">redPoint.hasOwnProperty(<span class="hljs-string">'x'</span>);</span><br><span class="line">redPoint.hasOwnProperty(<span class="hljs-string">'y'</span>);</span><br><span class="line">redPoint.hasOwnProperty(<span class="hljs-string">'position'</span>);</span><br><span class="line"><span class="hljs-comment">//true</span></span><br><span class="line"><span class="hljs-comment">//true</span></span><br><span class="line"><span class="hljs-comment">//false</span></span><br></pre></td></tr></table></figure></p><p>為什麼 <code>position</code> 是 false ！？ 他明明就可以執行。</p><p><img src="/img/prototype/prototype-05.png" alt></p><p>原來 js 在呼叫屬性的時候，先在屬性找，找不到，就向上找 <code>__proto__</code> ，<code>__proto__</code>是連結到建構式的 prototype，就找到 position 執行。</p><p>但是我們在 <code>__proto__</code> 裡面還看到一個 <code>__proto__</code>，打開來看看：</p><p><img src="/img/prototype/prototype-04.png" alt></p><p>會發現裡面都是我們平時在操縱物件的原生方法，原來我們平常操縱物件的方法都在裡面，因此我們可以理解成這樣。</p><p><img src="/img/prototype/prototype-06.png" alt></p><p>wowww，一切都說得通了，為什麼我們建立 javascript 物件會有 <code>__proto__</code> ，原來那是 javascript 的原型練，所有物件的方法都在裡面，而且物件的 prototype 永遠都保持在最上層。</p><h2 id="建構式的繼承"><a href="#建構式的繼承" class="headerlink" title="建構式的繼承"></a>建構式的繼承</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Tire</span>(<span class="hljs-params"></span>) </span>&#123;&#125;</span><br><span class="line">Tire.prototype = &#123;</span><br><span class="line">  print() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">'我是輪胎'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Car</span>(<span class="hljs-params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Car.prototype = <span class="hljs-built_in">Object</span>.create(Tire.prototype);</span><br><span class="line">Car.prototype.print = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-string">'我是車'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">RedCar</span>(<span class="hljs-params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">RedCar.prototype = <span class="hljs-built_in">Object</span>.create(Car.prototype);</span><br><span class="line">RedCar.prototype.print = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-string">'我是紅色的車'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> michilin = <span class="hljs-keyword">new</span> Tire();</span><br><span class="line"><span class="hljs-keyword">const</span> honda = <span class="hljs-keyword">new</span> Car();</span><br><span class="line"><span class="hljs-keyword">const</span> redHonda = <span class="hljs-keyword">new</span> RedCar();</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(michilin.print());</span><br><span class="line"><span class="hljs-comment">// 我是輪胎</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(honda.print());</span><br><span class="line"><span class="hljs-comment">// 我是車</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(redHonda.print());</span><br><span class="line"><span class="hljs-comment">// 我是紅車</span></span><br></pre></td></tr></table></figure></p><p>現在有三個建構式，輪胎、車，跟紅車，輪胎繼承在車上，車繼承在紅色車子上，上面各自有可以印出他是什麼的 function，他們再分別建構出了：米其林、宏打、紅宏打。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Tire</span>(<span class="hljs-params"></span>) </span>&#123;&#125;</span><br><span class="line">Tire.prototype = &#123;</span><br><span class="line">  print() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">'我是輪胎'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Car</span>(<span class="hljs-params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Car.prototype = <span class="hljs-built_in">Object</span>.create(Tire.prototype);</span><br><span class="line">Car.prototype.print = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-string">'我是車'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">RedCar</span>(<span class="hljs-params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">RedCar.prototype = <span class="hljs-built_in">Object</span>.create(Car.prototype);</span><br><span class="line"><span class="hljs-comment">// RedCar.prototype.print = function()&#123;</span></span><br><span class="line"><span class="hljs-comment">//   return '我是紅色的車'</span></span><br><span class="line"><span class="hljs-comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> michilin = <span class="hljs-keyword">new</span> Tire();</span><br><span class="line"><span class="hljs-keyword">const</span> honda = <span class="hljs-keyword">new</span> Car();</span><br><span class="line"><span class="hljs-keyword">const</span> redHonda = <span class="hljs-keyword">new</span> RedCar();</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// console.log(michilin.print())</span></span><br><span class="line"><span class="hljs-comment">// console.log(honda.print())</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(redHonda.print());</span><br></pre></td></tr></table></figure></p><p>今天我把紅宏打的 function 註解掉，他現在應該印不出東西來了。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(redHonda.print());</span><br><span class="line"><span class="hljs-comment">// 我是車</span></span><br></pre></td></tr></table></figure></p><p>但是他最後還是有執行，印出了<code>我是車</code>，代表他繼承了車的 function。</p><p><img src="/img/prototype/prototype-07.png" alt></p><h3 id="物件的繼承"><a href="#物件的繼承" class="headerlink" title="物件的繼承"></a>物件的繼承</h3><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> water = &#123;</span><br><span class="line">  printName() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">'我是水'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">let</span> bottle = &#123;</span><br><span class="line">  printMaterial() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">'塑膠'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.dir(bottle);</span><br></pre></td></tr></table></figure></p><p><code>console.dir</code> 可以印出物件的屬性。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> water = &#123;</span><br><span class="line">  printName() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">'我是水'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">let</span> bottle = &#123;</span><br><span class="line">  printMaterial() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">'塑膠'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">Object</span>.setPrototypeOf(bottle, water);</span><br><span class="line"><span class="hljs-built_in">console</span>.dir(bottle);</span><br><span class="line"><span class="hljs-built_in">console</span>.dir(bottle.printName());</span><br></pre></td></tr></table></figure></p><p><img src="/img/prototype/prototype-08.png" alt></p><p>這邊我們可以看到水瓶繼承了水的屬性，所以水瓶可以用水的 function，印出來是<code>我是水</code>。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> water = &#123;</span><br><span class="line">  printName() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">'我是水'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">let</span> bottle = &#123;</span><br><span class="line">  printName() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">'我是水瓶'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">Object</span>.setPrototypeOf(bottle, water);</span><br><span class="line"><span class="hljs-built_in">console</span>.dir(bottle.printName());</span><br></pre></td></tr></table></figure></p><p>如果我們把<code>printMaterial</code>改成<code>printName</code>，它理所當然印出<code>我是水瓶</code>。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> water = &#123;</span><br><span class="line">  printName() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">'我是水'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">let</span> bottle = &#123;</span><br><span class="line">  printName() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-keyword">super</span>.printName()&#125;</span> ---水瓶`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">Object</span>.setPrototypeOf(bottle, water);</span><br><span class="line"><span class="hljs-built_in">console</span>.dir(bottle.printName());</span><br></pre></td></tr></table></figure></p><p>但是我們在 <code>bottle</code> 裡面使用 <code>super</code> ，他可以繼承原型的屬性，所以他印出了<code>我是水</code>，但也印出了<code>---水瓶</code>，證明他呼叫的是 <code>bottle</code> 的 <code>printName</code>。</p><p>javascript ES6 有出 <code>class</code> 的建構式語法糖，有興趣的可以再去看看，感謝大家。</p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS】事件循環 Event-loop</title>
      <link href="/javascript-event-loop/"/>
      <url>/javascript-event-loop/</url>
      
        <content type="html"><![CDATA[<p>javascript 身為一個單線程語言，我們必須了解他在運行事件的方法是如何，才能避免一些值在錯誤的時機出現。</p><a id="more"></a><blockquote><p>程式碼擷取自 <a href="https://2014.jsconf.eu/speakers/philip-roberts-what-the-heck-is-the-event-loop-anyway.html" target="_blank" rel="noopener">Philip Roberts: What the heck is the event loop anyway?</a></p></blockquote><p>在了解事件循環前，必須先瞭解幾個專有名詞。</p><h2 id="單線程-single-threaded"><a href="#單線程-single-threaded" class="headerlink" title="單線程 single threaded"></a>單線程 single threaded</h2><p>意味同一時間，只能做一件事。在 javascript 裡面，則是會依據順序堆疊（stack）執行，而且一次只能執行一段程式碼。</p><h2 id="stack-堆疊"><a href="#stack-堆疊" class="headerlink" title="stack 堆疊"></a>stack 堆疊</h2><p>執行堆疊，javascript 為單線程，因此在進入函式中執行程式碼，該函式會被加在堆疊最上方，直到函式執行完成後被抽離堆疊，下方程式碼為堆疊範例。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multiply</span>(<span class="hljs-params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span>(<span class="hljs-params">n</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> multiply(n, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printSquare</span>(<span class="hljs-params">n</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">let</span> squared = square(n);</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(squared);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printSquare(<span class="hljs-number">4</span>);</span><br></pre></td></tr></table></figure></p><h2 id="無窮迴圈"><a href="#無窮迴圈" class="headerlink" title="無窮迴圈"></a>無窮迴圈</h2><p>如果執行無窮迴圈，堆疊會不斷增加到瀏覽器出現錯誤為止。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></p><h2 id="Blocking-阻塞"><a href="#Blocking-阻塞" class="headerlink" title="Blocking 阻塞"></a>Blocking 阻塞</h2><p>當瀏覽器進行同步請求，在等待期間的狀態，就稱為 <strong>blocking</strong>，blocking 狀態會使瀏覽器形成假死狀態，所有動作無法運行，因此為了避免 blocking 的狀況，所以一般使用非同步請求，關於同步與非同步，請看<a href="https://developer.mozilla.org/zh-TW/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests" target="_blank" rel="noopener">此</a> 。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hi'</span>);</span><br><span class="line"></span><br><span class="line">$.<span class="hljs-keyword">get</span>('url', function cb(data) &#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'JSConfEU'</span>);</span><br></pre></td></tr></table></figure></p><h2 id="task-queue-任務佇列"><a href="#task-queue-任務佇列" class="headerlink" title="task queue 任務佇列"></a>task queue 任務佇列</h2><p>在取得 web api 的結果後，瀏覽器會將回呼函式推進一個等待的地方，就是任務佇列（task queue ）。等瀏覽器執行完 stack 的程式，便會開始讀取任務佇列的回呼函式，讀取完成之後便會開始執行，再讀取下一個回呼。</p><h2 id="非同步的事件循環"><a href="#非同步的事件循環" class="headerlink" title="非同步的事件循環"></a>非同步的事件循環</h2><p>其實重點在任務佇列的部分已經說完了，就是瀏覽器必須等主任務（stack）執行完後，再開始讀取任務佇列並執行回呼函式，稱為事件循環。</p><h3 id="範例一：執行順序為-h1-→-setTimeout（非同步）-→-JSConfEU-→-there"><a href="#範例一：執行順序為-h1-→-setTimeout（非同步）-→-JSConfEU-→-there" class="headerlink" title="範例一：執行順序為 h1 → setTimeout（非同步） → JSConfEU → there"></a>範例一：執行順序為 h1 → setTimeout（非同步） → JSConfEU → there</h3><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hi'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'there'</span>);</span><br><span class="line">&#125;, <span class="hljs-number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'JSConfEU'</span>);</span><br></pre></td></tr></table></figure></p><h3 id="範例二：執行順序為"><a href="#範例二：執行順序為" class="headerlink" title="範例二：執行順序為"></a>範例二：執行順序為</h3><p>setTimeout（非同步） → 接回結果，放入佇列 →<br>setTimeout（非同步） → 接回結果，放入佇列 →<br>setTimeout（非同步） → 接回結果，放入佇列 →<br>setTimeout（非同步） → 接回結果，放入佇列 →</p><p>讀取<code>timeout();</code>，執行 →<code>console.log(&#39;hi&#39;)</code>，<br>讀取<code>timeout();</code>，執行 →<code>console.log(&#39;hi&#39;)</code>，<br>讀取<code>timeout();</code>，執行 →<code>console.log(&#39;hi&#39;)</code>，<br>讀取<code>timeout();</code>，執行 →<code>console.log(&#39;hi&#39;)</code>，<br>結束。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timeout</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hi'</span>);</span><br><span class="line">&#125;, <span class="hljs-number">1000</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timeout</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hi'</span>);</span><br><span class="line">&#125;, <span class="hljs-number">1000</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timeout</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hi'</span>);</span><br><span class="line">&#125;, <span class="hljs-number">1000</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timeout</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hi'</span>);</span><br><span class="line">&#125;, <span class="hljs-number">1000</span>);</span><br></pre></td></tr></table></figure></p><p>其他可以參考講者寫的一個<a href="http://latentflip.com/loupe/?code=ZnVuY3Rpb24gbXVsdGlwbHkoYSwgYikgewogIHJldHVybiBhICogYgp9CgpmdW5jdGlvbiBzcXVhcmUobikgewogIHJldHVybiBtdWx0aXBseShuLCBuKQp9CgpmdW5jdGlvbiBwcmludFNxdWFyZShuKSB7CiAgdmFyIHNxdWFyZWQgPSBzcXVhcmUobikKICBjb25zb2xlLmxvZyhzcXVhcmVkKQp9CgpwcmludFNxdWFyZSg0KTs%3D!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D" target="_blank" rel="noopener">事件循環模擬器</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CSS】nth-child 與 nth-of-type</title>
      <link href="/css-child-of-type/"/>
      <url>/css-child-of-type/</url>
      
        <content type="html"><![CDATA[<p>早上聽到旁邊的同學在討論這個問題，有時候會遇到使用<code>nth-child</code>沒反應的狀況，如今是該釐清的時候了。</p><a id="more"></a><p><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ul01"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ul02"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>span1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>span2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><figure class="highlight css hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-selector-class">.container</span> <span class="hljs-selector-tag">ul</span><span class="hljs-selector-pseudo">:nth-child(2)</span> &#123;</span><br><span class="line">  <span class="hljs-attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>現在有一段程式碼，原本我預期的狀況<code>ul02</code>會吃到底色，因為我選擇的是<code>container</code>下第二個<code>ul</code>，但吃到底色的<code>ul01</code>。<br>為什麼呢？因為<code>nth-child</code>在數 DOM 元素的時候不看 tag ，意思就是他在數元素的時候不會幫你過濾元素 type 。</p><p>假設我們將 CSS 選擇器更改為 <code>.container ul:nth-child(1)</code>，會發現沒有元素吃到 CSS，因為他選擇的是<code>container</code>下的第一個元素，而且必須為<code>ul</code>。<br>換句話說在<code>container</code>下的第一個元素如果不是<code>ul</code>，他就不會吃到 CSS， 在<code>container</code>下第一個元素是<code>h2</code>，所以他不會吃到 CSS ，如果你希望選擇<code>container</code>下第一個<code>ul</code>，必須使用<code>.container ul:nth-of-type(1)</code>。</p><p>對於後代選擇器使用<code>nth-child</code>也有一個很特殊的發現，如果選擇器更改為<code>.container :nth-child(2)</code>或<code>.container *:nth-child(2)</code>，你會發現從<code>container</code>開始各階層下的第二個元素都會被選擇到。<br>如果更改為<code>.container *:nth-of-type(2)</code>，各元素類型的第二個選擇器會被選擇到。</p><p>這邊要注意的是，<code>of-type</code>選擇器會以元素類型做區隔，而<code>nth-child</code>會計算到所有元素。</p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Github】不開 branch 使用 github page</title>
      <link href="/github-doc/"/>
      <url>/github-doc/</url>
      
        <content type="html"><![CDATA[<p>突然發現一個可以不用開 branch ，但也能使用 github page 的方法，<br>因為最近都在研究 Vue ，所以以 Vue 的專案來做講解。</p><a id="more"></a><p>假設我們現在已經把專案完成了，現在要用 webpack 來產出檔案，在那之前我們先改一下 webpack 的設定。</p><p>如果你的專案是使用<code>vue cli 2.9</code>的版本，那你在<code>config/index.js</code>下更改就可以了，其他專案就在 webpack build 的設定下更改就好。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><br><span class="line">  build: &#123;</span><br><span class="line">    <span class="hljs-comment">// Template for index.html</span></span><br><span class="line">    index: path.resolve(__dirname, <span class="hljs-string">'../docs/index.html'</span>),</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Paths</span></span><br><span class="line">    assetsRoot: path.resolve(__dirname, <span class="hljs-string">'../docs'</span>),</span><br><span class="line">    assetsSubDirectory: <span class="hljs-string">'static'</span>,</span><br><span class="line">    assetsPublicPath: <span class="hljs-string">'./'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>把<code>dist</code>更改為<code>docs</code>，把<code>assetsPublicPath</code>的設定更改為<code>./</code>。</p><p>如此一來產出的資料夾就為<code>docs</code>，<code>assetsPublicPath</code>正常來說應該更改成<code>/</code>就可以，可是在 webpack 產出的<code>index.html</code>會有錯誤，<code>index.html</code>引用的路徑會變為<code>/static/..</code>，<code>index.html</code>會無法正確讀取到檔案，再來就是在 repo settings 的 github pages 更改為<code>master branch / docs folder</code> 就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30】Day30：Whack A Mole Game</title>
      <link href="/javascript-30-day30/"/>
      <url>/javascript-30-day30/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://javascript30.com/" target="_blank" rel="noopener">javascript 30day</a></p></blockquote><a id="more"></a><h3 id="目標：做一個打地鼠的小遊戲"><a href="#目標：做一個打地鼠的小遊戲" class="headerlink" title="目標：做一個打地鼠的小遊戲"></a><span style="color:#ff5900">目標：做一個打地鼠的小遊戲</span></h3><h2 id="一、抓取頁面元素及命名變數"><a href="#一、抓取頁面元素及命名變數" class="headerlink" title="一、抓取頁面元素及命名變數"></a>一、抓取頁面元素及命名變數</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> holes = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'.hole'</span>);</span><br><span class="line"><span class="hljs-comment">// 洞</span></span><br><span class="line"><span class="hljs-keyword">const</span> scoreBoard = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.score'</span>);</span><br><span class="line"><span class="hljs-comment">// 分數顯示</span></span><br><span class="line"><span class="hljs-keyword">const</span> moles = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'.mole'</span>);</span><br><span class="line"><span class="hljs-comment">// 地鼠</span></span><br><span class="line"><span class="hljs-keyword">let</span> lastHole;</span><br><span class="line"><span class="hljs-comment">// 最後一次出現的地洞</span></span><br><span class="line"><span class="hljs-keyword">let</span> timeUP = <span class="hljs-literal">false</span>;</span><br><span class="line"><span class="hljs-comment">// 結束遊戲時間</span></span><br><span class="line"><span class="hljs-keyword">let</span> score = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-comment">// 分數</span></span><br></pre></td></tr></table></figure></p><h2 id="二、亂數選擇地鼠出沒的洞"><a href="#二、亂數選擇地鼠出沒的洞" class="headerlink" title="二、亂數選擇地鼠出沒的洞"></a>二、亂數選擇地鼠出沒的洞</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randomTime</span>(<span class="hljs-params">min, max</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.round(<span class="hljs-built_in">Math</span>.random() * (max - min) + min);</span><br><span class="line">  <span class="hljs-comment">// 產生一個小數點後四捨五入的亂數時間區間</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randomHole</span>(<span class="hljs-params">holes</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// 亂數產生地洞</span></span><br><span class="line">  <span class="hljs-keyword">const</span> idx = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * holes.length);</span><br><span class="line">  <span class="hljs-comment">// 亂數取得地洞</span></span><br><span class="line">  <span class="hljs-keyword">const</span> hole = holes[idx];</span><br><span class="line">  <span class="hljs-comment">// 賦予 DOM</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (hole === lastHole) &#123;</span><br><span class="line">    <span class="hljs-comment">// 避免亂數重複</span></span><br><span class="line">    <span class="hljs-keyword">return</span> randomHole(holes);</span><br><span class="line">  &#125;</span><br><span class="line">  lastHole = hole;</span><br><span class="line">  <span class="hljs-comment">// 紀錄最後出現的地洞</span></span><br><span class="line">  <span class="hljs-keyword">return</span> hole;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="三、地鼠出沒"><a href="#三、地鼠出沒" class="headerlink" title="三、地鼠出沒"></a>三、地鼠出沒</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">peep</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// 地鼠出現</span></span><br><span class="line">  <span class="hljs-keyword">const</span> time = randomTime(<span class="hljs-number">200</span>, <span class="hljs-number">1000</span>);</span><br><span class="line">  <span class="hljs-comment">// 取得出現的時間</span></span><br><span class="line">  <span class="hljs-keyword">const</span> hole = randomHole(holes);</span><br><span class="line">  <span class="hljs-comment">// 取得出現的地洞</span></span><br><span class="line">  hole.classList.add(<span class="hljs-string">'up'</span>);</span><br><span class="line">  <span class="hljs-comment">// 加上 class 出現 css 動畫效果</span></span><br><span class="line">  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span><br><span class="line">    hole.classList.remove(<span class="hljs-string">'up'</span>);</span><br><span class="line">    <span class="hljs-comment">// 時間到移除 css 動畫</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (!timeUp) peep();</span><br><span class="line">    <span class="hljs-comment">// 遊戲時間未結束 跑出下一隻地鼠</span></span><br><span class="line">  &#125;, time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="四、遊戲開始及打擊地鼠"><a href="#四、遊戲開始及打擊地鼠" class="headerlink" title="四、遊戲開始及打擊地鼠"></a>四、遊戲開始及打擊地鼠</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startGame</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  timeUp = <span class="hljs-literal">false</span>;</span><br><span class="line">  <span class="hljs-comment">// 時間重置</span></span><br><span class="line">  scoreBoard.textContent = <span class="hljs-number">0</span>;</span><br><span class="line">  score = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-comment">// 分數表初始化</span></span><br><span class="line"></span><br><span class="line">  peep();</span><br><span class="line">  <span class="hljs-comment">// 執行地鼠出現</span></span><br><span class="line">  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (timeUp = <span class="hljs-literal">true</span>), <span class="hljs-number">10000</span>);</span><br><span class="line">  <span class="hljs-comment">// 十秒後時間結束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bonk</span>(<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (!e.isTrusted) <span class="hljs-keyword">return</span>;</span><br><span class="line">  <span class="hljs-comment">// 防止腳本操作</span></span><br><span class="line">  score++;</span><br><span class="line">  <span class="hljs-comment">// 加分</span></span><br><span class="line">  <span class="hljs-keyword">this</span>.classList.remove(<span class="hljs-string">'up'</span>);</span><br><span class="line">  <span class="hljs-comment">// 移除 css 動畫</span></span><br><span class="line">  scoreBoard.textContent = score;</span><br><span class="line">  <span class="hljs-comment">// 更新分數</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">moles.forEach(<span class="hljs-function"><span class="hljs-params">mole</span> =&gt;</span> mole.addEventListener(<span class="hljs-string">'click'</span>, bonk));</span><br><span class="line"><span class="hljs-comment">//監聽每隻地鼠綁定 bonk 函式</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS30系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ES6】 let、const</title>
      <link href="/javascript-es6-let-const/"/>
      <url>/javascript-es6-let-const/</url>
      
        <content type="html"><![CDATA[<p>之前其實就有發過相關的文章，可是因為 github 沒有上傳 source code 結果被我弄爆了，這次挑精簡的寫重點，詳細的可以 google ，很多大神都有寫相關的文章。</p><a id="more"></a><h2 id="變數宣告"><a href="#變數宣告" class="headerlink" title="變數宣告"></a>變數宣告</h2><p>在 javascript 裡面命令宣告不外乎就是<code>var</code>、<code>let</code>、<code>const</code>。</p><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><ul><li>函式作用域</li><li>變數提升</li></ul><h4 id="函式作用域"><a href="#函式作用域" class="headerlink" title="函式作用域"></a>函式作用域</h4><p><code>var</code>為函式作用域，就是以函式當作變數是否有效的界線，這樣無疑會造成許多全域變數的產生。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hi'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(i);</span><br><span class="line"><span class="hljs-comment">// hi</span></span><br><span class="line"><span class="hljs-comment">// hi</span></span><br><span class="line"><span class="hljs-comment">// hi</span></span><br><span class="line"><span class="hljs-comment">// 10</span></span><br></pre></td></tr></table></figure></p><p>會得到這種迴圈體外可以存取得到變數<code>i</code>的現象，因為函式作用域的關係，導致<code>i</code>變成全域變數。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> a = [];</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="hljs-number">6</span>](); <span class="hljs-comment">// 10</span></span><br></pre></td></tr></table></figure></p><p>承上範例，因為<code>i</code>為全域變數，導致不管在迴圈體內輸入的<code>i</code>值為多少，輸出的<code>console.log</code>仍然為<code>10</code>。</p><h4 id="變數提升"><a href="#變數提升" class="headerlink" title="變數提升"></a>變數提升</h4><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(abc); <span class="hljs-comment">// undefined</span></span><br><span class="line"><span class="hljs-keyword">var</span> abc = <span class="hljs-number">10</span>;</span><br></pre></td></tr></table></figure></p><p><code>var</code>會發生變數提升的現象，在變數宣告前使用變數，輸出值為<code>undefined</code>。</p><h3 id="let、const"><a href="#let、const" class="headerlink" title="let、const"></a>let、const</h3><ul><li>區塊作用域</li><li>變數提升</li><li>不可重複宣告</li><li>減少 IIFE 的應用</li></ul><h4 id="區塊作用域"><a href="#區塊作用域" class="headerlink" title="區塊作用域"></a>區塊作用域</h4><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;</span><br><span class="line">  <span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(a);</span><br><span class="line"><span class="hljs-comment">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure></p><p>區塊作用域顧名思義變數僅在區塊內有效。</p><h3 id="變數提升-1"><a href="#變數提升-1" class="headerlink" title="變數提升"></a>變數提升</h3><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(b);</span><br><span class="line"><span class="hljs-keyword">let</span> b = <span class="hljs-number">10</span>;</span><br><span class="line"><span class="hljs-comment">// ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure></p><p>因為報錯的關係，許多人以為<code>let</code>和<code>const</code>不會做變數提升，事實上仍然會，只是因為 ES6 為了避免執行錯誤，將變數移至暫時性死區。<br>暫時性死區的定義是，在變數宣告前使用變數，所使用的變數仍然存在，但是不可使用，只有等到宣告變數後，才可以使用該變數。</p><h3 id="不可重複宣告"><a href="#不可重複宣告" class="headerlink" title="不可重複宣告"></a>不可重複宣告</h3><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;</span><br><span class="line">  <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Uncaught SyntaxError: Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure></p><p>不允許在相同作用域裡面，重複宣告同一個變數。</p><h3 id="減少-IIFE-的應用"><a href="#減少-IIFE-的應用" class="headerlink" title="減少 IIFE 的應用"></a>減少 IIFE 的應用</h3><p><strong>IIFE</strong></p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> tmp = <span class="hljs-number">1</span>;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(tmp);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="hljs-comment">// 1</span></span><br></pre></td></tr></table></figure></p><p><strong>區塊作用域</strong></p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="hljs-keyword">let</span> tmp = <span class="hljs-number">2</span>;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 2</span></span><br></pre></td></tr></table></figure></p><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul><li>變數宣告</li><li>迴圈循環重新綁定</li></ul><h4 id="變數宣告-1"><a href="#變數宣告-1" class="headerlink" title="變數宣告"></a>變數宣告</h4><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;</span><br><span class="line">a = a + <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(a);</span><br><span class="line"><span class="hljs-comment">// 11</span></span><br></pre></td></tr></table></figure></p><p><code>let</code>為變數宣告，可重複指定，用法類似於<code>var</code>。</p><h4 id="迴圈循環重新綁定"><a href="#迴圈循環重新綁定" class="headerlink" title="迴圈循環重新綁定"></a>迴圈循環重新綁定</h4><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> a = [];</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="hljs-number">6</span>](); <span class="hljs-comment">// 6</span></span><br></pre></td></tr></table></figure></p><p>因為區塊作用域的關係，<code>i</code>只在迴圈體內有效，每次遍歷都是重新綁定的變數，javascript 引擎內部會記住上一輪迴圈的數值，基於上一輪的計算，初始化本輪的變數<code>i</code>。</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ul><li>常數宣告</li><li>不可重複指定</li></ul><h4 id="常數宣告"><a href="#常數宣告" class="headerlink" title="常數宣告"></a>常數宣告</h4><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> a;</span><br><span class="line"><span class="hljs-comment">// Uncaught SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure></p><p><code>const</code>是針對常數做的定義，在常數做宣告時，必定要賦予值。</p><h4 id="不可重新指定"><a href="#不可重新指定" class="headerlink" title="不可重新指定"></a>不可重新指定</h4><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> a = <span class="hljs-number">10</span>;</span><br><span class="line">a = <span class="hljs-number">11</span>;</span><br><span class="line"><span class="hljs-comment">// Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure></p><p>不可重新指定的意思是不可用等號運算子做指定運算，如上所示，但宣告一個常數，不表示為不可改變。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> b = &#123;&#125;;</span><br><span class="line">b.obj = <span class="hljs-number">123</span>;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(b);</span><br><span class="line"><span class="hljs-comment">//&#123;obj: 123&#125;</span></span><br></pre></td></tr></table></figure></p><p>如果宣告的常數像是物件、陣列，都是屬於<code>by reference</code>，因此不會產生錯誤。</p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30】Day29：Countdown Timer</title>
      <link href="/javascript-30-day29/"/>
      <url>/javascript-30-day29/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://javascript30.com/" target="_blank" rel="noopener">javascript 30day</a></p></blockquote><a id="more"></a><h3 id="目標：點擊及輸入數值倒數計時"><a href="#目標：點擊及輸入數值倒數計時" class="headerlink" title="目標：點擊及輸入數值倒數計時"></a><span style="color:#ff5900">目標：點擊及輸入數值倒數計時</span></h3><h2 id="一、命名變數"><a href="#一、命名變數" class="headerlink" title="一、命名變數"></a>一、命名變數</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> countdown;</span><br><span class="line"><span class="hljs-comment">// 計數器</span></span><br><span class="line"><span class="hljs-keyword">const</span> timerDisplay = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.display__time-left'</span>);</span><br><span class="line"><span class="hljs-comment">// 頁面元素：顯示倒數</span></span><br><span class="line"><span class="hljs-keyword">const</span> endTime = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.display__end-time'</span>);</span><br><span class="line"><span class="hljs-comment">// 頁面元素：顯示計數後的時間</span></span><br><span class="line"><span class="hljs-keyword">const</span> buttons = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'[data-time]'</span>);</span><br><span class="line"><span class="hljs-comment">// 計數時間按鈕</span></span><br></pre></td></tr></table></figure></p><h2 id="二、設定計數器"><a href="#二、設定計數器" class="headerlink" title="二、設定計數器"></a>二、設定計數器</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timer</span>(<span class="hljs-params">seconds</span>) </span>&#123;</span><br><span class="line">  clearInterval(countdown);</span><br><span class="line">  <span class="hljs-comment">// 重啟計數器，清除原本計數的設定</span></span><br><span class="line">  <span class="hljs-keyword">const</span> now = <span class="hljs-built_in">Date</span>.now();</span><br><span class="line">  <span class="hljs-keyword">const</span> then = now + seconds * <span class="hljs-number">1000</span>;</span><br><span class="line">  <span class="hljs-comment">// 取得時間</span></span><br><span class="line">  displayTimeLeft(seconds);</span><br><span class="line">  displayEndTime(then);</span><br><span class="line">  <span class="hljs-comment">// 秀出開始倒數計時的時間與結束倒數後的時間</span></span><br><span class="line"></span><br><span class="line">  countdown = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-comment">// 每秒更新一次計數器</span></span><br><span class="line">    <span class="hljs-keyword">const</span> secondsLeft = <span class="hljs-built_in">Math</span>.round((then - <span class="hljs-built_in">Date</span>.now()) / <span class="hljs-number">1000</span>);</span><br><span class="line">    <span class="hljs-comment">// 要倒數的總時</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (secondsLeft &lt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">      clearInterval(countdown);</span><br><span class="line">      <span class="hljs-keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// 時間小於零，結束 setInterval</span></span><br><span class="line">    displayTimeLeft(secondsLeft);</span><br><span class="line">    <span class="hljs-comment">// 更新秀出時間</span></span><br><span class="line">  &#125;, <span class="hljs-number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayTimeLeft</span>(<span class="hljs-params">seconds</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">const</span> minutes = <span class="hljs-built_in">Math</span>.floor(seconds / <span class="hljs-number">60</span>);</span><br><span class="line">  <span class="hljs-comment">// 轉換分鐘數</span></span><br><span class="line">  <span class="hljs-keyword">const</span> remainderSeconds = seconds % <span class="hljs-number">60</span>;</span><br><span class="line">  <span class="hljs-comment">// 用 % 取得扣除分鐘數的秒數</span></span><br><span class="line">  <span class="hljs-keyword">const</span> display = <span class="hljs-string">`<span class="hljs-subst">$&#123;minutes&#125;</span>:<span class="hljs-subst">$&#123;remainderSeconds &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">'0'</span> : <span class="hljs-string">''</span>&#125;</span><span class="hljs-subst">$&#123;remainderSeconds&#125;</span>`</span>;</span><br><span class="line">  <span class="hljs-comment">// 顯示秒數，若秒數小於10，在個位數前面補零</span></span><br><span class="line">  <span class="hljs-built_in">document</span>.title = display;</span><br><span class="line">  timerDisplay.textContent = display;</span><br><span class="line">  <span class="hljs-comment">// 顯示對應時間</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayEndTime</span>(<span class="hljs-params">timestamp</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// 顯示結束時間</span></span><br><span class="line">  <span class="hljs-keyword">const</span> end = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(timestamp);</span><br><span class="line">  <span class="hljs-comment">// 取得結束的時間</span></span><br><span class="line">  <span class="hljs-keyword">const</span> hour = end.getHours();</span><br><span class="line">  <span class="hljs-comment">// 轉換成小時</span></span><br><span class="line">  <span class="hljs-keyword">const</span> adjustedHour = hour &gt; <span class="hljs-number">12</span> ? hour - <span class="hljs-number">12</span> : hour;</span><br><span class="line">  <span class="hljs-comment">// 將24小時制轉換成12小時制</span></span><br><span class="line">  <span class="hljs-keyword">const</span> minutes = end.getMinutes();</span><br><span class="line">  <span class="hljs-comment">// 取得分鐘</span></span><br><span class="line">  endTime.textContent = <span class="hljs-string">`Be Back At <span class="hljs-subst">$&#123;adjustedHour&#125;</span>:<span class="hljs-subst">$&#123;minutes &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">'0'</span> : <span class="hljs-string">''</span>&#125;</span><span class="hljs-subst">$&#123;minutes&#125;</span>`</span>;</span><br><span class="line">  <span class="hljs-comment">// 顯示結束的時間</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="三、設定固定倒數時間的按鈕及設定輸入倒數時間"><a href="#三、設定固定倒數時間的按鈕及設定輸入倒數時間" class="headerlink" title="三、設定固定倒數時間的按鈕及設定輸入倒數時間"></a>三、設定固定倒數時間的按鈕及設定輸入倒數時間</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startTimer</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">const</span> seconds = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">this</span>.dataset.time);</span><br><span class="line">  <span class="hljs-comment">// 取得 data-time 的數值</span></span><br><span class="line">  timer(seconds);</span><br><span class="line">  <span class="hljs-comment">// 傳入計數器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buttons.forEach(<span class="hljs-function"><span class="hljs-params">button</span> =&gt;</span> button.addEventListener(<span class="hljs-string">'click'</span>, startTimer));</span><br><span class="line"><span class="hljs-comment">// 遍歷按鈕並加上監聽事件</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">document</span>.customForm.addEventListener(<span class="hljs-string">'submit'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  <span class="hljs-comment">// 取消 submit 跳頁的預設</span></span><br><span class="line">  <span class="hljs-keyword">const</span> mins = <span class="hljs-keyword">this</span>.minutes.value;</span><br><span class="line">  <span class="hljs-comment">// 取得 input 的分鐘數值</span></span><br><span class="line">  timer(mins * <span class="hljs-number">60</span>);</span><br><span class="line">  <span class="hljs-comment">// 轉換成秒數傳回計數器</span></span><br><span class="line">  <span class="hljs-keyword">this</span>.reset();</span><br><span class="line">  <span class="hljs-comment">// 傳回後清空 input</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS30系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30】Day28：Video Speed Controller</title>
      <link href="/javascript-30-day28/"/>
      <url>/javascript-30-day28/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://javascript30.com/" target="_blank" rel="noopener">javascript 30day</a></p></blockquote><a id="more"></a><h3 id="目標：滑鼠事件監聽調整速度"><a href="#目標：滑鼠事件監聽調整速度" class="headerlink" title="目標：滑鼠事件監聽調整速度"></a><span style="color:#ff5900">目標：滑鼠事件監聽調整速度</span></h3><p>與<a href="/_posts/javascript/js30/day11.md">第 11 天</a>的練習類似。</p><h2 id="一、命名變數"><a href="#一、命名變數" class="headerlink" title="一、命名變數"></a>一、命名變數</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> speed = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.speed'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> bar = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.speed-bar'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> video = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.flex'</span>);</span><br></pre></td></tr></table></figure></p><h2 id="二、監聽事件"><a href="#二、監聽事件" class="headerlink" title="二、監聽事件"></a>二、監聽事件</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">speed.addEventListener(<span class="hljs-string">'mousemove'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// 滑鼠移動事件</span></span><br><span class="line">  <span class="hljs-keyword">const</span> y = e.pageY - <span class="hljs-keyword">this</span>.offsetTop;</span><br><span class="line">  <span class="hljs-comment">// 觸發位置 = 滑鼠距離整頁頂端的 y 軸位置 - 速率條到整個頁面頂端的距離</span></span><br><span class="line">  <span class="hljs-keyword">const</span> percent = y / <span class="hljs-keyword">this</span>.offsetHeight;</span><br><span class="line">  <span class="hljs-comment">// 百分比 = 觸發位置 / 速率條的高度</span></span><br><span class="line">  <span class="hljs-keyword">const</span> min = <span class="hljs-number">0.4</span>;</span><br><span class="line">  <span class="hljs-keyword">const</span> max = <span class="hljs-number">4</span>;</span><br><span class="line">  <span class="hljs-keyword">const</span> height = <span class="hljs-built_in">Math</span>.round(percent * <span class="hljs-number">100</span>) + <span class="hljs-string">'%'</span>;</span><br><span class="line">  <span class="hljs-comment">// 四捨五入百分百</span></span><br><span class="line">  <span class="hljs-keyword">const</span> playbackRate = percent * (max - min) + min;</span><br><span class="line">  <span class="hljs-comment">// 計算播放速率比例</span></span><br><span class="line">  bar.textContent = playbackRate.toFixed(<span class="hljs-number">2</span>) + <span class="hljs-string">'x'</span>;</span><br><span class="line">  <span class="hljs-comment">// 使用 toFixed 顯示小數點後兩位的速率文字</span></span><br><span class="line">  bar.style.height = height;</span><br><span class="line">  <span class="hljs-comment">// 顯示樣式</span></span><br><span class="line">  video.playbackRate = playbackRate;</span><br><span class="line">  <span class="hljs-comment">// 更改影片速率</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS30系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30】Day27：Click and Drag to Scroll</title>
      <link href="/javascript-30-day27/"/>
      <url>/javascript-30-day27/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://javascript30.com/" target="_blank" rel="noopener">javascript 30day</a></p></blockquote><a id="more"></a><h3 id="目標：點擊及拖曳使畫面滑動"><a href="#目標：點擊及拖曳使畫面滑動" class="headerlink" title="目標：點擊及拖曳使畫面滑動"></a><span style="color:#ff5900">目標：點擊及拖曳使畫面滑動</span></h3><h2 id="一、命名變數"><a href="#一、命名變數" class="headerlink" title="一、命名變數"></a>一、命名變數</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> slider = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.items'</span>);</span><br><span class="line"><span class="hljs-comment">// 頁面元素</span></span><br><span class="line"><span class="hljs-keyword">let</span> isDown = <span class="hljs-literal">false</span>;</span><br><span class="line"><span class="hljs-comment">// 狀態變數</span></span><br><span class="line"><span class="hljs-keyword">let</span> startX;</span><br><span class="line"><span class="hljs-keyword">let</span> scrollLeft;</span><br></pre></td></tr></table></figure></p><h2 id="二、監聽事件"><a href="#二、監聽事件" class="headerlink" title="二、監聽事件"></a>二、監聽事件</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">slider.addEventListener(<span class="hljs-string">'mousedown'</span>, () =&gt; &#123;&#125;);</span><br><span class="line">slider.addEventListener(<span class="hljs-string">'mouseleave'</span>, () =&gt; &#123;&#125;);</span><br><span class="line">slider.addEventListener(<span class="hljs-string">'mouseup'</span>, () =&gt; &#123;&#125;);</span><br><span class="line">slider.addEventListener(<span class="hljs-string">'mousemove'</span>, () =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure></p><p>分別有滑鼠按下、滑鼠離開、滑鼠放開，及滑鼠拖曳的動作。</p><h2 id="三、滑鼠按下事件"><a href="#三、滑鼠按下事件" class="headerlink" title="三、滑鼠按下事件"></a>三、滑鼠按下事件</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">slider.addEventListener(<span class="hljs-string">'mousedown'</span>, e =&gt; &#123;</span><br><span class="line">  isDown = <span class="hljs-literal">true</span>;</span><br><span class="line">  <span class="hljs-comment">// 狀態變數啟用</span></span><br><span class="line">  slider.classList.add(<span class="hljs-string">'active'</span>);</span><br><span class="line">  <span class="hljs-comment">// 增加樣式</span></span><br><span class="line">  startX = e.pageX - slider.offsetLeft;</span><br><span class="line">  <span class="hljs-comment">// 按下的起始位置 = 頁面位置 - 目前 item 的左邊距離</span></span><br><span class="line">  scrollLeft = slider.scrollLeft;</span><br><span class="line">  <span class="hljs-comment">// 紀錄移動的距離量</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="四、滑鼠滑動事件"><a href="#四、滑鼠滑動事件" class="headerlink" title="四、滑鼠滑動事件"></a>四、滑鼠滑動事件</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">slider.addEventListener(<span class="hljs-string">'mousemove'</span>, e =&gt; &#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (!isDown) <span class="hljs-keyword">return</span>;</span><br><span class="line">  <span class="hljs-comment">// 假設非按下滑動，就不執行</span></span><br><span class="line">  e.preventDefault();</span><br><span class="line">  <span class="hljs-comment">// 取消預設行為，如反白文字之類的</span></span><br><span class="line">  <span class="hljs-keyword">const</span> x = e.pageX - slider.offsetLeft;</span><br><span class="line">  <span class="hljs-comment">// 紀錄目前位置 = 頁面位置 - 目前 item 的左邊距離</span></span><br><span class="line">  <span class="hljs-keyword">const</span> walk = (x - startX) * <span class="hljs-number">3</span>;</span><br><span class="line">  <span class="hljs-comment">// 紀錄游標距離原本起始值的滑動距離 = (目前位置 - 起始位置)*3</span></span><br><span class="line">  slider.scrollLeft = scrollLeft - walk;</span><br><span class="line">  <span class="hljs-comment">// 設定水平的偏移量</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="、滑鼠離開、滑鼠放開事件"><a href="#、滑鼠離開、滑鼠放開事件" class="headerlink" title="、滑鼠離開、滑鼠放開事件"></a>、滑鼠離開、滑鼠放開事件</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">slider.addEventListener(<span class="hljs-string">'mouseleave'</span>, () =&gt; &#123;</span><br><span class="line">  isDown = <span class="hljs-literal">false</span>;</span><br><span class="line">  slider.classList.remove(<span class="hljs-string">'active'</span>);</span><br><span class="line">  <span class="hljs-comment">// 取消狀態及樣式</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">slider.addEventListener(<span class="hljs-string">'mouseup'</span>, () =&gt; &#123;</span><br><span class="line">  isDown = <span class="hljs-literal">false</span>;</span><br><span class="line">  slider.classList.remove(<span class="hljs-string">'active'</span>);</span><br><span class="line">  <span class="hljs-comment">// 取消狀態及樣式</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS30系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30】Day26：Stripe Follow Along Nav</title>
      <link href="/javascript-30-day26/"/>
      <url>/javascript-30-day26/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://javascript30.com/" target="_blank" rel="noopener">javascript 30day</a></p></blockquote><a id="more"></a><h3 id="目標：滑動的次導覽列"><a href="#目標：滑動的次導覽列" class="headerlink" title="目標：滑動的次導覽列"></a><span style="color:#ff5900">目標：滑動的次導覽列</span></h3><h2 id="一、抓取頁面元素及建立事件"><a href="#一、抓取頁面元素及建立事件" class="headerlink" title="一、抓取頁面元素及建立事件"></a>一、抓取頁面元素及建立事件</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> triggers = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'.cool &gt; li'</span>);</span><br><span class="line"><span class="hljs-comment">// 抓取各別的選單</span></span><br><span class="line"><span class="hljs-keyword">const</span> background = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.dropdownBackground'</span>);</span><br><span class="line"><span class="hljs-comment">// 抓取白底部分</span></span><br><span class="line"><span class="hljs-keyword">const</span> nav = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.top'</span>);</span><br><span class="line"><span class="hljs-comment">// 抓取主導覽列</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleEnter</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.classList.add(<span class="hljs-string">'trigger-enter'</span>);</span><br><span class="line">  <span class="hljs-comment">// 新增 class</span></span><br><span class="line">  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.classList.add(<span class="hljs-string">'trigger-enter-active'</span>), <span class="hljs-number">150</span>);</span><br><span class="line">  <span class="hljs-comment">// 0.15毫秒後新增 class</span></span><br><span class="line">  background.classList.add(<span class="hljs-string">'open'</span>);</span><br><span class="line">  <span class="hljs-comment">// 新增白底樣式的 class</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleLeave</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.classList.remove(<span class="hljs-string">'trigger-enter'</span>, <span class="hljs-string">'trigger-enter-active'</span>);</span><br><span class="line">  background.classList.remove(<span class="hljs-string">'open'</span>);</span><br><span class="line">  <span class="hljs-comment">// 移除相關class</span></span><br><span class="line">&#125;</span><br><span class="line">triggers.forEach(<span class="hljs-function"><span class="hljs-params">trigger</span> =&gt;</span> trigger.addEventListener(<span class="hljs-string">'mouseenter'</span>, handleEnter));</span><br><span class="line">triggers.forEach(<span class="hljs-function"><span class="hljs-params">trigger</span> =&gt;</span> trigger.addEventListener(<span class="hljs-string">'mouseleave'</span>, handleLeave));</span><br></pre></td></tr></table></figure></p><p>事件僅有滑鼠滑入及滑出的效果，</p><h2 id="二、新增動態效果"><a href="#二、新增動態效果" class="headerlink" title="二、新增動態效果"></a>二、新增動態效果</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleEnter</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.classList.add(<span class="hljs-string">'trigger-enter'</span>);</span><br><span class="line">  <span class="hljs-comment">// 新增 class</span></span><br><span class="line">  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.classList.add(<span class="hljs-string">'trigger-enter-active'</span>), <span class="hljs-number">150</span>);</span><br><span class="line">  <span class="hljs-comment">// 0.15毫秒後新增 class</span></span><br><span class="line">  background.classList.add(<span class="hljs-string">'open'</span>);</span><br><span class="line">  <span class="hljs-comment">// 新增白底樣式的 class</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">const</span> dropdown = <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'.dropdown'</span>);</span><br><span class="line">  <span class="hljs-comment">// 取得導覽底下的下拉導覽</span></span><br><span class="line">  <span class="hljs-keyword">const</span> dropdownCoords = dropdown.getBoundingClientRect();</span><br><span class="line">  <span class="hljs-comment">// 取得下拉導覽的資訊</span></span><br><span class="line">  <span class="hljs-keyword">const</span> navCoords = nav.getBoundingClientRect();</span><br><span class="line">  <span class="hljs-comment">// 取得導覽列的資訊</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">const</span> coords = &#123;</span><br><span class="line">    height: dropdownCoords.height,</span><br><span class="line">    width: dropdownCoords.width,</span><br><span class="line">    top: dropdownCoords.top,</span><br><span class="line">    left: dropdownCoords.left,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="hljs-comment">// 取得下拉導覽座標</span></span><br><span class="line"></span><br><span class="line">  background.style.setProperty(<span class="hljs-string">'width'</span>, <span class="hljs-string">`<span class="hljs-subst">$&#123;coords.width&#125;</span>px`</span>);</span><br><span class="line">  background.style.setProperty(<span class="hljs-string">'height'</span>, <span class="hljs-string">`<span class="hljs-subst">$&#123;coords.height&#125;</span>px`</span>);</span><br><span class="line">  background.style.setProperty(<span class="hljs-string">'transform'</span>, <span class="hljs-string">`translate(<span class="hljs-subst">$&#123;coords.left&#125;</span>px,<span class="hljs-subst">$&#123;coords.top&#125;</span>px)`</span>);</span><br><span class="line">  <span class="hljs-comment">// 設定白底樣式滑入的寬高及定位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="三、Debug-錯位與快速滑動"><a href="#三、Debug-錯位與快速滑動" class="headerlink" title="三、Debug 錯位與快速滑動"></a>三、Debug 錯位與快速滑動</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleEnter</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">  <span class="hljs-keyword">const</span> coords = &#123;</span><br><span class="line">        height: dropdownCoords.height,</span><br><span class="line">        width: dropdownCoords.width,</span><br><span class="line">        top: dropdownCoords.top - navCoords.top,</span><br><span class="line">        left: dropdownCoords.left - navCoords.left</span><br><span class="line">            <span class="hljs-comment">// 減去主導覽列的定位</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假設主導覽列上方有新增元素，則下拉導覽列會錯位，為了避免錯位，因此必須扣除掉主導覽列的定位。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.classList.contains(<span class="hljs-string">'trigger-enter'</span>) &amp;&amp; <span class="hljs-keyword">this</span>.classList.add(<span class="hljs-string">'trigger-enter-active'</span>), <span class="hljs-number">150</span>);</span><br></pre></td></tr></table></figure></p><p>為了避免快速滑動導覽列產生錯亂，因此在<code>setTimeout</code>上增加判斷，<br>假設前者導覽有<code>trigger-enter</code>的 class，便增加<code>trigger-enter-active</code>，<br>假設沒有，則會一直顯示白色導覽列的部分，內容不會被顯示出來。</p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS30系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30】Day25：Event Capture, Propagation, Bubbling and Once</title>
      <link href="/javascript-30-day25/"/>
      <url>/javascript-30-day25/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://javascript30.com/" target="_blank" rel="noopener">javascript 30day</a></p></blockquote><a id="more"></a><h3 id="目標：理解事件捕捉、傳遞、氣泡，和單次執行"><a href="#目標：理解事件捕捉、傳遞、氣泡，和單次執行" class="headerlink" title="目標：理解事件捕捉、傳遞、氣泡，和單次執行"></a><span style="color:#ff5900">目標：理解事件捕捉、傳遞、氣泡，和單次執行</span></h3><h2 id="一、事件模型"><a href="#一、事件模型" class="headerlink" title="一、事件模型"></a>一、事件模型</h2><p><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"one"</span>&gt;</span></span><br><span class="line">  紫色</span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"two"</span>&gt;</span></span><br><span class="line">    粉色</span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"three"</span>&gt;</span></span><br><span class="line">      橘色</span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="二、建立事件點擊"><a href="#二、建立事件點擊" class="headerlink" title="二、建立事件點擊"></a>二、建立事件點擊</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> divs = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'div'</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logText</span>(<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.classList.value);</span><br><span class="line">&#125;</span><br><span class="line">divs.forEach(<span class="hljs-function"><span class="hljs-params">div</span> =&gt;</span> div.addEventListener(<span class="hljs-string">'click'</span>, logText));</span><br></pre></td></tr></table></figure></p><p>當你做事件點擊的監聽，點擊到<code>three</code>，而<code>two</code>和<code>one</code>會被<code>console.log</code>出來，<br>因為事件氣泡的關係，會不斷向外觸發所有的<code>div</code>元素，點擊<code>three</code>就會觸發<code>two</code>、<code>one</code>，點擊<code>two</code>，就觸發<code>one</code>，</p><p>事件氣泡為目標元素被監聽，點擊元素會不斷向外尋找，直到找到目標元素為止，<br>假設監聽元素是<code>body</code>，那點擊<code>three</code>，監聽就會向外尋找，觸發順序就為<code>three</code>、<code>two</code>、<code>one</code>、<code>body</code>。</p><p>事件捕捉為不斷向內觸發，那他就會向內觸發，以此類推。</p><h2 id="三、監聽事件的第三個參數，capture-屬性"><a href="#三、監聽事件的第三個參數，capture-屬性" class="headerlink" title="三、監聽事件的第三個參數，capture 屬性"></a>三、監聽事件的第三個參數，capture 屬性</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">divs.forEach(<span class="hljs-function"><span class="hljs-params">div</span> =&gt;</span></span><br><span class="line">  div.addEventListener(<span class="hljs-string">'click'</span>, logText, &#123;</span><br><span class="line">    capture: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 預設為false</span></span><br><span class="line">  &#125;),</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>監聽事件有第三個參數，假設不輸入，預設值就為<code>false</code>，該監聽事件就為事件氣泡，<br>如果輸入<code>true</code>，該事件就為事件捕捉。</p><h2 id="四、stopPropagation"><a href="#四、stopPropagation" class="headerlink" title="四、stopPropagation"></a>四、stopPropagation</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logText</span>(<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.classList.value);</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">divs.forEach(<span class="hljs-function"><span class="hljs-params">div</span> =&gt;</span> div.addEventListener(<span class="hljs-string">'click'</span>, logText));</span><br></pre></td></tr></table></figure></p><p>使用<code>stopPropagation();</code>，就不會向外觸發父元素。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logText</span>(<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.classList.value);</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">divs.forEach(<span class="hljs-function"><span class="hljs-params">div</span> =&gt;</span></span><br><span class="line">  div.addEventListener(<span class="hljs-string">'click'</span>, logText, &#123;</span><br><span class="line">    capture: <span class="hljs-literal">true</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>假設在事件捕捉的時候，使用<code>stopPropagation</code>，點擊<code>three</code>，會觸發<code>one</code>，<br>因為事件捕捉是由外向內觸發，他會向內尋找目標元素，但因為<code>stopPropagation</code>的關係，<br>觸發到最外層的<code>one</code>元素，便會停止事件捕捉的監聽。</p><h2 id="三、第三個參數，once-屬性"><a href="#三、第三個參數，once-屬性" class="headerlink" title="三、第三個參數，once 屬性"></a>三、第三個參數，once 屬性</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">button.addEventListener(</span><br><span class="line">  <span class="hljs-string">'click'</span>,</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Click!!!'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    once: <span class="hljs-literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>監聽的<code>once</code>屬性，是監聽一次點擊事件後，就會解除對自己本身的事件綁定，<br>所以再點擊第二次、第三次，他不會被監聽，因為在監聽第一次的時候，已經解除監聽狀態。</p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ul><li>addEventListener</li><li>stopPropagation</li></ul>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS30系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30】Day24：Sticky Nav</title>
      <link href="/javascript-30-day24/"/>
      <url>/javascript-30-day24/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://javascript30.com/" target="_blank" rel="noopener">javascript 30day</a></p></blockquote><a id="more"></a><h3 id="目標：偵測頁面高度固定導覽列"><a href="#目標：偵測頁面高度固定導覽列" class="headerlink" title="目標：偵測頁面高度固定導覽列"></a><span style="color:#ff5900">目標：偵測頁面高度固定導覽列</span></h3><h2 id="一、取得頁面元素及偵測高度"><a href="#一、取得頁面元素及偵測高度" class="headerlink" title="一、取得頁面元素及偵測高度"></a>一、取得頁面元素及偵測高度</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> nav = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#main'</span>);</span><br><span class="line"><span class="hljs-comment">// 導覽列</span></span><br><span class="line"><span class="hljs-keyword">const</span> topOfNav = nav.offsetTop;</span><br><span class="line"><span class="hljs-comment">// 導覽列頂部到 top 的距離</span></span><br></pre></td></tr></table></figure></p><h2 id="二、新增-class-及判斷"><a href="#二、新增-class-及判斷" class="headerlink" title="二、新增 class 及判斷"></a>二、新增 class 及判斷</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fixNav</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.scrollY &gt;= topOfNav) &#123;</span><br><span class="line">    <span class="hljs-comment">// 假設頁面高度超過距離</span></span><br><span class="line">    <span class="hljs-built_in">document</span>.body.classList.add(<span class="hljs-string">'fixed-nav'</span>);</span><br><span class="line">    <span class="hljs-comment">// body就增加 class</span></span><br><span class="line">  &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">document</span>.body.classList.remove(<span class="hljs-string">'fixed-nav'</span>);</span><br><span class="line">    <span class="hljs-comment">// 若沒有就移除 class</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'scroll'</span>, fixNav);</span><br><span class="line"><span class="hljs-comment">// 監聽滾動事件</span></span><br></pre></td></tr></table></figure></p><h2 id="三、新增-fixed-樣式"><a href="#三、新增-fixed-樣式" class="headerlink" title="三、新增 fixed 樣式"></a>三、新增 fixed 樣式</h2><p><figure class="highlight css hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-selector-class">.fixed-nav</span> <span class="hljs-selector-class">.site-wrap</span> &#123;</span><br><span class="line">  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 當出現 fixed-nav ，site-wrap 縮放比改為 1 */</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-selector-class">.fixed-nav</span> <span class="hljs-selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="hljs-attribute">position</span>: fixed;</span><br><span class="line">  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">5px</span> <span class="hljs-built_in">rgba</span>(0, 0, 0, 0.1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 當出現 fixed-nav ，把 nav 固定，並加上陰影*/</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-selector-class">.fixed-nav</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-class">.logo</span> &#123;</span><br><span class="line">  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">500px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 當出現 fixed-nav ，顯示並增加 logo 寬度*/</span></span><br></pre></td></tr></table></figure></p><h2 id="四、debug"><a href="#四、debug" class="headerlink" title="四、debug"></a>四、debug</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fixNav</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.scrollY &gt;= topOfNav) &#123;</span><br><span class="line">    <span class="hljs-comment">// 假設頁面高度超過距離</span></span><br><span class="line">    <span class="hljs-built_in">document</span>.body.paddingTop = nav.offsetHeight + <span class="hljs-string">'px'</span>;</span><br><span class="line">    <span class="hljs-comment">// 當 position 被設定為 fixed ，物件便會浮動固定在畫面上，所以需要動態增加 offsetHeight 的高度，避免彈跳現象。</span></span><br><span class="line">    <span class="hljs-built_in">document</span>.body.classList.add(<span class="hljs-string">'fixed-nav'</span>);</span><br><span class="line">    <span class="hljs-comment">// body就增加 class</span></span><br><span class="line">  &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">document</span>.body.style.paddingTop = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-comment">// 若沒有就還原頁面。</span></span><br><span class="line">    <span class="hljs-built_in">document</span>.body.classList.remove(<span class="hljs-string">'fixed-nav'</span>);</span><br><span class="line">    <span class="hljs-comment">// 若沒有就移除 class</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS30系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30】Day23：Speech Synthesis</title>
      <link href="/javascript-30-day23/"/>
      <url>/javascript-30-day23/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://javascript30.com/" target="_blank" rel="noopener">javascript 30day</a></p></blockquote><a id="more"></a><h3 id="目標：使文字轉語音，並變換音調及速率"><a href="#目標：使文字轉語音，並變換音調及速率" class="headerlink" title="目標：使文字轉語音，並變換音調及速率"></a><span style="color:#ff5900">目標：使文字轉語音，並變換音調及速率</span></h3><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> msg = <span class="hljs-keyword">new</span> SpeechSynthesisUtterance();</span><br><span class="line"><span class="hljs-keyword">let</span> voices = [];</span><br><span class="line"><span class="hljs-keyword">const</span> voicesDropdown = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'[name="voice"]'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> options = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'[type="range"], [name="text"]'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> speakButton = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#speak'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> stopButton = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#stop'</span>);</span><br></pre></td></tr></table></figure></p><p>作業一開始已經先取用好 DOM。</p><h2 id="一、取用語音要播放的文字"><a href="#一、取用語音要播放的文字" class="headerlink" title="一、取用語音要播放的文字"></a>一、取用語音要播放的文字</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">msg.text = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'[name="text"]'</span>).value;</span><br><span class="line"><span class="hljs-comment">// 使輸入欄位成為要使用的值</span></span><br></pre></td></tr></table></figure></p><h2 id="二、取用語系"><a href="#二、取用語系" class="headerlink" title="二、取用語系"></a>二、取用語系</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">populateVoices</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  voices = <span class="hljs-keyword">this</span>.getVoices();</span><br><span class="line">  <span class="hljs-comment">// 取得播放聲音的語系資訊</span></span><br><span class="line">  voicesDropdown.innerHTML = voices</span><br><span class="line">    .map(<span class="hljs-function"><span class="hljs-params">voice</span> =&gt;</span> <span class="hljs-string">`&lt;option value="<span class="hljs-subst">$&#123;voice.name&#125;</span>"&gt;<span class="hljs-subst">$&#123;voice.name&#125;</span>(<span class="hljs-subst">$&#123;voice.lang&#125;</span>)&lt;/option&gt;`</span>)</span><br><span class="line">    <span class="hljs-comment">// 取用語系資料塞進下拉選單</span></span><br><span class="line">    .join(<span class="hljs-string">''</span>);</span><br><span class="line">  <span class="hljs-comment">// 使用 join 取消逗號</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">speechSynthesis.addEventListener(<span class="hljs-string">'voiceschanged'</span>, populateVoices);</span><br></pre></td></tr></table></figure></p><h2 id="三、更換選單，更換播放語系"><a href="#三、更換選單，更換播放語系" class="headerlink" title="三、更換選單，更換播放語系"></a>三、更換選單，更換播放語系</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setVoice</span>(<span class="hljs-params">startOver = true</span>) </span>&#123;</span><br><span class="line">  msg.voice = voices.find(<span class="hljs-function"><span class="hljs-params">voice</span> =&gt;</span> voice.name === <span class="hljs-keyword">this</span>.value);</span><br><span class="line">  <span class="hljs-comment">// 設定輸入欄位的語音是選擇發音的語系</span></span><br><span class="line"></span><br><span class="line">  toggle();</span><br><span class="line">  <span class="hljs-comment">// 播放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toggle</span>(<span class="hljs-params">startOver = true</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// 播放暫停切換</span></span><br><span class="line">  speechSynthesis.cancel();</span><br><span class="line">  <span class="hljs-comment">// 停用原本的語音</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (startOver) &#123;</span><br><span class="line">    speechSynthesis.speak(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-comment">// 重新播放新的語系。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">voicesDropdown.addEventListener(<span class="hljs-string">'change'</span>, setVoice);</span><br><span class="line"><span class="hljs-comment">// 監聽 change 事件</span></span><br></pre></td></tr></table></figure></p><h2 id="四、調整速度與音準，以及設定其餘監聽"><a href="#四、調整速度與音準，以及設定其餘監聽" class="headerlink" title="四、調整速度與音準，以及設定其餘監聽"></a>四、調整速度與音準，以及設定其餘監聽</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setOption</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  msg[<span class="hljs-keyword">this</span>.name] = <span class="hljs-keyword">this</span>.value;</span><br><span class="line">  <span class="hljs-comment">// 傳入的變數與SpeechSynthesisUtterance本身的物件相同，可以直接取用</span></span><br><span class="line">  toggle();</span><br><span class="line">&#125;</span><br><span class="line">options.forEach(<span class="hljs-function"><span class="hljs-params">option</span> =&gt;</span> option.addEventListener(<span class="hljs-string">'change'</span>, setOption));</span><br><span class="line"><span class="hljs-comment">// 監聽音準和速率的change事件</span></span><br><span class="line">speakButton.addEventListener(<span class="hljs-string">'click'</span>, toggle);</span><br><span class="line"><span class="hljs-comment">// 監聽播放鍵</span></span><br><span class="line">stopButton.addEventListener(<span class="hljs-string">'click'</span>, () =&gt; toggle(<span class="hljs-literal">false</span>));</span><br><span class="line"><span class="hljs-comment">// 監聽暫停鍵</span></span><br></pre></td></tr></table></figure></p><h2 id="五、取用部分語系"><a href="#五、取用部分語系" class="headerlink" title="五、取用部分語系"></a>五、取用部分語系</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">populateVoices</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    voices = <span class="hljs-keyword">this</span>.getVoices();</span><br><span class="line">    <span class="hljs-comment">// 取得播放聲音的語系資訊</span></span><br><span class="line">    voicesDropdown.innerHTML = voices</span><br><span class="line">        .filter(<span class="hljs-function"><span class="hljs-params">voice</span>=&gt;</span>voice.includes(<span class="hljs-string">'en'</span>))</span><br><span class="line">        .map(<span class="hljs-function"><span class="hljs-params">voice</span> =&gt;</span> <span class="hljs-string">`&lt;option value="<span class="hljs-subst">$&#123;voice.name&#125;</span>"&gt;<span class="hljs-subst">$&#123;voice.name&#125;</span>(<span class="hljs-subst">$&#123;voice.lang&#125;</span>)&lt;/option&gt;`</span>)</span><br><span class="line">        <span class="hljs-comment">// 取用語系資料塞進下拉選單</span></span><br><span class="line">        .join(<span class="hljs-string">''</span>);</span><br><span class="line">    <span class="hljs-comment">// 使用 join 取消逗號</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ul><li>SpeechSynthesisUtterance</li><li>speechSynthesis</li></ul>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS30系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Vue】Vue 常用套件環境設定</title>
      <link href="/vue-cli-2-plugin/"/>
      <url>/vue-cli-2-plugin/</url>
      
        <content type="html"><![CDATA[<ul><li>vue-loader</li><li>bootstrap / jQuery</li><li>axios</li></ul><p>版本：vue-cli 2.9.3</p><a id="more"></a><h2 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue-router"></a>Vue-router</h2><h3 id="安裝-Vue-router"><a href="#安裝-Vue-router" class="headerlink" title="安裝 Vue-router"></a>安裝 Vue-router</h3><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ npm install vue-router</span><br></pre></td></tr></table></figure></p><p>在專案下使用 npm 安裝，如果你是使用 webpack 樣板，你在設定<code>pakage.json</code>就可以選擇要不要安裝。</p><h3 id="註冊"><a href="#註冊" class="headerlink" title="註冊"></a>註冊</h3><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">'./router'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="hljs-string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="hljs-string">'&lt;App/&gt;'</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>在<code>main.js</code>裡面會發現他已經幫你 import 進去，接著看<code>app.vue</code>，會發現有個<code>&lt;router-view/&gt;</code>的標籤，這意思是路由顯示的畫面會在那個區塊做顯示，接著看<code>router/index.js</code></p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"><span class="hljs-comment">// init</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// page import</span></span><br><span class="line"><span class="hljs-keyword">import</span> Hello <span class="hljs-keyword">from</span> <span class="hljs-string">'./pages/Hello.vue'</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> Hello2 <span class="hljs-keyword">from</span> <span class="hljs-string">'./pages/Hello2.vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;</span><br><span class="line">  mode: <span class="hljs-string">'history'</span>,</span><br><span class="line">  base: __dirname,</span><br><span class="line">  <span class="hljs-comment">// router 列表</span></span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="hljs-string">'/hello'</span>,</span><br><span class="line">      name: <span class="hljs-string">'hello'</span>,</span><br><span class="line">      component: Hello,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="hljs-string">'/hello2'</span>,</span><br><span class="line">      name: <span class="hljs-string">'hello2'</span>,</span><br><span class="line">      component: Hello2,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="hljs-comment">// router 轉址</span></span><br><span class="line">    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'/*'</span>, <span class="hljs-attr">redirect</span>: <span class="hljs-string">'/hello'</span> &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>如果使用<code>webpack-simple</code>模板，需要按照官方的方式 import，也不會有<code>router</code>資料夾，必須直接在裡面設置 router。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> HelloWorld <span class="hljs-keyword">from</span> <span class="hljs-string">'@/components/HelloWorld'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="hljs-string">'/'</span>,</span><br><span class="line">      name: <span class="hljs-string">'HelloWorld'</span>,</span><br><span class="line">      component: HelloWorld,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>這段的意思是說，是 router 根據用戶的 url 來判斷要顯示哪個元件，所有要依據路由轉換的元件都要在<code>router/index.js</code>上註冊。</p><p><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"page01url"</span>&gt;</span>page01<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"page02url"</span>&gt;</span>page02<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在選用觸發切換路由，絕大部分人都會直接反應用 a 連結下去切換，但官方並不建議這樣寫，官方建議用<code>&lt;router-link&gt;</code>。</p><h2 id="bootstrap"><a href="#bootstrap" class="headerlink" title="bootstrap"></a>bootstrap</h2><h3 id="安裝-bootstrap"><a href="#安裝-bootstrap" class="headerlink" title="安裝 bootstrap"></a>安裝 bootstrap</h3><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ npm install bootstrap sass-loader postcss-loader node-sass --save</span><br></pre></td></tr></table></figure></p><p>上面指令是官方建議的安裝方法，但如果要引用 bootstrap 的 sass 仍然會報錯，因為 webpack 無法解析，所以要安裝<code>sass-loader</code>、<code>post-loader</code>，以及讓<code>sass-loader</code>相依的<code>node-sass</code>，讓 bootstrap 可以正常解析。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ npm install -D vue-style-loader css-loader</span><br></pre></td></tr></table></figure></p><p>但是為了在預覽 vue 的時候可以即時顯示，所以我們必須還要再下載<code>vue-style-loader</code>，這和之前用的<code>style-loader</code>有 87 分像。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="hljs-regexp">/\.vue$/</span>,</span><br><span class="line">  loader: <span class="hljs-string">'vue-loader'</span>,</span><br><span class="line">  options: &#123;</span><br><span class="line">    loaders: &#123;</span><br><span class="line">      <span class="hljs-string">'scss'</span>: [</span><br><span class="line">        <span class="hljs-string">'vue-style-loader'</span>,</span><br><span class="line">        <span class="hljs-string">'css-loader'</span>,</span><br><span class="line">        <span class="hljs-string">'post-loader'</span>,</span><br><span class="line">        <span class="hljs-string">'sass-loader'</span>,</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因為 webpack loader 的運作機制順序是由後往前、內往外，因此在<code>webpack.base.config.js</code>的配置如上，這讓 bootstrap 的 sass 有全局的設定。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ npm install sass-resources-loader</span><br></pre></td></tr></table></figure></p><p>此時發現，只要在子元件想要使用 bootstrap sass 的程式庫 （mixin、extend……）及變數，並無法正確載入，為了不要在子元件裡面一直重複 import ，這時候需要加載<code>sass-resources-loader</code>。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="hljs-regexp">/\.vue$/</span>,</span><br><span class="line">  loader: <span class="hljs-string">'vue-loader'</span>,</span><br><span class="line">  options: &#123;</span><br><span class="line">      loaders: &#123;</span><br><span class="line">          <span class="hljs-string">'scss'</span>: [</span><br><span class="line">              <span class="hljs-string">'vue-style-loader'</span>,</span><br><span class="line">              <span class="hljs-string">'css-loader'</span>,</span><br><span class="line">              <span class="hljs-string">'sass-loader'</span>,</span><br><span class="line">              &#123;</span><br><span class="line">                  loader: <span class="hljs-string">'sass-resources-loader'</span>,</span><br><span class="line">                  options: &#123;</span><br><span class="line">                      resources: path.resolve(__dirname, <span class="hljs-string">'./src/assets/styles/global.scss'</span>),</span><br><span class="line">                  &#125;,</span><br><span class="line">              &#125;</span><br><span class="line">          ]</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>這個 loader 主要是讓 sass 在被編譯解析前，把我們要設為全域環境的 sass 檔案路徑放到<code>resources</code>中。</p><p><figure class="highlight scss hljs"><table><tr><td class="code"><pre><span class="line">@<span class="hljs-keyword">import</span> <span class="hljs-string">'~bootstrap/scss/bootstrap'</span>;</span><br></pre></td></tr></table></figure></p><p>再到<code>./src/assets/styles/global.scss</code>的檔案裡面匯入 bootstrap 。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">'./assets/styles/global.scss'</span>;</span><br></pre></td></tr></table></figure></p><p>最後別忘了要再<code>app.vue</code>的檔案中 import 才算完成。<br>此外在<code>global.scss</code>中，你也可以放置你想要設為全域的 sass ，例如 RWD 斷點、變數之類的，因為這個 sass 是全域，所以也要考慮專案的加載量。</p><h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h2><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ npm install --save jquery popper.js</span><br></pre></td></tr></table></figure></p><p>處理完 sass 的部分，接下來處理互動。為了能正常使用 bootstrap 元件的部分，因此要再多下載 jQuery 和 popper.js，popper.js 的副檔名一定要加，不然 popper 是另外一個套件。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>)</span><br><span class="line">...</span><br><span class="line"> plugins: [</span><br><span class="line">    <span class="hljs-keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">        <span class="hljs-string">'$'</span>: <span class="hljs-string">"jquery"</span>,</span><br><span class="line">        <span class="hljs-string">'jQuery'</span>: <span class="hljs-string">"jquery"</span>,</span><br><span class="line">        <span class="hljs-string">'Popper'</span>: <span class="hljs-string">'popper.js'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure></p><p>在<code>webpack.base.config.js</code>的設定。</p><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><h3 id="介紹"><a href="#介紹" class="headerlink" title="介紹"></a>介紹</h3><blockquote><p>Promise based HTTP client for the browser and node.js</p></blockquote><p>基於 promise 用於 瀏覽器和 node.js 的 HTTP 客戶端。</p><h3 id="特色"><a href="#特色" class="headerlink" title="特色"></a>特色</h3><ul><li>在瀏覽器創建 XMLHttpRequest</li><li>從 node.js 發出 http 請求</li><li>支援 Promise API</li><li>攔截請求跟回應</li><li>轉換請求與回應資料</li><li>取消請求</li><li>自動轉換 JSON 資料</li><li>客戶端防止 CSRF/XSRF</li></ul><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ npm install axios</span><br></pre></td></tr></table></figure></p><p>一樣使用 npm 安裝。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> Axios <span class="hljs-keyword">from</span> <span class="hljs-string">'Axios'</span>;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">Vue.prototype.$axios = Axios;</span><br><span class="line"><span class="hljs-comment">// 為了讓其他元件也能使用 axios，需改成 vue 的原型屬性。</span></span><br></pre></td></tr></table></figure></p><p>安裝完之後，把他 import 進<code>main.js</code>。</p><h3 id="post-範例執行方法"><a href="#post-範例執行方法" class="headerlink" title="post 範例執行方法"></a>post 範例執行方法</h3><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.$axios.post(<span class="hljs-string">'/user'</span>, &#123;</span><br><span class="line">    firstName: <span class="hljs-string">'Fred'</span>,</span><br><span class="line">    lastName: <span class="hljs-string">'Flintstone'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>這個方法是在元件被創造完後，立即調用，利用 axios 執行 post 請求，要看更多方法請看<a href="https://github.com/axios/axios" target="_blank" rel="noopener">axios github</a>，生命週期的部分，詳細可以看<a href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90" target="_blank" rel="noopener">Vue 生命週期</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30】Day22：Follow Along Link Highlighter</title>
      <link href="/javascript-30-day22/"/>
      <url>/javascript-30-day22/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://javascript30.com/" target="_blank" rel="noopener">javascript 30day</a></p></blockquote><a id="more"></a><h3 id="目標：根據滑鼠游標移動-highlight-位置"><a href="#目標：根據滑鼠游標移動-highlight-位置" class="headerlink" title="目標：根據滑鼠游標移動 highlight 位置"></a><span style="color:#ff5900">目標：根據滑鼠游標移動 highlight 位置</span></h3><h2 id="一、取得-DOM"><a href="#一、取得-DOM" class="headerlink" title="一、取得 DOM"></a>一、取得 DOM</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> triggers = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'a'</span>);</span><br><span class="line"><span class="hljs-comment">// 取得 a 連結</span></span><br><span class="line"><span class="hljs-keyword">const</span> highlight = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'span'</span>);</span><br><span class="line"><span class="hljs-comment">// 建立highlight</span></span><br><span class="line">highlight.classList.add(<span class="hljs-string">'highlight'</span>);</span><br><span class="line"><span class="hljs-comment">// 新增節點</span></span><br><span class="line"><span class="hljs-built_in">document</span>.body.append(highlight);</span><br><span class="line"><span class="hljs-comment">// 加到頁面中</span></span><br></pre></td></tr></table></figure></p><h2 id="二、更改狀態"><a href="#二、更改狀態" class="headerlink" title="二、更改狀態"></a>二、更改狀態</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">highlightLink</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">const</span> linkCoords = <span class="hljs-keyword">this</span>.getBoundingClientRect();</span><br><span class="line">  <span class="hljs-comment">// 取得 a 本身距離瀏覽器窗口的位置</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">const</span> coords = &#123;</span><br><span class="line">    width: linkCoords.width,</span><br><span class="line">    height: linkCoords.height,</span><br><span class="line">    top: linkCoords.top + <span class="hljs-built_in">window</span>.scrollY,</span><br><span class="line">    left: linkCoords.left + <span class="hljs-built_in">window</span>.scrollX,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="hljs-comment">// 建立物件，以便存放位置訊息，因為根據 window 捲軸滑動的關係，必須加上scroll移動值。</span></span><br><span class="line"></span><br><span class="line">  highlight.style.width = <span class="hljs-string">`<span class="hljs-subst">$&#123;coords.width&#125;</span>px`</span>;</span><br><span class="line">  highlight.style.height = <span class="hljs-string">`<span class="hljs-subst">$&#123;coords.height&#125;</span>px`</span>;</span><br><span class="line">  highlight.style.transform = <span class="hljs-string">`translate(<span class="hljs-subst">$&#123;coords.left&#125;</span>px, <span class="hljs-subst">$&#123;coords.top&#125;</span>px)`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 設定效果的寬高及定位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">triggers.forEach(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> a.addEventListener(<span class="hljs-string">'mouseenter'</span>, highlightLink));</span><br><span class="line"><span class="hljs-comment">// 監聽所有 a 連結的滑鼠移入，觸發 highlightLink</span></span><br></pre></td></tr></table></figure></p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ul><li>getBoundingClientRect</li></ul>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS30系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30】Day21：Geolocation based Speedometer and Compass</title>
      <link href="/javascript-30-day21/"/>
      <url>/javascript-30-day21/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://javascript30.com/" target="_blank" rel="noopener">javascript 30day</a></p></blockquote><a id="more"></a><h3 id="目標：取得裝置地理位置和速度"><a href="#目標：取得裝置地理位置和速度" class="headerlink" title="目標：取得裝置地理位置和速度"></a><span style="color:#ff5900">目標：取得裝置地理位置和速度</span></h3><h2 id="一、使用-npm-啟動-server"><a href="#一、使用-npm-啟動-server" class="headerlink" title="一、使用 npm 啟動 server"></a>一、使用 npm 啟動 server</h2><p>因為練習是取用定位，所以 mac 可以用 Xcode 模擬，<br>或是用 npm start 啟動內網 ip，連線啟動 server 。</p><h2 id="二、Coding"><a href="#二、Coding" class="headerlink" title="二、Coding"></a>二、Coding</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> arrow = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.arrow'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> speed = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.speed-value'</span>);</span><br><span class="line"><span class="hljs-comment">// 抓取 DOM</span></span><br><span class="line"></span><br><span class="line">navigator.geolocation.watchPosition(</span><br><span class="line">  data =&gt; &#123;</span><br><span class="line">    <span class="hljs-comment">// 使用 watchPosition 取得裝置資料，若成功就回傳</span></span><br><span class="line">    <span class="hljs-built_in">console</span>.log(data);</span><br><span class="line">    <span class="hljs-comment">// data.coords.speed 取得速度</span></span><br><span class="line">    speed.textContent = data.coords.speed;</span><br><span class="line">    <span class="hljs-comment">// data.coords.heading 取得角度</span></span><br><span class="line">    arrow.style.transform = <span class="hljs-string">`rotate(<span class="hljs-subst">$&#123;data.coords.heading&#125;</span>deg)`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.error(err);</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ul><li>Geolocation.watchPosition()</li></ul>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS30系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Vue】Vue 與 webpack</title>
      <link href="/vue-cli-2-webpack/"/>
      <url>/vue-cli-2-webpack/</url>
      
        <content type="html"><![CDATA[<p>版本：vue-cli 2.9.3</p><a id="more"></a><h2 id="產出的專案資料夾結構"><a href="#產出的專案資料夾結構" class="headerlink" title="產出的專案資料夾結構"></a>產出的專案資料夾結構</h2><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── build          // 與 webpack 相關</span><br><span class="line">├── config         // 與 webpack 相關</span><br><span class="line">├── node_modules   // node npm 模組</span><br><span class="line">├── src            // 主要開發環境 source code</span><br><span class="line">|   ├── assets     // 圖片等靜態檔</span><br><span class="line">|   ├── router     // vue 路由器</span><br><span class="line">|   ├── app.vue    // 主要的樣板檔</span><br><span class="line">|   ├── main.js    // 主要的 js 檔，套件 import 的入口文件</span><br><span class="line">|   └── components // vue 元件檔</span><br><span class="line">├── static         // 放置第三方 plugin 位置</span><br><span class="line">├── index.html     // 靜態 html檔</span><br><span class="line">├── package.json</span><br><span class="line">└── package-lock.json</span><br></pre></td></tr></table></figure></p><p>當我們使用<code>npm run dev</code>啟用 vue-cli 的專案，打開 chrome 的 network 會發現當中除了載入<code>index.html</code>，還有一隻<code>app.js</code>檔，<br>可是你會發現專案裡面根本就沒有<code>app.js</code>檔，而且<code>index.html</code>根本也沒有引入任何的 js 文件。</p><p>我們從<code>npm run dev</code>開始追根究底，打開<code>package.json</code>會發現其中一行 script 指令。</p><p><figure class="highlight hljs"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看起來我們運作的和<code>build/webpack.dev.conf.js</code>非常有關。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> utils = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./utils'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>); <span class="hljs-comment">// webpack 核心編譯工具</span></span><br><span class="line"><span class="hljs-keyword">const</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../config'</span>); <span class="hljs-comment">// config/index.js</span></span><br><span class="line"><span class="hljs-keyword">const</span> merge = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack-merge'</span>); <span class="hljs-comment">// 合併 config</span></span><br><span class="line"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>); <span class="hljs-comment">// node API 處理文件路徑</span></span><br><span class="line"><span class="hljs-keyword">const</span> baseWebpackConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./webpack.base.conf'</span>); <span class="hljs-comment">//base.config</span></span><br><span class="line"><span class="hljs-keyword">const</span> CopyWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'copy-webpack-plugin'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> FriendlyErrorsPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'friendly-errors-webpack-plugin'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> portfinder = <span class="hljs-built_in">require</span>(<span class="hljs-string">'portfinder'</span>);</span><br></pre></td></tr></table></figure></p><p>打開來會發現裡面有導入很多模組，我們主要看幾個文件，<code>config/index.js</code>，仔細看內容。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><br><span class="line">  dev: &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="hljs-comment">// Various Dev Server settings</span></span><br><span class="line">    host: <span class="hljs-string">'localhost'</span>, <span class="hljs-comment">// can be overwritten by process.env.HOST</span></span><br><span class="line">    port: <span class="hljs-number">8080</span>, <span class="hljs-comment">// can be overwritten by process.env.PORT, if port is in use, a free one will be determined</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  build: &#123;</span><br><span class="line">    <span class="hljs-comment">// Template for index.html</span></span><br><span class="line">    index: path.resolve(__dirname, <span class="hljs-string">'../dist/index.html'</span>),</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>裡面分別有<code>dev</code>開發版本的基本設定，例如在本地端運行的 port 號 ，或是<code>build</code>生產版本的設定，例如首頁的導入設定，<br>回去看<code>build</code>資料夾，裡面有三個 config 檔在不同狀況下讀取不同的檔案，分別是<code>dev</code>開發版本、<code>build</code>生產版本和<code>base</code>共用版本，當中最重要的是<code>base</code>，當中有一些 webpack 的基本設定。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">context: path.resolve(__dirname, <span class="hljs-string">'../'</span>),</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="hljs-string">'./src/main.js'</span> <span class="hljs-comment">// 主要導入的 js</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: config.build.assetsRoot, <span class="hljs-comment">// 編譯導出的文件路徑 config/index.js</span></span><br><span class="line">    filename: <span class="hljs-string">'[name].js'</span>, <span class="hljs-comment">// 導出文件名稱 [name].js =&gt; app.js</span></span><br><span class="line">    publicPath: process.env.NODE_ENV === <span class="hljs-string">'production'</span></span><br><span class="line">      ? config.build.assetsPublicPath</span><br><span class="line">      : config.dev.assetsPublicPath <span class="hljs-comment">// 靜態文件的絕對路徑</span></span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123; <span class="hljs-comment">// import 元件時的設定</span></span><br><span class="line">    extensions: [<span class="hljs-string">'.js'</span>, <span class="hljs-string">'.vue'</span>, <span class="hljs-string">'.json'</span>],</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="hljs-string">'vue$'</span>: <span class="hljs-string">'vue/dist/vue.esm.js'</span>,</span><br><span class="line">      <span class="hljs-string">'@'</span>: resolve(<span class="hljs-string">'src'</span>), <span class="hljs-comment">// 編寫路徑時 @ 可代替src</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...<span class="hljs-comment">// webpack 編譯時，文件處理的相關 loader</span></span><br><span class="line">  ...</span><br><span class="line">  &#123; <span class="hljs-comment">// 圖片處理（多媒體及字體以此類推）</span></span><br><span class="line">  test: <span class="hljs-regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">  loader: <span class="hljs-string">'url-loader'</span>,</span><br><span class="line">  options: &#123;</span><br><span class="line">    limit: <span class="hljs-number">10000</span>,<span class="hljs-comment">// 小於10kb會被編譯成 base64 字串打包編譯到 js 文件中</span></span><br><span class="line">    name: utils.assetsPath(<span class="hljs-string">'img/[name].[hash:7].[ext]'</span>)<span class="hljs-comment">// 超過大小會被放到/static/img/[圖片名稱].[hash值].副檔名</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p><p>至於為什麼在<code>static</code>裡面，可以根據路徑轉向到<code>utils.js</code>裡面的<code>assetsPath</code>，發現文件又導向<code>webpack.config.dev/build.js</code>的<code>assetsSubDirectory</code>，發現 template 將路徑設定在<code>static</code>。</p><p>那剩下關於 webpack plugin/loader 的詳細設定，可以參考<a href="https://leiadot.github.io/tags/%E6%97%A5%E5%AE%89%E5%88%9D%E6%8E%A2-Webpack/" target="_blank" rel="noopener">日安初探 webpack 系列文章</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Webpack】source-map</title>
      <link href="/webpack-4-source-map/"/>
      <url>/webpack-4-source-map/</url>
      
        <content type="html"><![CDATA[<p>新手從無到有，初探 webpack 的心得。</p><p>有時候看到別人的<code>webpack.config.js</code>會看到一段<code>devtool: &#39;source-map&#39;</code>，<br>不太了解這是什麼，也不太了解那有什麼用處，現在就來看看。</p><p>版本：webpack 4.1.1</p><a id="more"></a><p>因為有時候要檢查出錯的程式碼，但是從 webpack 產出的檔案都是已經被編譯過的，<br>就算找到 bug 位置，可是不知道具體 source code 位置，還是沒辦法做即時修正。</p><h2 id="一、在-js-中使用"><a href="#一、在-js-中使用" class="headerlink" title="一、在 js 中使用"></a>一、在 js 中使用</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="hljs-string">'source-map'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改<code>webpack.config.js</code>，開發者工具會連結到<code>src/app.js</code> 有 bug 的位置。</p><h2 id="二、在-css-中使用"><a href="#二、在-css-中使用" class="headerlink" title="二、在 css 中使用"></a>二、在 css 中使用</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="hljs-regexp">/\.scss$/</span>,</span><br><span class="line">  use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">      fallback: <span class="hljs-string">'style-loader'</span>,</span><br><span class="line">      <span class="hljs-comment">//resolve-url-loader may be chained before sass-loader if necessary</span></span><br><span class="line">      use: [<span class="hljs-string">'css-loader?sourceMap'</span>, <span class="hljs-string">'sass-loader?sourceMap'</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一樣修改<code>webpack.config.js</code>，就會在開發者工具 css 的部份看到 <code>app.scss</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Webpack】打包圖片與壓縮</title>
      <link href="/webpack-4-image-compression/"/>
      <url>/webpack-4-image-compression/</url>
      
        <content type="html"><![CDATA[<p>新手從無到有，初探 webpack 的心得。</p><p>打包圖片與壓縮的介紹。</p><p>版本：webpack 4.1.1</p><a id="more"></a><p>新增<code>src/img/logo.png</code>，並在 <code>src/app.scss</code> 裡面載入背景圖片<br><code>background: url(&#39;./img/logo.png&#39;) 0 0 no-repeat;</code>，<br>執行之後會報錯，因此我們要加裝<code>file-loader</code>。</p><h2 id="Sass-載入圖片"><a href="#Sass-載入圖片" class="headerlink" title="Sass 載入圖片"></a>Sass 載入圖片</h2><h3 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h3><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ npm install --save-dev file-loader</span><br></pre></td></tr></table></figure></p><p>在專案下安裝。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="hljs-built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="hljs-regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="hljs-string">'file-loader'</span>,</span><br><span class="line">            options: &#123;&#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>更改<code>webpack.config.js</code>，執行後有效，但發現圖檔名為 hash 值，因此我們更改<code>option</code>。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">test: <span class="hljs-regexp">/\.(gif|png|jpe?g|svg)$/i</span>,</span><br><span class="line">use: [</span><br><span class="line">  &#123;</span><br><span class="line">    loader: <span class="hljs-string">'file-loader'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">      name: <span class="hljs-string">'[name].[ext]'</span>,</span><br><span class="line">      outputPath: <span class="hljs-string">'images/'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><ul><li>name：採用 source 檔名</li><li>ext：副檔名</li><li>outputPath：輸出檔案資料夾</li></ul><h2 id="Html-載入圖片"><a href="#Html-載入圖片" class="headerlink" title="Html 載入圖片"></a>Html 載入圖片</h2><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ npm install --save-dev html-loader</span><br></pre></td></tr></table></figure></p><p>這時候又發現沒有辦法在 html 載入圖片，因為缺少一個在 html 中處理圖片的 loader，因此用上述指令安裝。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="hljs-regexp">/\.html$/</span>,</span><br><span class="line">  use: [ &#123;</span><br><span class="line">    loader: <span class="hljs-string">'html-loader'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">      minimize: <span class="hljs-literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>新增一個 loader，更改<code>webpack.config.js</code>設定。</p><h2 id="壓縮圖片"><a href="#壓縮圖片" class="headerlink" title="壓縮圖片"></a>壓縮圖片</h2><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ npm install image-webpack-loader --save-dev</span><br></pre></td></tr></table></figure></p><p>安裝<code>image-webpack-loader</code>。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="hljs-regexp">/\.(gif|png|jpe?g|svg)$/i</span>,</span><br><span class="line">    use: [&#123;</span><br><span class="line">            loader: <span class="hljs-string">'file-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">                name: <span class="hljs-string">'[name].[ext]'</span>,</span><br><span class="line">                outputPath: <span class="hljs-string">'./img/'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            loader: <span class="hljs-string">'image-webpack-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">                bypassOnDebug: <span class="hljs-literal">true</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更改<code>webpack.config.js</code>裡面<code>file-loader</code>的設定。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ ls -lh src/img</span><br><span class="line">$ ls -lh dist/img</span><br></pre></td></tr></table></figure></p><p>輸入指令可以查看圖片大小的落差，有些圖片太小會比較沒有感覺。</p><p>另外如果要在 js 檔使用圖片，則須在 js 內引入<code>import img from &#39;./img/logo.png&#39;;</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Vue】Vue-cli 安裝</title>
      <link href="/vue-cli-2-install/"/>
      <url>/vue-cli-2-install/</url>
      
        <content type="html"><![CDATA[<p>版本：vue-cli 2.9.3</p><a id="more"></a><h2 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h2><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ npm install -g vue-cli // 全域安裝</span><br></pre></td></tr></table></figure></p><p>vue-cli ，必須在 node.js 下安裝，<br>安裝完之後，可以用<code>vue -v</code>檢查版本。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ vue list</span><br></pre></td></tr></table></figure></p><p>vue-cli 官方提供多種樣版結構，可使用<code>vue list</code>查看樣板種類。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ vue init &lt;template-name&gt; &lt;project-name&gt;</span><br></pre></td></tr></table></figure></p><p>這邊我們選擇<code>webpack</code>版。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Generate project in current directory? Yes</span><br><span class="line">? Project name vuecli-demo</span><br><span class="line">? Project description A Vue.js project</span><br><span class="line">? Author // 預設</span><br><span class="line">? Vue build standalone // 預設</span><br><span class="line">? Install vue-router? // 是否安裝 vue-router</span><br><span class="line">? Use ESLint to lint your code? // 是否使用 eslint 檢測js</span><br><span class="line">? Set up unit tests // 使否單元測試</span><br><span class="line">? Setup e2e tests with Nightwatch? //是否使用 e2e 測試</span><br><span class="line">? Should we run `npm install` for you after the project has been created? Yes, use NPM</span><br><span class="line">//在專案創建好，是否跑 npm install</span><br></pre></td></tr></table></figure></p><p>這邊會有像建置<code>package.json</code>一樣的選項讓你填寫，這邊我先選預設，並不安裝其他項目。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">To get started:</span><br><span class="line"></span><br><span class="line">  cd vuecli-demo</span><br><span class="line">  npm run dev</span><br></pre></td></tr></table></figure></p><p>接下來根據指令到專案資料夾跑 server ，便完成這次安裝。</p><h2 id="產出的專案資料夾結構"><a href="#產出的專案資料夾結構" class="headerlink" title="產出的專案資料夾結構"></a>產出的專案資料夾結構</h2><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── build          // 與 webpack 相關</span><br><span class="line">├── config         // 與 webpack 相關</span><br><span class="line">├── node_modules   // node npm 模組</span><br><span class="line">├── src            // 主要開發環境 source code</span><br><span class="line">|   ├── assets     // 圖片等靜態檔</span><br><span class="line">|   ├── router     // vue 路由器</span><br><span class="line">|   ├── app.vue    // 主要的樣板檔</span><br><span class="line">|   ├── main.js    // 主要的 js 檔，套件 import 的入口文件</span><br><span class="line">|   └── components // vue 元件檔</span><br><span class="line">├── static         // 放置第三方 plugin 位置</span><br><span class="line">├── index.html     // 靜態 html檔</span><br><span class="line">├── package.json</span><br><span class="line">└── package-lock.json</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30】Day20：Native Speech Recognition</title>
      <link href="/javascript-30-day20/"/>
      <url>/javascript-30-day20/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://javascript30.com/" target="_blank" rel="noopener">javascript 30day</a></p></blockquote><a id="more"></a><h3 id="目標：在頁面上啟用語音辨識並輸入文字。"><a href="#目標：在頁面上啟用語音辨識並輸入文字。" class="headerlink" title="目標：在頁面上啟用語音辨識並輸入文字。"></a><span style="color:#ff5900">目標：在頁面上啟用語音辨識並輸入文字。</span></h3><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">window</span>.SpeechRecognition = <span class="hljs-built_in">window</span>.SpeechRecognition || <span class="hljs-built_in">window</span>.webkitSpeechRecognition;</span><br></pre></td></tr></table></figure></p><p>作業一開始已經先將全域語音辨識指定好，這次練習也要啟用本地端 server 。</p><h2 id="一、建立語音辨識物件"><a href="#一、建立語音辨識物件" class="headerlink" title="一、建立語音辨識物件"></a>一、建立語音辨識物件</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> recognition = <span class="hljs-keyword">new</span> SpeechRecognition();</span><br><span class="line"><span class="hljs-comment">// 建立一個變數為語音辨識</span></span><br><span class="line">recognition.interimResults = <span class="hljs-literal">true</span>;</span><br><span class="line"><span class="hljs-comment">// 允許語音辨識回傳識別後的資料</span></span><br></pre></td></tr></table></figure></p><h2 id="二、新增輸入區域文字段落"><a href="#二、新增輸入區域文字段落" class="headerlink" title="二、新增輸入區域文字段落"></a>二、新增輸入區域文字段落</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> p = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'p'</span>);</span><br><span class="line"><span class="hljs-comment">// 建立段落</span></span><br><span class="line"><span class="hljs-keyword">const</span> words = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.words'</span>);</span><br><span class="line"><span class="hljs-comment">// 選取輸入區域</span></span><br><span class="line">words.appendChild(p);</span><br><span class="line"><span class="hljs-comment">// 使段落新增到輸入區域中</span></span><br></pre></td></tr></table></figure></p><p>三、整合語音資訊到輸入區域</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">recognition.addEventListener(<span class="hljs-string">'result'</span>, e =&gt; &#123;</span><br><span class="line">  <span class="hljs-comment">// 監聽識別後的結果回傳資料</span></span><br><span class="line">  <span class="hljs-keyword">const</span> transcript = <span class="hljs-built_in">Array</span>.from(e.results)</span><br><span class="line">    <span class="hljs-comment">// 因為得到的是 nodelist ，所以先轉為陣列</span></span><br><span class="line">    .map(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> result[<span class="hljs-number">0</span>])</span><br><span class="line">    <span class="hljs-comment">// 透過陣列取得資料中的第一筆</span></span><br><span class="line">    .map(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> result.transcript)</span><br><span class="line">    <span class="hljs-comment">// 再取出第一筆中的 transcript 資料</span></span><br><span class="line">    .join(<span class="hljs-string">''</span>);</span><br><span class="line">  <span class="hljs-comment">// 使用 join 取消連結符號</span></span><br><span class="line"></span><br><span class="line">  p.textContent = transcript;</span><br><span class="line">  <span class="hljs-comment">// 將回傳的文字內容放入段落中</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (e.results[<span class="hljs-number">0</span>].isFinal) &#123;</span><br><span class="line">    <span class="hljs-comment">// 假設回傳內容結束 則放入一個新段落到輸入區域中</span></span><br><span class="line">    p = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'p'</span>);</span><br><span class="line">    words.appendChild(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">recognition.addEventListener(<span class="hljs-string">'end'</span>, recognition.start);</span><br><span class="line"><span class="hljs-comment">// 如果語音辨識結束，則重新打開語音辨識。</span></span><br><span class="line">recognition.start();</span><br><span class="line"><span class="hljs-comment">// 開始語音辨識</span></span><br></pre></td></tr></table></figure></p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ul><li>SpeechRecognition.interimResults</li></ul>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS30系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30】Day19：Unreal Webcam Fun</title>
      <link href="/javascript-30-day19/"/>
      <url>/javascript-30-day19/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://javascript30.com/" target="_blank" rel="noopener">javascript 30day</a></p></blockquote><a id="more"></a><h3 id="目標：取用攝影機，預覽截圖存檔。"><a href="#目標：取用攝影機，預覽截圖存檔。" class="headerlink" title="目標：取用攝影機，預覽截圖存檔。"></a><span style="color:#ff5900">目標：取用攝影機，預覽截圖存檔。</span></h3><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> video = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.player'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> canvas = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.photo'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> ctx = canvas.getContext(<span class="hljs-string">'2d'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> strip = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.strip'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> snap = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.snap'</span>);</span><br></pre></td></tr></table></figure></p><p>練習檔案已經先取用 DOM，開始練習前，要先啟用本地端 server。<br>必須加裝 node.js ，並在練習資料夾的 terminal 輸入以下指令。<br><code>npm install</code><br><code>npm start</code></p><h2 id="一、取用攝影機"><a href="#一、取用攝影機" class="headerlink" title="一、取用攝影機"></a>一、取用攝影機</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getVideo</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  navigator.mediaDevices</span><br><span class="line">    .getUserMedia(&#123; <span class="hljs-attr">video</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">audio</span>: <span class="hljs-literal">false</span> &#125;)</span><br><span class="line">    <span class="hljs-comment">// 取得使用者攝影機裝置，並利用 promise 回傳</span></span><br><span class="line">    .then(<span class="hljs-function"><span class="hljs-params">localMediaStream</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="hljs-built_in">console</span>.log(localMediaStream);</span><br><span class="line">      video.src = <span class="hljs-built_in">window</span>.URL.createObjectURL(localMediaStream);</span><br><span class="line">      video.play();</span><br><span class="line">      <span class="hljs-comment">// 如果回傳成功，將回傳的 localMediaStream 寫入 html video tag 並播放。</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'no'</span>, err);</span><br><span class="line">      <span class="hljs-comment">// 如果回傳失敗，送出錯誤訊息</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getVideo();</span><br></pre></td></tr></table></figure></p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">video.addEventListener(<span class="hljs-string">'canplay'</span>, paintToCanvas);</span><br></pre></td></tr></table></figure></p><p>二、將資料，寫進 canvas</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">paintToCanvas</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">const</span> width = video.videoWidth;</span><br><span class="line">  <span class="hljs-keyword">const</span> height = video.videoHeight;</span><br><span class="line">  <span class="hljs-comment">// 取用影像寬高</span></span><br><span class="line"></span><br><span class="line">  canvas.width = width;</span><br><span class="line">  canvas.height = height;</span><br><span class="line">  <span class="hljs-comment">// 使影像寬高等於 canvas 寬高</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-comment">// 每16毫秒 取用一次影像</span></span><br><span class="line">    ctx.drawImage(video, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);</span><br><span class="line">    <span class="hljs-comment">// 讓影像為繪圖來源，寬、高、XY軸位置與 video 相同。</span></span><br><span class="line">    <span class="hljs-keyword">let</span> pixels = ctx.getImageData(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);</span><br><span class="line">    <span class="hljs-comment">// 取用 canvas 圖像數據資料</span></span><br><span class="line">    pixels = rgbSplit(pixels);</span><br><span class="line">    <span class="hljs-comment">// 將資料傳進 rgbSplit，增加濾鏡效果，再重新寫入 pixels</span></span><br><span class="line">    ctx.globalAlpha = <span class="hljs-number">0.1</span>;</span><br><span class="line">    <span class="hljs-comment">// 調節 canvas 透明度</span></span><br><span class="line">    ctx.putImageData(pixels, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);</span><br><span class="line">    <span class="hljs-comment">// 將圖像數據指定到 canvas 上</span></span><br><span class="line">  &#125;, <span class="hljs-number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>console.log(pixels)</code>會發現，canvas 圖像數據資料都是數個陣列所組成，數據為數字，順序皆為 RGBA 輪迴。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rgbSplit</span>(<span class="hljs-params">pixels</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; pixels.data.length; i += <span class="hljs-number">4</span>) &#123;</span><br><span class="line">    pixels.data[i - <span class="hljs-number">150</span>] = pixels.data[i + <span class="hljs-number">0</span>] + <span class="hljs-number">100</span>;</span><br><span class="line">    pixels.data[i + <span class="hljs-number">500</span>] = pixels.data[i + <span class="hljs-number">1</span>] - <span class="hljs-number">50</span>;</span><br><span class="line">    pixels.data[i - <span class="hljs-number">550</span>] = pixels.data[i + <span class="hljs-number">2</span>] * <span class="hljs-number">0.5</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> pixels;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此增加濾鏡效果，四個數值為一個輪迴，巡迴<code>data</code>陣列 RGB 的數值，並作修改。</p><p>三、拍照效果</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">takePhoto</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  snap.currentTime = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-comment">// 音效轉回第 0 秒</span></span><br><span class="line">  snap.play();</span><br><span class="line">  <span class="hljs-comment">// 播放</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">const</span> data = canvas.toDataURL(<span class="hljs-string">'image/jpeg'</span>);</span><br><span class="line">  <span class="hljs-comment">// 將資料轉為 base64 的文字資料</span></span><br><span class="line">  <span class="hljs-keyword">const</span> link = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'a'</span>);</span><br><span class="line">  <span class="hljs-comment">// 建立一個 a 連結</span></span><br><span class="line">  link.href = data;</span><br><span class="line">  <span class="hljs-comment">// 連結位置設置為 base64 位置</span></span><br><span class="line">  link.setAttribute(<span class="hljs-string">'download'</span>, <span class="hljs-string">'pretty'</span>);</span><br><span class="line">  <span class="hljs-comment">// 設為連結提供下載</span></span><br><span class="line">  link.innerHTML = <span class="hljs-string">`&lt;img src="<span class="hljs-subst">$&#123;data&#125;</span>" alt="pretty" /&gt;`</span>;</span><br><span class="line">  <span class="hljs-comment">// 將圖片預覽</span></span><br><span class="line">  strip.insertBefore(link, strip.firstChild);</span><br><span class="line">  <span class="hljs-comment">// 在圖片區域放入新的圖片，並使新圖片新增在第一個位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ul><li>MediaDevices.getUserMedia()</li><li>CanvasRenderingContext2D.drawImage()</li><li>HTMLCanvasElement.toDataURL()</li><li>Node.insert Before()</li><li>CanvasRenderingContext2D.getImageData()</li><li>putImageData()</li></ul>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS30系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Webpack】plugin 與 loader</title>
      <link href="/webpack-4-plugin-loade/"/>
      <url>/webpack-4-plugin-loade/</url>
      
        <content type="html"><![CDATA[<p>新手從無到有，初探 webpack 的心得。</p><p>此篇介紹 plugin 及 loader 簡單的使用方法，承襲上一篇的內容，逐步實作做下去。<br>介紹的 plgin / loader 如下。</p><ul><li>利用 template 產出 html</li><li>載入 css / sass 並另外產出 css 檔並引入</li><li>在本地端運行伺服器</li><li>自動清除殘餘檔案</li><li>babel 及 pug 轉譯</li><li>HMR</li></ul><p>版本：webpack 4.1.1</p><a id="more"></a><h2 id="Plugin-與-loader-介紹"><a href="#Plugin-與-loader-介紹" class="headerlink" title="Plugin 與 loader 介紹"></a>Plugin 與 loader 介紹</h2><blockquote><p>Plugin 為外掛程式，普遍常用，在這邊不多作介紹。</p></blockquote><blockquote><p>Loaders are transformations that are applied on the source code of a module. They allow you to pre-process files as you import or “load” them. Thus, loaders are kind of like “tasks” in other build tools, and provide a powerful way to handle front-end build steps. Loaders can transform files from a different language (like TypeScript) to JavaScript, or inline images as data URLs. Loaders even allow you to do things like import CSS files directly from your JavaScript modules!</p></blockquote><p>官方網站表明，loader 就像其他前端開發任務建構工具一樣，他可以將 typescript 轉換成 js ，<br>或是將圖片轉換成內嵌 url ，或是直接在 js 模組中導入 css 文件。</p><h2 id="使用-html-webpack-plugin"><a href="#使用-html-webpack-plugin" class="headerlink" title="使用 html-webpack-plugin"></a>使用 html-webpack-plugin</h2><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ npm install --save-dev html-webpack-plugin</span><br></pre></td></tr></table></figure></p><p>在專案資料夾執行命令安裝，安裝完成後，會在<code>package.json</code>檔案下發現</p><p><figure class="highlight hljs"><table><tr><td class="code"><pre><span class="line">"devDependencies": &#123;</span><br><span class="line">   "html-webpack-plugin": "^3.0.6",</span><br><span class="line">   "webpack": "^4.1.1"</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h4 id="產生-html-檔"><a href="#產生-html-檔" class="headerlink" title="產生 html 檔"></a>產生 html 檔</h4><p>將<code>webpack.config.js</code>更改如下。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="hljs-string">'./src/app.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + <span class="hljs-string">'/dist'</span>,</span><br><span class="line">    filename: <span class="hljs-string">'app.bundle.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [<span class="hljs-keyword">new</span> HtmlWebpackPlugin()],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>執行<code>npm run build</code>，就會產生<code>index.html</code>，並自動載入 js 檔。</p><h4 id="自動載入-title"><a href="#自動載入-title" class="headerlink" title="自動載入 title"></a>自動載入 title</h4><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="hljs-string">'./src/app.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + <span class="hljs-string">'/dist'</span>,</span><br><span class="line">    filename: <span class="hljs-string">'app.bundle.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: <span class="hljs-string">'hello world'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>更改<code>webpack.config</code>後，標題則會自己更換，但為了不要一個個文件標題都要自行更改，必須使用到 template 。</p><h4 id="template"><a href="#template" class="headerlink" title="template"></a>template</h4><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="hljs-string">'./src/app.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + <span class="hljs-string">'/dist'</span>,</span><br><span class="line">    filename: <span class="hljs-string">'app.bundle.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: <span class="hljs-string">'hello world'</span>,</span><br><span class="line">      template: <span class="hljs-string">'./src/index.html'</span>,</span><br><span class="line">      filename: <span class="hljs-string">'index.html'</span>,</span><br><span class="line">      minify: &#123;</span><br><span class="line">        collapseWhitespace: <span class="hljs-literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>更改<code>webpack.config</code>後，新增<code>src/index.html</code>的 template 樣板。</p><p><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">%=</span> <span class="hljs-attr">htmlWebpackPlugin.options.title</span> %&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>執行<code>npm run build</code>，因為<code>minify: {collapseWhitespace: true,},</code>，<br>所以輸出的 html 為壓縮形式沒有空格。</p><p><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>hi<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"app.bundle.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="css-loader-style-loader"><a href="#css-loader-style-loader" class="headerlink" title="css-loader / style-loader"></a>css-loader / style-loader</h2><p>新增<code>src/app.css</code></p><p><figure class="highlight css hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-selector-tag">body</span> &#123;</span><br><span class="line">  <span class="hljs-attribute">background</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>變更<code>src/app.js</code></p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> css <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hello world'</span>);</span><br></pre></td></tr></table></figure></p><p>在一般沒有加裝 loader 的狀況下，webpack 沒有辦法處理 css 文件，<br>此時執行<code>npm run build</code>則會出現錯誤。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ npm install --save-dev css-loader style-loader</span><br></pre></td></tr></table></figure></p><p>因此加裝<code>css-loader</code>及<code>style-loader</code>。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="hljs-string">'./src/app.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + <span class="hljs-string">'/dist'</span>,</span><br><span class="line">    filename: <span class="hljs-string">'app.bundle.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="hljs-string">'./src/index.html'</span>,</span><br><span class="line">      filename: <span class="hljs-string">'index.html'</span>,</span><br><span class="line">      minify: &#123;</span><br><span class="line">        collapseWhitespace: <span class="hljs-literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      hash: <span class="hljs-literal">true</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="hljs-built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="hljs-regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="hljs-string">'style-loader'</span>, <span class="hljs-string">'css-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>然後變更<code>webpack.config.js</code>，運行<code>npm run build</code>，<br>再用瀏覽器打開<code>dist/index.html</code>，則會發現 css 已經載進 html 頁面。</p><p><code>test: /\.css$/</code>表示他是處理 css 文件，在處理 css 文件時，則是由陣列右邊執行到陣列左邊（裝飾模式）。<br><code>css-loader</code>先解析處理，再由<code>style-loader</code>則會將 css 嵌入 html。</p><h2 id="sass-loader"><a href="#sass-loader" class="headerlink" title="sass-loader"></a>sass-loader</h2><p><figure class="highlight scss hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-selector-tag">body</span> &#123;</span><br><span class="line">  <span class="hljs-attribute">background</span>: pink;</span><br><span class="line">  <span class="hljs-selector-tag">p</span> &#123;</span><br><span class="line">    <span class="hljs-attribute">color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>將<code>app.css</code>更改為<code>app.scss</code>，並修改為巢狀。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> css <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.scss'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hello world'</span>);</span><br></pre></td></tr></table></figure></p><p>更改<code>app.js</code>。</p><p><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello world<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><code>src/index.html</code>輸入<code>p</code>段落文字。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="hljs-string">'./src/app.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + <span class="hljs-string">'/dist'</span>,</span><br><span class="line">    filename: <span class="hljs-string">'app.bundle.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="hljs-string">'./src/index.html'</span>,</span><br><span class="line">      filename: <span class="hljs-string">'index.html'</span>,</span><br><span class="line">      minify: &#123;</span><br><span class="line">        collapseWhitespace: <span class="hljs-literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      hash: <span class="hljs-literal">true</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="hljs-built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="hljs-regexp">/\.scss$/</span>,</span><br><span class="line">        use: [<span class="hljs-string">'style-loader'</span>, <span class="hljs-string">'css-loader'</span>, <span class="hljs-string">'sass-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>更改<code>webpack.config.js</code>，則可運行 sass ，打開 source code 會發現裡面只有載入<code>app.bundle.js</code>，但有時候需要將 css 和 js 分離，則使用<code>extract-text-webpack-plugin</code>。</p><h2 id="extract-text-webpack-plugin"><a href="#extract-text-webpack-plugin" class="headerlink" title="extract-text-webpack-plugin"></a>extract-text-webpack-plugin</h2><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">$ npm i -d extract-text-webpack-plugin@next</span><br></pre></td></tr></table></figure></p><p>安裝套件。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> ExtractTextPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'extract-text-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="hljs-string">'./src/app.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + <span class="hljs-string">'/dist'</span>,</span><br><span class="line">    filename: <span class="hljs-string">'app.bundle.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="hljs-string">'./src/index.html'</span>,</span><br><span class="line">      filename: <span class="hljs-string">'index.html'</span>,</span><br><span class="line">      minify: &#123;</span><br><span class="line">        collapseWhitespace: <span class="hljs-literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      hash: <span class="hljs-literal">true</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="hljs-keyword">new</span> ExtractTextPlugin(<span class="hljs-string">'style.css'</span>),</span><br><span class="line">  ],</span><br><span class="line">  <span class="hljs-built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="hljs-regexp">/\.scss$/</span>,</span><br><span class="line">        use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          fallback: <span class="hljs-string">'style-loader'</span>,</span><br><span class="line">          <span class="hljs-comment">//resolve-url-loader may be chained before sass-loader if necessary</span></span><br><span class="line">          use: [<span class="hljs-string">'css-loader'</span>, <span class="hljs-string">'sass-loader'</span>],</span><br><span class="line">        &#125;),</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>更改<code>webpack.config.js</code>後，執行<code>npm run build</code>，則會發現<code>index.html</code>另外載入<code>style.css</code>。</p><h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>之前使用的<code>webpack -d --watch</code>適合運作在靜態文件上，但在開發狀態<code>webpack-dev-server</code>是更好的選擇。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ npm install -g webpack-dev-server // 全域安裝</span><br><span class="line">$ npm install --save-dev webpack-dev-server // 區域安裝</span><br></pre></td></tr></table></figure></p><p>接著執行。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ webpack-dev-server</span><br></pre></td></tr></table></figure></p><p><img src="/img/webpack/webpack03-1.png" alt></p><p>server 執行成功，port 號為 <code>8080</code>。</p><p><img src="/img/webpack/webpack03-2.png" alt></p><p>我們也可以到<code>webpack.config.js</code>改 port 號，設定<code>open:true</code>，自動打開瀏覽器。</p><h4 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h4><p>webpack-dev-server 有提供代理伺服器的功能。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="hljs-string">'./src/app.js'</span>,</span><br><span class="line">  ...</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    port: <span class="hljs-number">9000</span>,</span><br><span class="line">    open: <span class="hljs-literal">true</span>,</span><br><span class="line">    proxy: &#123;</span><br><span class="line">          <span class="hljs-string">"/api"</span>: &#123;</span><br><span class="line">            target: <span class="hljs-string">"https://other-server.example.com"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>為了避免跨域的狀況，當請求 api 的時候，便會呼叫 <code>target</code>。</p><h2 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel loader"></a>babel loader</h2><p><code>babel-loader</code>就是一個轉譯器，將一些瀏覽器不支援的 js 寫法或檔案，轉譯成瀏覽器可以讀取的檔案。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ npm install --save-dev babel-loader</span><br></pre></td></tr></table></figure></p><p>在專案下安裝<code>babel-loader</code>。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">rules: [</span><br><span class="line">      ...,</span><br><span class="line">      &#123; <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>, <span class="hljs-attr">loader</span>: <span class="hljs-string">'babel-loader'</span>, <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span> &#125;</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure></p><p>便可執行轉譯。</p><h2 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean webpack plugin"></a>clean webpack plugin</h2><p>主要運用在產出檔案前，將原資料夾檔案清空，一開始我們先更改原本的設定。</p><p><code>webpack.config.js</code></p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">entry: &#123;</span><br><span class="line">    <span class="hljs-string">'app.bundle'</span>: <span class="hljs-string">'./src/app.js'</span></span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">    path: __dirname + <span class="hljs-string">'/dist'</span>,</span><br><span class="line">    filename: <span class="hljs-string">'[name].[chunkhash].js'</span></span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>將產出的 js 檔名更改為 hash 值，避免檔名重複出現錯誤。</p><p>這時只要修改<code>src/app.js</code>，<code>webpack</code>就會重新產生一個 js 檔，<br>因此需要<code>clean webpack plugin</code>將原本的舊的檔案清除，如此一來就不會累積過多的舊檔案。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ npm i clean-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure></p><p>在專案資料夾，使用 npm 指令安裝。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="hljs-keyword">const</span> CleanWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'clean-webpack-plugin'</span>);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">plugins: [</span><br><span class="line">    <span class="hljs-keyword">new</span> CleanWebpackPlugin([<span class="hljs-string">'dist'</span>]),</span><br><span class="line">    ...</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure></p><p>呼叫套件，並指定清空檔案的資料夾，這時候再使用<code>npm run build</code>觀察，此時發現<code>dist</code>資料夾下只剩下一隻 js 檔。</p><h2 id="pug-html-loader"><a href="#pug-html-loader" class="headerlink" title="pug-html-loader"></a>pug-html-loader</h2><p>pug(jade) 是 html 的樣板語言，猶如 sass 和 css 之間的關係，這邊先不多作解釋。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ npm install --save-dev pug pug-html-loader raw-loader</span><br></pre></td></tr></table></figure></p><p>先安裝 pug 、 pug-html-loader 和 raw-loader。<br>加裝 raw-loader 是因為 pug-html-loader 必須依附在這個 loader 下，<br>google 未果，我不知道為什麼，如果有人知道，歡迎在下方留言告訴我。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">doctype html</span><br><span class="line">html(lang=&quot;en&quot;)</span><br><span class="line">  head</span><br><span class="line">    title= pageTitle</span><br><span class="line">    script(type=&apos;text/javascript&apos;).</span><br><span class="line">      if (foo) bar(1 + 5)</span><br><span class="line">  body</span><br><span class="line">    h1 Pug - node template engine</span><br><span class="line">    #root</span><br><span class="line">    #container.col</span><br><span class="line">      if youAreUsingPug</span><br><span class="line">        p You are amazing</span><br><span class="line">      else</span><br><span class="line">        p Get on it!</span><br><span class="line">      p.</span><br><span class="line">        Pug is a terse and simple templating language with a</span><br><span class="line">        strong focus on performance and powerful features.</span><br></pre></td></tr></table></figure></p><p>為了測試是否能正確將 pug 編譯出來，先將<code>src/index.html</code>改為<code>src/index.pug</code>，<br>並將內容更改為 pug 的格式，內容如上。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    ...</span><br><span class="line">    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="hljs-string">'./src/index.pug'</span>,</span><br><span class="line">      ...</span><br><span class="line">    &#125;),</span><br><span class="line">    ...</span><br><span class="line">  ],</span><br><span class="line"> <span class="hljs-built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      ...</span><br><span class="line">      &#123; <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.pug$/</span>, <span class="hljs-attr">loader</span>: [<span class="hljs-string">'raw-loader'</span>, <span class="hljs-string">'pug-html-loader'</span>] &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>再將<code>webpack.config.js</code>進行修改，並下指令運行，便可成功轉譯。</p><h2 id="使用-HMR-監看修改的-CSS"><a href="#使用-HMR-監看修改的-CSS" class="headerlink" title="使用 HMR 監看修改的 CSS"></a>使用 HMR 監看修改的 CSS</h2><p><code>webpack --watch</code>及<code>webpack-dev-server</code> 是監聽文件的變化自動刷新瀏覽器，<br>而 HMR  不是刷新整個瀏覽器，只會讓已經修改的部分，出現修改後的變化。</p><p>先將剛剛修改的 pug template 改回 html template。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">devServer: &#123;</span><br><span class="line">    port: <span class="hljs-number">9000</span>,</span><br><span class="line">    open: <span class="hljs-literal">true</span>,</span><br><span class="line">    hot: <span class="hljs-literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">plugins: [</span><br><span class="line">    <span class="hljs-keyword">new</span> webpack.NamedModulesPlugin(),</span><br><span class="line">    <span class="hljs-keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure></p><p>修改<code>webpack.config.js</code>，並運行。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">ERROR in chunk app.bundle [entry]</span><br><span class="line">[name].[chunkhash].js</span><br><span class="line">Cannot use [chunkhash] for chunk in &apos;[name].[chunkhash].js&apos; (use [hash] instead)</span><br></pre></td></tr></table></figure></p><p>接下來就會爆出錯誤訊息，需要將<code>chunkhash</code>改成<code>hash</code>。<br><code>chunkhash</code>是根據 Entry 文件內容，編譯出對應的 hash 值。<br><code>hash</code>是只要文件內容有更改，當次被編譯出來的相關文件 hash 都會變更，而且相同。</p><p>另外提一個叫<code>contenthash</code>，假設<code>index.css</code>被<code>index.js</code>引用，<br>但更改的文件只有<code>index.js</code>時，會產生<code>index.css</code>也會被重新編譯，<br>如此會產生重複內容的檔案，這時候輸入<code>contenthash</code>只要該文件內容不改變，也不會重新編譯。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    path: __dirname + <span class="hljs-string">'/dist'</span>,</span><br><span class="line">    filename: <span class="hljs-string">'[name].[hash].js'</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>接下來將 output 的檔名進行更改，此時運行時你會發現頁面完全不會改變。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">new</span> ExtractTextPlugin(&#123;</span><br><span class="line">  filename: <span class="hljs-string">'style.css'</span>,</span><br><span class="line">  disable: <span class="hljs-literal">true</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure></p><p>只要將<code>ExtractTextPlugin</code>修改，便可以自動更新頁面，<br>這意味著產出 css 和 HMR，只能二選一，我們可以將開發環境和生產環境分離，便可以解決。</p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Webpack】認識 webpack</title>
      <link href="/webpack-4-first-try/"/>
      <url>/webpack-4-first-try/</url>
      
        <content type="html"><![CDATA[<p>新手從無到有，初探 webpack 的心得，webpack 的基本介紹、比較，以及如何運用相關套件簡單運行。</p><p>版本：webpack 4.1.1</p><a id="more"></a><h2 id="定義"><a href="#定義" class="headerlink" title="定義"></a>定義</h2><blockquote><p>At its core, webpack is a static module bundler for modern JavaScript applications. When webpack processes your application, it recursively builds a dependency graph that includes every module your application needs, then packages all of those modules into one or more bundles.</p></blockquote><p>webpack ， 簡單來說就是一個模組打包工具，可以將開發中的資料，如 html 文件、sass、圖片等資料，<br>模組化，利用<code>loader</code>、<code>plugin</code>轉換成瀏覽器可以閱讀的資料並打包。</p><h2 id="比較"><a href="#比較" class="headerlink" title="比較"></a>比較</h2><p>有些人會拿 webpack 跟 gulp 之類的工具做比較，讓我們先看看 gulp 官網的解釋。</p><blockquote><p>gulp is a toolkit for automating painful or time-consuming tasks in your development workflow, so you can stop messing around and build something.</p></blockquote><p>gulp ，用於在開發流程中，自動執行較耗時或較痛苦的任務，<br>意思是 gulp 為任務執行工具，可以通過定義<code>task</code>自動化來執行處理任務。</p><p>gulp 為任務執行工具，注重的是開發流程； webpack 強調模組化開發，處理壓縮文件、圖片等。</p><h2 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h2><p>webpack 必須運行在 <code>node.js</code> 的環境下。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ npm install -g webpack</span><br></pre></td></tr></table></figure></p><p>全域安裝 webpack。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">webpack -v</span><br></pre></td></tr></table></figure></p><p>安裝完後檢測版本，確認是否已經安裝。</p><h2 id="npm-初始化"><a href="#npm-初始化" class="headerlink" title="npm 初始化"></a>npm 初始化</h2><p>先進到你要存放的目錄</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ mkdir webpack-demo</span><br><span class="line">$ cd webpack-demo</span><br><span class="line">$ npm init</span><br></pre></td></tr></table></figure></p><p>接下來會出現<code>package.json</code>配置，可以全部 enter 跑預設。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">name: (webpack-demo)</span><br><span class="line">version: (1.0.0)</span><br><span class="line">description:</span><br><span class="line">entry point: (index.js)</span><br><span class="line">test command:</span><br><span class="line">git repository:</span><br></pre></td></tr></table></figure></p><p>接下來在<code>webpack-demo</code>下面出現<code>package.json</code>。</p><p><figure class="highlight json hljs"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"webpack-demo"</span>,</span><br><span class="line">  <span class="hljs-attr">"version"</span>: <span class="hljs-string">"1.0.0"</span>,</span><br><span class="line">  <span class="hljs-attr">"description"</span>: <span class="hljs-string">""</span>,</span><br><span class="line">  <span class="hljs-attr">"main"</span>: <span class="hljs-string">"index.js"</span>,</span><br><span class="line">  <span class="hljs-attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="hljs-attr">"test"</span>: <span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="hljs-attr">"author"</span>: <span class="hljs-string">""</span>,</span><br><span class="line">  <span class="hljs-attr">"license"</span>: <span class="hljs-string">"ISC"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>這些都是關於這個專案的內容，可以根據專案狀況更改。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ npm install --save-dev webpack</span><br></pre></td></tr></table></figure></p><p>接下來在專案上安裝 webpack 。</p><p><figure class="highlight hljs"><table><tr><td class="code"><pre><span class="line">"devDependencies": &#123;</span><br><span class="line">    "webpack": "^4.1.1"</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p><code>package.json</code>就會出現 webpack 的安裝資料。</p><h2 id="運行-webpack"><a href="#運行-webpack" class="headerlink" title="運行 webpack"></a>運行 webpack</h2><p>現在來試著運作 webpack ，在目錄下新增<code>src/app.js</code>，內容如下。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hello webpack'</span>);</span><br></pre></td></tr></table></figure></p><p>在 terminal 輸入指令。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ webpack ./src/app.js --output ./dist/app.bundle.js</span><br></pre></td></tr></table></figure></p><p>目錄資料結構就變成這樣</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── dist</span><br><span class="line">|   └── app.bundle.js</span><br><span class="line">├── node_modules</span><br><span class="line">├── package.json</span><br><span class="line">└── src</span><br><span class="line">    └── app.js</span><br></pre></td></tr></table></figure></p><p><code>app.bundle.js</code><br><img src="/img/webpack/webpack01.png" alt></p><h2 id="webpack-指令"><a href="#webpack-指令" class="headerlink" title="webpack 指令"></a>webpack 指令</h2><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">webpack --watch ./src/app.js ./dist/app.bundle.js</span><br></pre></td></tr></table></figure></p><p><code>watch</code>指令可以監聽檔案狀況做變更。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ webpack -p ./src/app.js ./dist/app.bundle.js</span><br></pre></td></tr></table></figure></p><p><code>-p</code>指令可以產出生產版壓縮過的檔案。</p><p>如果想看其他指令可以在 terminal 輸入</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ webpack --help</span><br></pre></td></tr></table></figure></p><p>假設你只有在專案上面安裝 webpack，則輸入</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ npx webpack --help</span><br></pre></td></tr></table></figure></p><h2 id="配置-webpack"><a href="#配置-webpack" class="headerlink" title="配置 webpack"></a>配置 webpack</h2><p>在根目錄創建<code>webpack.config.js</code>的檔案，內容如下。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="hljs-string">'./src/app.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="hljs-string">'./app.bundle.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>entry</code>為 source code，<code>output</code>是輸出的目標文件，配置完後，在 terminal 輸入 <code>webpack</code> 即可運行。</p><h2 id="快速下-webpack-指令"><a href="#快速下-webpack-指令" class="headerlink" title="快速下 webpack 指令"></a>快速下 webpack 指令</h2><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ npm install webpack-cli -d</span><br></pre></td></tr></table></figure></p><p>安裝<code>webpack-cli</code>，再改寫目前的<code>package.json</code>。</p><p><figure class="highlight json hljs"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"wepback-demo"</span>,</span><br><span class="line">  <span class="hljs-attr">"version"</span>: <span class="hljs-string">"1.0.0"</span>,</span><br><span class="line">  <span class="hljs-attr">"description"</span>: <span class="hljs-string">""</span>,</span><br><span class="line">  <span class="hljs-attr">"main"</span>: <span class="hljs-string">"index.js"</span>,</span><br><span class="line">  <span class="hljs-attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="hljs-attr">"build"</span>: <span class="hljs-string">"webpack -d --watch"</span>,</span><br><span class="line">    <span class="hljs-attr">"prod"</span>: <span class="hljs-string">"webpack -p"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="hljs-attr">"author"</span>: <span class="hljs-string">""</span>,</span><br><span class="line">  <span class="hljs-attr">"license"</span>: <span class="hljs-string">"ISC"</span>,</span><br><span class="line">  <span class="hljs-attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="hljs-attr">"webpack"</span>: <span class="hljs-string">"^3.8.1"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>改寫之後，在 terminal 輸入指令。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ npm run build</span><br></pre></td></tr></table></figure></p><p>則會運行<code>webpack -d --watch</code>。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ npm run prod</span><br></pre></td></tr></table></figure></p><p>則會運行<code>webpack -p</code>。</p><p>使用<code>script</code>指令的好處是把所有命令集中在一起，方便維護查看，<br>其他開發者只要看<code>package.json</code>就可以知道大概運行的開發指令是什麼。</p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30】Day18：Adding Up Times with Reduce</title>
      <link href="/javascript-30-day18/"/>
      <url>/javascript-30-day18/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://javascript30.com/" target="_blank" rel="noopener">javascript 30day</a></p></blockquote><a id="more"></a><h3 id="目標：使用-reduce-總和所有播放影片的時間"><a href="#目標：使用-reduce-總和所有播放影片的時間" class="headerlink" title="目標：使用 reduce 總和所有播放影片的時間"></a><span style="color:#ff5900">目標：使用 reduce 總和所有播放影片的時間</span></h3><h2 id="一、抓-DOM"><a href="#一、抓-DOM" class="headerlink" title="一、抓 DOM"></a>一、抓 DOM</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> timeNodes = <span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'[data-time]'</span>));</span><br><span class="line"><span class="hljs-keyword">const</span> seconds = timeNodes.map(<span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> node.dataset.time);</span><br></pre></td></tr></table></figure></p><p>使用<code>[...]</code>或<code>Array.from()</code>先將取用到的<code>dataset</code>的 nodelist 轉換成陣列。</p><h2 id="二、加總計算"><a href="#二、加總計算" class="headerlink" title="二、加總計算"></a>二、加總計算</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> seconds = timeNodes</span><br><span class="line">  .map(<span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> node.dataset.time)</span><br><span class="line">  .map(<span class="hljs-function"><span class="hljs-params">timeCode</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> [mins, secs] = timeCode.split(<span class="hljs-string">':'</span>).map(<span class="hljs-built_in">parseFloat</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> mins * <span class="hljs-number">60</span> + secs;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(mins, secs);</span><br><span class="line">  &#125;)</span><br><span class="line">  .reduce(<span class="hljs-function">(<span class="hljs-params">total, vidSecondes</span>) =&gt;</span> total + vidSecondes);</span><br></pre></td></tr></table></figure></p><p>使用<code>map</code>轉換成新陣列，取用<code>dataset</code>的數值，使用<code>split</code>刪除<code>:</code>符號分割，<br>並從字串轉換為數字， 分鐘轉換秒數加總，再使用<code>reduce</code>做陣列加總。</p><h2 id="三、計算小時"><a href="#三、計算小時" class="headerlink" title="三、計算小時"></a>三、計算小時</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> secondsLeft = seconds;</span><br><span class="line"><span class="hljs-keyword">const</span> hours = <span class="hljs-built_in">Math</span>.floor(secondsLeft / <span class="hljs-number">3600</span>);</span><br><span class="line">secondsLeft = secondsLeft % <span class="hljs-number">3600</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> mins = <span class="hljs-built_in">Math</span>.floor(secondsLeft / <span class="hljs-number">60</span>);</span><br><span class="line">secondsLeft = secondsLeft % <span class="hljs-number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(hours, mins, secondsLeft);</span><br></pre></td></tr></table></figure></p><p>計算小時，將秒數轉換成小時後，使用<code>Math.floor()</code>取用整數，<br>再使用<code>%</code>計算剩餘的秒數，再以同樣的方法轉換分鐘，便可以計算出所有影片的小時/分鐘/秒數。</p><h2 id="三、計算分鐘"><a href="#三、計算分鐘" class="headerlink" title="三、計算分鐘"></a>三、計算分鐘</h2><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS30系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30】Day17：Sort Without Articles</title>
      <link href="/javascript-30-day17/"/>
      <url>/javascript-30-day17/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://javascript30.com/" target="_blank" rel="noopener">javascript 30day</a></p></blockquote><a id="more"></a><h3 id="目標：排除某些文字下進行陣列排序"><a href="#目標：排除某些文字下進行陣列排序" class="headerlink" title="目標：排除某些文字下進行陣列排序"></a><span style="color:#ff5900">目標：排除某些文字下進行陣列排序</span></h3><h2 id="一、排序陣列"><a href="#一、排序陣列" class="headerlink" title="一、排序陣列"></a>一、排序陣列</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> sortedBands = band.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">  &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>將原本的陣列做排序，但因為有<code>a</code>、<code>an</code>、<code>the</code>等冠詞，造成無法正確依照字母順序做排序。</p><h2 id="二、使用正規表示法過濾冠詞"><a href="#二、使用正規表示法過濾冠詞" class="headerlink" title="二、使用正規表示法過濾冠詞"></a>二、使用正規表示法過濾冠詞</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">strip</span>(<span class="hljs-params">bandName</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> bandName.replace(<span class="hljs-regexp">/^(a |the |an )/i</span>, <span class="hljs-string">''</span>).trim();</span><br></pre></td></tr></table></figure></p><h2 id="三、排序過濾好的陣列"><a href="#三、排序過濾好的陣列" class="headerlink" title="三、排序過濾好的陣列"></a>三、排序過濾好的陣列</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> sortedBands = bans.sort(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span> strip(a):strip(b) ? <span class="hljs-number">1</span>:<span class="hljs-number">-1</span>);</span><br></pre></td></tr></table></figure></p><p>這邊使用三元運算子及箭頭函式。</p><h2 id="四、渲染-DOM"><a href="#四、渲染-DOM" class="headerlink" title="四、渲染 DOM"></a>四、渲染 DOM</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#bands'</span>).innerHTML = sortedBands.map(<span class="hljs-function"><span class="hljs-params">band</span> =&gt;</span> <span class="hljs-string">`&lt;li&gt;<span class="hljs-subst">$&#123;band&#125;</span>&lt;/li&gt;`</span>).join(<span class="hljs-string">''</span>);</span><br></pre></td></tr></table></figure></p><p>這邊加上<code>join();</code>是因為在陣列裡面，字串的區隔是逗號，<br>如果不寫入<code>join</code>，則會把逗號一起渲染。</p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ul><li>正規表示法</li><li>map</li><li>join</li><li>sort</li></ul>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS30系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30】Day16：Mouse Move Shadow</title>
      <link href="/javascript-30-day16/"/>
      <url>/javascript-30-day16/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://javascript30.com/" target="_blank" rel="noopener">javascript 30day</a></p></blockquote><a id="more"></a><h3 id="目標：滑鼠移動時，CSS-的陰影跟著移動。"><a href="#目標：滑鼠移動時，CSS-的陰影跟著移動。" class="headerlink" title="目標：滑鼠移動時，CSS 的陰影跟著移動。"></a><span style="color:#ff5900">目標：滑鼠移動時，CSS 的陰影跟著移動。</span></h3><h2 id="一、設立目標區域"><a href="#一、設立目標區域" class="headerlink" title="一、設立目標區域"></a>一、設立目標區域</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> hero = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.hero'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> text = hero.querySelector(<span class="hljs-string">'h1'</span>);</span><br></pre></td></tr></table></figure></p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shadow</span>(<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> &#123;</span><br><span class="line">        offsetWidth: width,</span><br><span class="line">        offsetHeight: height</span><br><span class="line">    &#125; = hero;</span><br><span class="line">    <span class="hljs-comment">// 利用解構賦值取得目標寬高</span></span><br><span class="line">    <span class="hljs-keyword">let</span> &#123;</span><br><span class="line">        offsetX: x,</span><br><span class="line">        offsetY: y</span><br><span class="line">    &#125; = e;</span><br><span class="line">    <span class="hljs-comment">// 取得滑鼠位置</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> !== e.target) &#123;</span><br><span class="line">        x = x + e.target.offsetLeft;</span><br><span class="line">        y = y + e.target.offsetTop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// 如果在目標區域外 則加入目標座標值</span></span><br></pre></td></tr></table></figure></p><h2 id="二、設定偏移量"><a href="#二、設定偏移量" class="headerlink" title="二、設定偏移量"></a>二、設定偏移量</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> walk = <span class="hljs-number">100</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> xWalk = <span class="hljs-built_in">Math</span>.round((x / width * walk) - (walk / <span class="hljs-number">2</span>));</span><br><span class="line"><span class="hljs-keyword">const</span> yWalk = <span class="hljs-built_in">Math</span>.round((y / height * walk) - (walk / <span class="hljs-number">2</span>));</span><br><span class="line"><span class="hljs-comment">// 並四捨五入偏移值</span></span><br><span class="line"></span><br><span class="line">text.style.textShadow =</span><br><span class="line">  <span class="hljs-string">` <span class="hljs-subst">$&#123;xWalk&#125;</span>px <span class="hljs-subst">$&#123;yWalk&#125;</span>px 0 rgba(255,0,255,0.7),</span></span><br><span class="line"><span class="hljs-string">    <span class="hljs-subst">$&#123;xWalk * <span class="hljs-number">-1</span>&#125;</span>px <span class="hljs-subst">$&#123;yWalk&#125;</span>px 0 rgba(0,255,255,0.7),</span></span><br><span class="line"><span class="hljs-string">    <span class="hljs-subst">$&#123;yWalk&#125;</span>px <span class="hljs-subst">$&#123;xWalk * <span class="hljs-number">-1</span>&#125;</span>px 0 rgba(0,255,0,0.7),</span></span><br><span class="line"><span class="hljs-string">    <span class="hljs-subst">$&#123;yWalk * <span class="hljs-number">-1</span>&#125;</span>px <span class="hljs-subst">$&#123;xWalk&#125;</span>px 0 rgba(0,0,255,0.7)`</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 加入 textShadow</span></span><br><span class="line"></span><br><span class="line">hero.addEventListener(<span class="hljs-string">'mousemove'</span>, shadow);</span><br></pre></td></tr></table></figure></p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ul><li>解構賦值</li></ul>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS30系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30】Day15：LocalStorage</title>
      <link href="/javascript-30-day15/"/>
      <url>/javascript-30-day15/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://javascript30.com/" target="_blank" rel="noopener">javascript 30day</a></p></blockquote><a id="more"></a><h3 id="目標：使用-LocalStorage-做-todolist"><a href="#目標：使用-LocalStorage-做-todolist" class="headerlink" title="目標：使用 LocalStorage 做 todolist"></a><span style="color:#ff5900">目標：使用 LocalStorage 做 todolist</span></h3><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> addItems = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.add-items'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> itemsList = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.plates'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> items = [];</span><br></pre></td></tr></table></figure></p><p>一開始進入 start 作者已經命名好變數。</p><h2 id="一、送出輸入項目"><a href="#一、送出輸入項目" class="headerlink" title="一、送出輸入項目"></a>一、送出輸入項目</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">addItems.addEventListener(<span class="hljs-string">'submit'</span>, addItem);</span><br></pre></td></tr></table></figure></p><p>在<code>input</code>輸入完，送出項目。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addItem</span>(<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  <span class="hljs-comment">// 取消送出資料後的自動刷新頁面</span></span><br><span class="line">  <span class="hljs-keyword">const</span> text = <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'[name=item]'</span>).value;</span><br><span class="line">  <span class="hljs-comment">// item 的輸入值為 text 的 key / value，放入 json 中</span></span><br><span class="line">  <span class="hljs-keyword">const</span> item = &#123;</span><br><span class="line">    text, <span class="hljs-comment">//es6:text:text</span></span><br><span class="line">    done: <span class="hljs-literal">false</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  items.push(item);</span><br><span class="line">  <span class="hljs-comment">//塞入陣列存取</span></span><br><span class="line">  populateList(items, itemsList);</span><br><span class="line">  <span class="hljs-comment">//建html</span></span><br><span class="line">  localStorage.setItem(<span class="hljs-string">'items'</span>, <span class="hljs-built_in">JSON</span>.stringify(items));</span><br><span class="line">  <span class="hljs-comment">//因為重新整理之後，輸入的資料會消失，則必須將資料輸入到瀏覽器的localStorage</span></span><br><span class="line">  <span class="hljs-keyword">this</span>.reset();</span><br><span class="line">  <span class="hljs-comment">//清除輸入框（form的方法）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="二、新建後新增-html"><a href="#二、新建後新增-html" class="headerlink" title="二、新建後新增 html"></a>二、新建後新增 html</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">populateList</span>(<span class="hljs-params">plates = [], platesList</span>) </span>&#123;</span><br><span class="line">  platesList.innerHTML = plates</span><br><span class="line">    .map(<span class="hljs-function">(<span class="hljs-params">plate, i</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-string">`</span></span><br><span class="line"><span class="hljs-string">      &lt;li&gt;</span></span><br><span class="line"><span class="hljs-string">          &lt;input type="checkbox" data-index=<span class="hljs-subst">$&#123;i&#125;</span> id="item<span class="hljs-subst">$&#123;i&#125;</span>" <span class="hljs-subst">$&#123;plate.done ? <span class="hljs-string">'checked'</span> : <span class="hljs-string">''</span>&#125;</span> /&gt;</span></span><br><span class="line"><span class="hljs-string">          &lt;label for="item<span class="hljs-subst">$&#123;i&#125;</span>"&gt;<span class="hljs-subst">$&#123;plate.text&#125;</span>&lt;/label&gt;</span></span><br><span class="line"><span class="hljs-string">      &lt;/li&gt;</span></span><br><span class="line"><span class="hljs-string">      `</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .join(<span class="hljs-string">''</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>新增  html 的<code>li</code>項目。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> items = <span class="hljs-built_in">JSON</span>.parse(localStorage.getItem(<span class="hljs-string">'items'</span>)) || [];</span><br></pre></td></tr></table></figure></p><p>此時<code>items</code>必須更改為以上，假設<code>localStorage</code>有資料則取用，若沒有資料<code>items</code>為空陣列。</p><h2 id="三、儲存-checkbox-狀態"><a href="#三、儲存-checkbox-狀態" class="headerlink" title="三、儲存 checkbox 狀態"></a>三、儲存 checkbox 狀態</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">itemsList.addEventListener(<span class="hljs-string">'click'</span>, toggleDone);</span><br></pre></td></tr></table></figure></p><p><code>ul</code>被點擊後，執行。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toggleDone</span>(<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (!e.target.matches(<span class="hljs-string">'input'</span>)) <span class="hljs-keyword">return</span>;</span><br><span class="line">  <span class="hljs-comment">// input （checkbox）才執行動作</span></span><br><span class="line">  <span class="hljs-keyword">const</span> el = e.target;</span><br><span class="line">  <span class="hljs-keyword">const</span> index = el.dataset.index;</span><br><span class="line">  items[index].done = !items[index].done;</span><br><span class="line">  <span class="hljs-comment">//true / false 切換</span></span><br><span class="line"></span><br><span class="line">  localStorage.setItem(<span class="hljs-string">'items'</span>, <span class="hljs-built_in">JSON</span>.stringify(items));</span><br><span class="line">  <span class="hljs-comment">//存入localStorage</span></span><br><span class="line">  populateList(items, itemsList);</span><br><span class="line">  <span class="hljs-comment">//更新 html</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="四、進入頁面"><a href="#四、進入頁面" class="headerlink" title="四、進入頁面"></a>四、進入頁面</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">populateList(items, itemsList);</span><br></pre></td></tr></table></figure></p><p>假設進入頁面時<code>localStorage</code>有資料，在最底下執行<code>populateList</code>，以刷新 html 。</p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ul><li>localStorage</li><li>dateset</li></ul>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS30系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30】Day14： JavaScript References VS Copying</title>
      <link href="/javascript-30-day14/"/>
      <url>/javascript-30-day14/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://javascript30.com/" target="_blank" rel="noopener">javascript 30day</a></p></blockquote><a id="more"></a><h3 id="目標：理解-javascript-reference-與-copy"><a href="#目標：理解-javascript-reference-與-copy" class="headerlink" title="目標：理解 javascript reference 與 copy"></a><span style="color:#ff5900">目標：理解 javascript reference 與 copy</span></h3><h2 id="原始型別"><a href="#原始型別" class="headerlink" title="原始型別"></a>原始型別</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> age = <span class="hljs-number">100</span>;</span><br><span class="line"><span class="hljs-keyword">let</span> age2 = age;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(age, age2);</span><br><span class="line"><span class="hljs-comment">//100,100</span></span><br><span class="line"></span><br><span class="line">age = <span class="hljs-number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(age, age2);</span><br><span class="line"><span class="hljs-comment">//200,100</span></span><br></pre></td></tr></table></figure></p><p>原始型別都是 Call by value，所以複製時不影響，當<code>age = 200</code>，<br>因為<code>age2</code>已經被定義過，則<code>age</code>的改變不會影響<code>age2</code>。</p><h2 id="陣列"><a href="#陣列" class="headerlink" title="陣列"></a>陣列</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> players = [<span class="hljs-string">'Wes'</span>, <span class="hljs-string">'Sarah'</span>, <span class="hljs-string">'Ryan'</span>, <span class="hljs-string">'Poppy'</span>];</span><br><span class="line"><span class="hljs-keyword">const</span> team = players;</span><br><span class="line"></span><br><span class="line">team[<span class="hljs-number">3</span>] = <span class="hljs-string">'Lux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(team, players);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//['Wes', 'Sarah', 'Ryan', 'Lux']</span></span><br><span class="line"><span class="hljs-comment">//['Wes', 'Sarah', 'Ryan', 'Lux']</span></span><br></pre></td></tr></table></figure></p><p>陣列為 Call by reference ，因為我們更新<code>team</code>，<br>但<code>team</code>本身沒有陣列可以更改，<code>team</code>本身參照<code>player</code>的原始陣列，<br>所以如果你修改原始陣列，或當你更新任何陣列，他就會被修改，陣列參照不同於數字、布林及字串。</p><p>假設你是想複製且更新一份陣列。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> team2 = players.slice();</span><br><span class="line"><span class="hljs-keyword">const</span> team3 = [].concat(players);</span><br><span class="line"><span class="hljs-keyword">const</span> team4 = [...players];</span><br><span class="line"><span class="hljs-keyword">const</span> team5 = <span class="hljs-built_in">Array</span>.from(players);</span><br></pre></td></tr></table></figure></p><h2 id="物件"><a href="#物件" class="headerlink" title="物件"></a>物件</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="hljs-string">'Wes Bos'</span>,</span><br><span class="line">  age: <span class="hljs-number">80</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> captain = person;</span><br><span class="line">captain.number = <span class="hljs-number">99</span>;</span><br></pre></td></tr></table></figure></p><p>物件和陣列相同，屬於 call by reference ，因此為了不要污染到<code>person</code>。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> cap3 = &#123; ...person &#125;;</span><br></pre></td></tr></table></figure></p><p>或</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> cap2 = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, person, &#123;</span><br><span class="line">  number: <span class="hljs-number">99</span>,</span><br><span class="line">  age: <span class="hljs-number">12</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(cap2);</span><br></pre></td></tr></table></figure></p><p>如此，可覆寫原本屬性與值的配對，且<code>person</code>則不會被污染到，但有例外的是。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> wes = &#123;</span><br><span class="line">  name: <span class="hljs-string">'Wes'</span>,</span><br><span class="line">  age: <span class="hljs-number">100</span>,</span><br><span class="line">  social: &#123;</span><br><span class="line">    twitter: <span class="hljs-string">'@wesbos'</span>,</span><br><span class="line">    facebook: <span class="hljs-string">'wesbos.developer'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> dev = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, wes);</span><br><span class="line"></span><br><span class="line">dev.social.twitter = <span class="hljs-string">'@coolman'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(dev.social);</span><br><span class="line"><span class="hljs-comment">// Object &#123; twitter: '@coolman' , facebook: 'wesbos.developer'&#125;</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(wes.social);</span><br><span class="line"><span class="hljs-comment">// Object &#123; twitter: '@coolman' , facebook: 'wesbos.developer'&#125;</span></span><br></pre></td></tr></table></figure></p><p><code>Object.assign</code>僅能做一層複製。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> dev2 = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(wes));</span><br></pre></td></tr></table></figure></p><p>可使用以上做破解。<br>因為使用<code>JSON.stringify</code>，將原本物件的內容，全部轉換成字串，<br>回到原始型別，在用<code>JSON.parse</code>轉成物件，則全部內容都能被複製成功。</p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ul><li>slice()</li><li>concat()</li><li>es6 Spread</li><li>Array.from()</li><li>Object.assign()</li></ul>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS30系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30】Day13：Slide In on Scroll</title>
      <link href="/javascript-30-day13/"/>
      <url>/javascript-30-day13/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://javascript30.com/" target="_blank" rel="noopener">javascript 30day</a></p></blockquote><a id="more"></a><h3 id="目標：滾動捲軸，使圖片滑動顯示。"><a href="#目標：滾動捲軸，使圖片滑動顯示。" class="headerlink" title="目標：滾動捲軸，使圖片滑動顯示。"></a><span style="color:#ff5900">目標：滾動捲軸，使圖片滑動顯示。</span></h3><h2 id="一、設定-transition-設定彈跳動畫效果"><a href="#一、設定-transition-設定彈跳動畫效果" class="headerlink" title="一、設定 transition 設定彈跳動畫效果"></a>一、設定 transition 設定彈跳動畫效果</h2><p>作者已經在 css 上設定好<code>transition</code>。</p><h2 id="二、監聽及觸發"><a href="#二、監聽及觸發" class="headerlink" title="二、監聽及觸發"></a>二、監聽及觸發</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> sliderImages = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'.slide-in'</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'scroll'</span>, debounce(checkSlide));</span><br></pre></td></tr></table></figure></p><p>因為滑動必須用<code>windows</code>選定<code>scroll</code>事件，但因效能上的需求，所以作者多寫一個<code>debounce</code>的<code>function</code>，讓<code>scroll</code>觸發事件間隔 20 秒。</p><h2 id="三、了解視窗高度"><a href="#三、了解視窗高度" class="headerlink" title="三、了解視窗高度"></a>三、了解視窗高度</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkSlide</span>(<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">  sliderImages.forEach(<span class="hljs-function"><span class="hljs-params">sliderImage</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> slideInAt = <span class="hljs-built_in">window</span>.scrollY + <span class="hljs-built_in">window</span>.innerHeight - sliderImage.height / <span class="hljs-number">2</span>;</span><br><span class="line">    <span class="hljs-comment">//圖片1/2的定位點 = 捲軸垂直位移量 + 視窗高度 - 圖片1/2的高度</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">const</span> imageBottom = sliderImage.offsetTop + sliderImage.height;</span><br><span class="line">    <span class="hljs-comment">//圖片底部 = 圖片離視窗頂部的距離 + 圖片高度</span></span><br><span class="line">    <span class="hljs-keyword">const</span> isHalfShown = slideInAt &gt; sliderImage.offsetTop;</span><br><span class="line">    <span class="hljs-comment">//判斷視窗是否超過圖片的一半，超過顯示</span></span><br><span class="line">    <span class="hljs-keyword">const</span> isNotScrolledPast = <span class="hljs-built_in">window</span>.scrollY &lt; imageBottom;</span><br><span class="line">    <span class="hljs-comment">//判斷滾動範圍是否超過圖片底部，超過則不顯示</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (isHalfShown &amp;&amp; isNotScrolledPast) &#123;</span><br><span class="line">      sliderImage.classList.add(<span class="hljs-string">'active'</span>);</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      sliderImage.classList.remove(<span class="hljs-string">'active'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">//判斷是否顯示圖片</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><table><thead><tr><th><code>window.scrollY</code></th><th><code>window.innerHeight</code></th><th><code>sliderImage.offsetTop</code></th><th><code>slideInAt</code></th></tr></thead><tbody><tr><td>捲軸垂直的位移量（不含視窗）</td><td>視窗高度</td><td>圖片離視窗頂部的高度</td><td>圖片 1/2 的定位點</td></tr></tbody></table><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ul><li>window.scrollY：瀏覽器 Y 軸滾動的位移量。</li><li>window.innerHeight：瀏覽器的可視高度。</li><li>offsetTop：傳回當前元素對於<code>offsetParent</code>元素頂部距離的位置。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS30系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30】Day12：Key Sequence Detection</title>
      <link href="/javascript-30-day12/"/>
      <url>/javascript-30-day12/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://javascript30.com/" target="_blank" rel="noopener">javascript 30day</a></p></blockquote><a id="more"></a><h3 id="目標：只有輸入某段特別密碼，才會出現特效。"><a href="#目標：只有輸入某段特別密碼，才會出現特效。" class="headerlink" title="目標：只有輸入某段特別密碼，才會出現特效。"></a><span style="color:#ff5900">目標：只有輸入某段特別密碼，才會出現特效。</span></h3><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> pressed = []; <span class="hljs-comment">//保存已輸入值的陣列</span></span><br><span class="line"><span class="hljs-keyword">const</span> secretCode = <span class="hljs-string">'wesbos'</span>; <span class="hljs-comment">//密碼</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'keyup'</span>, e =&gt; &#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(e.key);</span><br><span class="line">  pressed.push(e.key);</span><br><span class="line">  pressed.splice(-secretCode.length - <span class="hljs-number">1</span>, pressed.length - secretCode.length);</span><br><span class="line">  <span class="hljs-keyword">if</span> (pressed.join(<span class="hljs-string">''</span>).includes(secretCode)) &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'DING DING!'</span>);</span><br><span class="line">    cornify_add();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(pressed);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>使用<code>keyup</code>監聽按鍵行為，觸發時利用陣列的<code>push</code>塞入已經按下按鍵的內容，<br>利用<code>splice</code>來控制陣列的長度，使陣列為最後輸入的五個字元，<br>再以<code>join</code>、<code>includes</code>來驗證輸入值是否和密碼相同，若相同則出現特效。</p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ul><li>splice</li><li>include</li><li>join</li></ul><h2 id="splice-刪除"><a href="#splice-刪除" class="headerlink" title="splice 刪除"></a>splice 刪除</h2><p><strong>array.splice(start[, deleteCount[, item1[, item2[, …]]]])</strong></p><ul><li><p><strong>start</strong><br>索引位置（從 0 開始），如果索引大於陣列長度，則索引值會被設為陣列長度；<br>如果索引為負值（從 -1 開始），則會從陣列最後一個元素往前更動，<br>且若此負數的絕對值大於陣列長度，則會被設置為 0 。</p></li><li><p><strong>deleteCount</strong>，選擇性。<br>表示要刪除原本陣列數量的整數。</p></li><li><p><strong>item1,item2…</strong>，選擇性。<br>從<code>start</code>位置起始，要加入到陣列的元素。</p></li></ul><p>回傳：一個被包含刪除的元素陣列，如果只有一個元素被刪除，<br>依舊是回傳包含一個元素的陣列，倘若沒有元素被刪除，則會回傳空陣列。</p><h2 id="include-包含"><a href="#include-包含" class="headerlink" title="include 包含"></a>include 包含</h2><p><strong>arr.includes(searchElement[, fromIndex])</strong></p><ul><li><p><strong>searchElement</strong><br>要搜尋的元素</p></li><li><p><strong>fromIndex</strong>，選擇性。<br>預設值為 0 ，要在此陣列搜尋<code>searchElement</code>的位置。<br>如果是負數，則自<code>array.length - fromIndex</code>開始搜尋，預設值為 0 。</p></li></ul><p>回傳：布林值</p><h2 id="join-合併字串"><a href="#join-合併字串" class="headerlink" title="join 合併字串"></a>join 合併字串</h2><p><strong>arr.join([separator])</strong></p><ul><li><strong>separator</strong>，選擇性。<br>用來隔開陣列中每個元素的字串。</li></ul><p>如果必要的話，separator 會自動被轉成字串型態，未傳入參數，陣列中的元素將預設用英文逗號（「,」）隔開。<br>如果 separator 是空字串，合併後，元素間不會有任何字元。</p><p>回傳：一個合併所有陣列元素的字串。假如<code>arr.length</code>為 0，將回傳空字串。</p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS30系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30】Day11：Custom Video Player</title>
      <link href="/javascript-30-day11/"/>
      <url>/javascript-30-day11/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://javascript30.com/" target="_blank" rel="noopener">javascript 30day</a></p></blockquote><a id="more"></a><h3 id="目標：使用-html5-video-tag-控制影片"><a href="#目標：使用-html5-video-tag-控制影片" class="headerlink" title="目標：使用 html5 video tag 控制影片"></a><span style="color:#ff5900">目標：使用 html5 video tag 控制影片</span></h3><h3 id="一、先抓取-html5-video-tag-DOM-元素"><a href="#一、先抓取-html5-video-tag-DOM-元素" class="headerlink" title="一、先抓取 html5 video tag DOM 元素"></a>一、先抓取 html5 video tag DOM 元素</h3><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 取得元素</span></span><br><span class="line"><span class="hljs-keyword">const</span> player = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.player'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> video = player.querySelector(<span class="hljs-string">'.viewer'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> progress = player.querySelector(<span class="hljs-string">'.progress'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> progressBar = player.querySelector(<span class="hljs-string">'.progress__filled'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> toggle = player.querySelector(<span class="hljs-string">'.toggle'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> skipButtons = player.querySelectorAll(<span class="hljs-string">'[data-skip]'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> ranges = player.querySelectorAll(<span class="hljs-string">'.player__slider'</span>);</span><br></pre></td></tr></table></figure></p><h3 id="二、建立-function"><a href="#二、建立-function" class="headerlink" title="二、建立 function"></a>二、建立 function</h3><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">togglePlay</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">const</span> method = video.paused ? <span class="hljs-string">'play'</span> : <span class="hljs-string">'pause'</span>;</span><br><span class="line">  <span class="hljs-comment">// 三元運算子 true:play ; false:pause</span></span><br><span class="line">  video[method]();</span><br><span class="line">  <span class="hljs-comment">//抓出video的 play / pause 屬性執行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateButton</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">const</span> icon = <span class="hljs-keyword">this</span>.paused ? <span class="hljs-string">'►'</span> : <span class="hljs-string">'❚ ❚'</span>;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(icon);</span><br><span class="line">  toggle.textContent = icon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skip</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  video.currentTime += <span class="hljs-built_in">parseFloat</span>(<span class="hljs-keyword">this</span>.dataset.skip);</span><br><span class="line">  <span class="hljs-comment">// parseFloat 解析字串並返回數字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleRangeUpdate</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  video[<span class="hljs-keyword">this</span>.name] = <span class="hljs-keyword">this</span>.value; <span class="hljs-comment">// volume/playbackRate</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleProgress</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">const</span> percent = (video.currentTime / video.duration) * <span class="hljs-number">100</span>;</span><br><span class="line">  progressBar.style.flexBasis = <span class="hljs-string">`<span class="hljs-subst">$&#123;percent&#125;</span>%`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scrub</span>(<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">const</span> scrubTime = (e.offsetX / progress.offsetWidth) * video.duration;</span><br><span class="line">  video.currentTime = scrubTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="三、監聽並執行"><a href="#三、監聽並執行" class="headerlink" title="三、監聽並執行"></a>三、監聽並執行</h3><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">video.addEventListener(<span class="hljs-string">'click'</span>, togglePlay); <span class="hljs-comment">//點擊影片控制開關</span></span><br><span class="line">toggle.addEventListener(<span class="hljs-string">'click'</span>, togglePlay); <span class="hljs-comment">//播放鍵控制開關</span></span><br><span class="line">video.addEventListener(<span class="hljs-string">'play'</span>, updateButton);</span><br><span class="line">video.addEventListener(<span class="hljs-string">'pause'</span>, updateButton); <span class="hljs-comment">//控制播放鍵開關狀態</span></span><br><span class="line">video.addEventListener(<span class="hljs-string">'timeupdate'</span>, handleProgress); <span class="hljs-comment">//播放直接更新進度條</span></span><br><span class="line"></span><br><span class="line">skipButtons.forEach(<span class="hljs-function"><span class="hljs-params">button</span> =&gt;</span> button.addEventListener(<span class="hljs-string">'click'</span>, skip)); <span class="hljs-comment">// forEach是因為有前後跳轉</span></span><br><span class="line">ranges.forEach(<span class="hljs-function"><span class="hljs-params">range</span> =&gt;</span> range.addEventListener(<span class="hljs-string">'change'</span>, handleRangeUpdate));</span><br><span class="line">ranges.forEach(<span class="hljs-function"><span class="hljs-params">range</span> =&gt;</span> range.addEventListener(<span class="hljs-string">'mousemove'</span>, handleRangeUpdate)); <span class="hljs-comment">//控制調整音量跟播放速度</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> mousedown = <span class="hljs-literal">false</span>;</span><br><span class="line"><span class="hljs-comment">//因為拖拉進度條，影片感覺像無法跟上，因此再監聽mouseup和mousedown，讓影片進度條更即時</span></span><br><span class="line"></span><br><span class="line">progress.addEventListener(<span class="hljs-string">'click'</span>, scrub); <span class="hljs-comment">//點擊改變進度條</span></span><br><span class="line">progress.addEventListener(<span class="hljs-string">'mousemove'</span>, () =&gt; mousedown &amp;&amp; scrub(e));</span><br><span class="line"><span class="hljs-comment">//拖拉改變進度條，如果mousedown是true，就往後執行scrub(e)，如果false就中斷。</span></span><br><span class="line"></span><br><span class="line">progress.addEventListener(<span class="hljs-string">'mousedown'</span>, () =&gt; (mousedown = <span class="hljs-literal">true</span>)); <span class="hljs-comment">//拖拉改變進度條</span></span><br><span class="line">progress.addEventListener(<span class="hljs-string">'mouseup'</span>, () =&gt; (mousedown = <span class="hljs-literal">false</span>)); <span class="hljs-comment">//拖拉改變進度條</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS30系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30】Day10：Hold Shift and Check Checkboxes</title>
      <link href="/javascript-30-day10/"/>
      <url>/javascript-30-day10/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/js30day/small.jpg" alt></p><blockquote><p><a href="https://javascript30.com/" target="_blank" rel="noopener">javascript 30day</a></p></blockquote><a id="more"></a><h3 id="目標：單點滑鼠選取，加按-shift-區域選取。"><a href="#目標：單點滑鼠選取，加按-shift-區域選取。" class="headerlink" title="目標：單點滑鼠選取，加按 shift 區域選取。"></a><span style="color:#ff5900">目標：單點滑鼠選取，加按 shift 區域選取。</span></h3><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> checkboxes = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'.inbox input[type="checkbox"]'</span>);</span><br><span class="line"><span class="hljs-comment">// 選擇多選框</span></span><br><span class="line">checkboxes.forEach(<span class="hljs-function"><span class="hljs-params">checkbox</span> =&gt;</span> checkbox.addEventListener(<span class="hljs-string">'click'</span>, handleCheck));</span><br><span class="line"><span class="hljs-comment">// 點擊多選框觸發函數</span></span><br><span class="line"><span class="hljs-keyword">let</span> lastChecked;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleCheck</span>(<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// 判斷是否同時按下shift和選擇多選框的參數</span></span><br><span class="line">  <span class="hljs-keyword">let</span> inBetween = <span class="hljs-literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (e.shiftKey &amp;&amp; <span class="hljs-keyword">this</span>.checked) &#123;</span><br><span class="line">    <span class="hljs-comment">// 遍歷所有 checkbox</span></span><br><span class="line"></span><br><span class="line">    checkboxes.forEach(<span class="hljs-function"><span class="hljs-params">checkbox</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="hljs-built_in">console</span>.log(checkbox);</span><br><span class="line">      <span class="hljs-keyword">if</span> (checkbox === <span class="hljs-keyword">this</span> || checkbox === lastChecked) &#123;</span><br><span class="line">        inBetween = !inBetween;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Starting to check them inbetween!'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="hljs-comment">// 勾選區間內為true的checkbox</span></span><br><span class="line">      <span class="hljs-keyword">if</span> (inBetween) &#123;</span><br><span class="line">        checkbox.checked = <span class="hljs-literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lastChecked = <span class="hljs-keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS30系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30】Day09：Dev Tools Domination</title>
      <link href="/javascript-30-day09/"/>
      <url>/javascript-30-day09/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://javascript30.com/" target="_blank" rel="noopener">javascript 30day</a></p></blockquote><a id="more"></a><h3 id="目標：了解開發者工具使用方法"><a href="#目標：了解開發者工具使用方法" class="headerlink" title="目標：了解開發者工具使用方法"></a><span style="color:#ff5900">目標：了解開發者工具使用方法</span></h3><h2 id="一、對-DOM-元素按右鍵下中斷點"><a href="#一、對-DOM-元素按右鍵下中斷點" class="headerlink" title="一、對 DOM 元素按右鍵下中斷點"></a>一、對 DOM 元素按右鍵下中斷點</h2><p><img src="/img/js30day/day9-1.jpg" alt></p><ol><li>subtree modifications: 當子元素發生變化時</li><li>arrtibute modifications: 當元素發生變化時</li><li>node removal: 當元素被移除時</li></ol><h2 id="二、console-log-各種用法"><a href="#二、console-log-各種用法" class="headerlink" title="二、console.log 各種用法"></a>二、console.log 各種用法</h2><ol><li>console.log(‘’); 一邊的 console.log</li><li>console.log(‘%s’);</li><li>console.log(‘%c’);</li><li>console.wran(‘’); 出現警告圖示</li><li>console.error(‘’); 出現錯誤圖示</li><li>console.info(‘’); 出現資訊圖示</li><li>console.assert(Condition Expression,’’); 判斷是否為真，false 則回傳錯誤。</li></ol><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-string">``</span><span class="hljs-string">`</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">8. console.clear(); 清除所有訊息</span></span><br><span class="line"><span class="hljs-string">9. console.dir(); 顯示所有屬性</span></span><br><span class="line"><span class="hljs-string">10. console.groupCollapsed、console.groupEnd 群組化訊息</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">`</span><span class="hljs-string">``</span>js</span><br><span class="line">dogs.forEach(<span class="hljs-function"><span class="hljs-params">dog</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.groupCollapsed(<span class="hljs-string">`<span class="hljs-subst">$&#123;dog.name&#125;</span>`</span>);</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`This is <span class="hljs-subst">$&#123;dog.name&#125;</span>`</span>);</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;dog.name&#125;</span> is <span class="hljs-subst">$&#123;dog.age&#125;</span> years old`</span>);</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;dog.name&#125;</span> is <span class="hljs-subst">$&#123;dog.age * <span class="hljs-number">7</span>&#125;</span> dog years old`</span>);</span><br><span class="line">  <span class="hljs-built_in">console</span>.groupEnd(<span class="hljs-string">`<span class="hljs-subst">$&#123;dog.name&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><ol start="11"><li>console.count(); 累加計數</li></ol><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.count(a);</span><br><span class="line"><span class="hljs-built_in">console</span>.count(a);</span><br><span class="line"><span class="hljs-built_in">console</span>.count(b);</span><br><span class="line">a: <span class="hljs-number">1</span>;</span><br><span class="line">a: <span class="hljs-number">2</span>;</span><br><span class="line">b: <span class="hljs-number">1</span>;</span><br></pre></td></tr></table></figure></p><ol start="12"><li>console.time()、 console.timeEnd() 計算區域範圍執行時間區間</li><li>console.table()</li></ol>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS30系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Hexo】使用 Travis CI 自動佈署 Blog</title>
      <link href="/travis-ci-deploy/"/>
      <url>/travis-ci-deploy/</url>
      
        <content type="html"><![CDATA[<p>這兩天忙著處理 Travis CI ，終於有點心得，<br>來簡單分享不加密自動佈署，以及使用 ssh 的方法。</p><a id="more"></a><h2 id="Travis-CI-自動化執行"><a href="#Travis-CI-自動化執行" class="headerlink" title="Travis CI 自動化執行"></a>Travis CI 自動化執行</h2><p>Travis CI 就是一種代理媽媽（？）的概念，他可以代替你在 terminal 的行為，<br>在網路上看到一些分享文章都會要你裝 ruby ，但假設你不加密可以省略這個步驟，<br>因為我們只是一般的部落格，所以我們這邊選擇不加密的方式。</p><p>那我們開始吧。</p><h3 id="一、新建-repository-，並分支。"><a href="#一、新建-repository-，並分支。" class="headerlink" title="一、新建 repository ，並分支。"></a>一、新建 repository ，並分支。</h3><p>首先要先新建一個 repository ，一般來說 master 放 source code 是比較好的，<br>但是因為我的 repository name 是 <code>user.github.io</code> 格式，所以 github page 只能是 master，<br>因此我把 source code 放 branch ，產出的文章放 master 。</p><p><img src="/img/travisci/step01.png" alt><br><img src="/img/travisci/step02.png" alt></p><h3 id="二、申請-token"><a href="#二、申請-token" class="headerlink" title="二、申請 token"></a>二、申請 token</h3><p>在 Github 裡面，進入到<code>Settings</code>。</p><p><img src="/img/travisci/step03.png" alt></p><p>選擇<code>Developer Settings</code>。</p><p><img src="/img/travisci/step04.png" alt></p><p>選擇<code>Personal access tokens</code>再選擇右邊的<code>Generate new token</code>。</p><p><img src="/img/travisci/step05.png" alt></p><p>命名，依照你的需要選擇權限。<br>我自己權限是只選擇第一個<code>repo</code>，當然你也可以全部選起來。</p><p><img src="/img/travisci/step06.png" alt></p><p>接著 Github 就會產生一組編碼，<strong>這個編碼只會出現一次，請務必保存</strong>。</p><h3 id="三、設定-Travis-CI"><a href="#三、設定-Travis-CI" class="headerlink" title="三、設定 Travis CI"></a>三、設定 Travis CI</h3><p>Github 帳號授權連結申請後。</p><p>點進 Travis CI 的<code>Profile</code>。<br><img src="/img/travisci/step07.png" alt></p><p>把你需要自動化的 repository 打開，在點進旁邊的零件圖示。</p><p><img src="/img/travisci/step08.png" alt></p><p>這是放置 Travis CI 環境變數的地方。<br>新增一個<code>GH_TOKEN</code>，值為剛剛 Github 給的編碼，<br>新增一個<code>GH_REF</code>，值為 git repository 的位置，<br>像是我部落格的位置是<code>github.com/leiadot/leiadot.github.io.git</code>。</p><h3 id="四、新增-travis-yml"><a href="#四、新增-travis-yml" class="headerlink" title="四、新增 .travis.yml"></a>四、新增 <code>.travis.yml</code></h3><p><img src="/img/travisci/step09.png" alt></p><p>在<code>.git</code>的同層新增<code>.travis.yml</code>，如果你的 hexo 沒有指定<code>package.json</code>，<br>要將<code># before_install</code>的註解打開，否則 Travis CI 無法執行 hexo 的 command line ，檔案內容如下。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">yml</span><br><span class="line">language: node_js #選擇語言</span><br><span class="line"></span><br><span class="line">node_js: stable #選擇版本</span><br><span class="line"></span><br><span class="line"># before_install:</span><br><span class="line">  # - npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line">install:</span><br><span class="line">  - npm install #安裝npm</span><br><span class="line"></span><br><span class="line">script: #要執行的程式</span><br><span class="line">  - hexo clean # 清除</span><br><span class="line">  - hexo generate # 生成</span><br><span class="line"></span><br><span class="line">after_success: #執行完成後的 git push</span><br><span class="line">  - cd ./public</span><br><span class="line">  - git init</span><br><span class="line">  - git config user.name &quot;你的user帳號&quot;</span><br><span class="line">  - git config user.email &quot;你的email&quot;</span><br><span class="line">  - git add .</span><br><span class="line">  - git commit -m &quot;Update by travis ci&quot;</span><br><span class="line">  - git push --force --quiet &quot;https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;&quot; master:master</span><br><span class="line"></span><br><span class="line">branches: #分支</span><br><span class="line">  only:</span><br><span class="line">    - source</span><br></pre></td></tr></table></figure></p><p><img src="/img/travisci/step10.png" alt></p><p>回到 Travis CI 查看是否執行完成。</p><h2 id="SSH-key-設定"><a href="#SSH-key-設定" class="headerlink" title="SSH key 設定"></a>SSH key 設定</h2><p>要 Travis CI 觸發，必須 branch 要有動作，<br>為了節省打帳號密碼的上傳時間，在這邊簡單介紹 ssh key 設定。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;user@gmail.com&quot;</span><br></pre></td></tr></table></figure></p><p>在 Terminal 上，輸入新建 ssh key 指令。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/home/user/.ssh/id_rsa):</span><br></pre></td></tr></table></figure></p><p>輸入 ssh key 檔案存放位置，一般預設在<code>~/.ssh</code>資料夾裡面，<br>這邊我輸入<code>/home/user/.ssh/id_rsa</code>。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure></p><p>都按<code>Enter</code>跳過</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Your identification has been saved in /home/user/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /home/user/.ssh/id_rsa.pub.</span><br></pre></td></tr></table></figure></p><p>ssh key 檔案產生完成。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure></p><p>到 ssh key 資料夾位置，下<code>cat</code>指令得到 key 碼，<br>在 github 上新增 ssh key 之後。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">ssh -v git@github.com</span><br></pre></td></tr></table></figure></p><p>輸入測試 command line。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.</span><br><span class="line">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure></p><p>得到訊息，輸入<code>yes</code>。</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Hi username! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure></p><p>授權成功</p><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ git remote set-url origin git@github.com:user/repo.git</span><br></pre></td></tr></table></figure></p><p>如果已經 clone 過，只要再掛載這串指令就好。</p>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> TravisCI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30】Day08：Fun with HTML5 Canvas</title>
      <link href="/javascript-30-day08/"/>
      <url>/javascript-30-day08/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://javascript30.com/" target="_blank" rel="noopener">javascript 30day</a></p></blockquote><a id="more"></a><h3 id="目標：使用滑鼠做拖拉繪圖，顏色及筆劃粗細能在繪畫時能產生不同變化。"><a href="#目標：使用滑鼠做拖拉繪圖，顏色及筆劃粗細能在繪畫時能產生不同變化。" class="headerlink" title="目標：使用滑鼠做拖拉繪圖，顏色及筆劃粗細能在繪畫時能產生不同變化。"></a><span style="color:#ff5900">目標：使用滑鼠做拖拉繪圖，顏色及筆劃粗細能在繪畫時能產生不同變化。</span></h3><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> canvas = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#draw'</span>);</span><br><span class="line"><span class="hljs-comment">// 指定canvas畫布</span></span><br><span class="line"><span class="hljs-keyword">const</span> ctx = canvas.getContext(<span class="hljs-string">'2d'</span>);</span><br><span class="line"><span class="hljs-comment">// 渲染環境為2D繪圖</span></span><br><span class="line">canvas.width = <span class="hljs-built_in">window</span>.innerWidth;</span><br><span class="line">canvas.height = <span class="hljs-built_in">window</span>.innerHeight;</span><br><span class="line"><span class="hljs-comment">// 指定畫布寬高</span></span><br><span class="line">ctx.strokeStyle = <span class="hljs-string">'#BADA55'</span>;</span><br><span class="line"><span class="hljs-comment">//指定筆刷顏色</span></span><br><span class="line">ctx.lineJoin = <span class="hljs-string">'round'</span>;</span><br><span class="line"><span class="hljs-comment">// 筆劃轉角形狀</span></span><br><span class="line">ctx.lineCap = <span class="hljs-string">'round'</span>;</span><br><span class="line"><span class="hljs-comment">// 筆劃形狀</span></span><br><span class="line">ctx.lineWidth = <span class="hljs-number">100</span>;</span><br><span class="line"><span class="hljs-comment">// 筆劃寬度</span></span><br><span class="line"><span class="hljs-comment">// ctx.globalCompositeOperation = 'multiply';</span></span><br><span class="line"><span class="hljs-comment">// 圖形相疊時的模式</span></span><br></pre></td></tr></table></figure></p><p>上述參數設定皆為 Canvas 的基本環境設定，<br>比較特別是 <code>globalCompositeOperation</code> ，圖形相疊模式有點像 photoshop 的混合模式。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> isDrawing = <span class="hljs-literal">false</span>;</span><br><span class="line"><span class="hljs-comment">// 判斷是否為繪圖狀態的參數</span></span><br><span class="line"><span class="hljs-keyword">let</span> lastX = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">let</span> lastY = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-comment">// 設定要繪畫的位置參數。</span></span><br><span class="line"><span class="hljs-keyword">let</span> hue = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-comment">// 色相值</span></span><br><span class="line"><span class="hljs-keyword">let</span> direction = <span class="hljs-literal">true</span>;</span><br><span class="line"><span class="hljs-comment">// 判斷繪圖粗細增減</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">draw</span>(<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (!isDrawing) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果繪畫參數為false，則不執行函數</span></span><br><span class="line">  <span class="hljs-built_in">console</span>.log(e);</span><br><span class="line">  ctx.strokeStyle = <span class="hljs-string">`hsl(<span class="hljs-subst">$&#123;hue&#125;</span>, 100%, 50%)`</span>;</span><br><span class="line">  <span class="hljs-comment">// 繪畫時的筆刷顏色為色相變數</span></span><br><span class="line">  ctx.beginPath();</span><br><span class="line">  <span class="hljs-comment">// 啟動 canvas 繪畫路徑</span></span><br><span class="line">  ctx.moveTo(lastX, lastY);</span><br><span class="line">  <span class="hljs-comment">// canvas路徑位置移動到 X、Y 變數。</span></span><br><span class="line">  ctx.lineTo(e.offsetX, e.offsetY);</span><br><span class="line">  <span class="hljs-comment">// 連結點與點之間的座標</span></span><br><span class="line">  ctx.stroke();</span><br><span class="line">  [lastX, lastY] = [e.offsetX, e.offsetY];</span><br><span class="line">  <span class="hljs-comment">//利用解構賦值，使繪畫位置為目前滑鼠位置</span></span><br><span class="line">  hue++;</span><br><span class="line">  <span class="hljs-comment">//色相漸增</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (hue &gt;= <span class="hljs-number">360</span>) &#123;</span><br><span class="line">    hue = <span class="hljs-number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-comment">//但因色相只有360度，只要大於等於360度，色相就再從零開始</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (ctx.lineWidth &gt;= <span class="hljs-number">100</span> || ctx.lineWidth &lt;= <span class="hljs-number">1</span>) &#123;</span><br><span class="line">    direction = !direction;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-comment">//當筆劃寬度大於等於100或小於等於1，則轉換判斷變數</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (direction) &#123;</span><br><span class="line">    ctx.lineWidth++;</span><br><span class="line">  &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">    ctx.lineWidth--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-comment">// 轉換判斷變數</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">canvas.addEventListener(<span class="hljs-string">'mousedown'</span>, e =&gt; &#123;</span><br><span class="line">  isDrawing = <span class="hljs-literal">true</span>;</span><br><span class="line">  [lastX, lastY] = [e.offsetX, e.offsetY];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 當滑鼠按下時，讓滑鼠當下的位置就是繪畫位置，並讓isDrawing為true為繪畫狀態。</span></span><br><span class="line"></span><br><span class="line">canvas.addEventListener(<span class="hljs-string">'mousemove'</span>, draw);</span><br><span class="line"><span class="hljs-comment">// 滑鼠移動時，仍然執行繪畫函數</span></span><br><span class="line">canvas.addEventListener(<span class="hljs-string">'mouseup'</span>, () =&gt; (isDrawing = <span class="hljs-literal">false</span>));</span><br><span class="line">canvas.addEventListener(<span class="hljs-string">'mouseout'</span>, () =&gt; (isDrawing = <span class="hljs-literal">false</span>));</span><br><span class="line"><span class="hljs-comment">// 放開滑鼠時和滑鼠移出時，使繪畫參數為false，不執行繪畫函數。</span></span><br></pre></td></tr></table></figure></p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ul><li>Canvas</li></ul>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS30系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ES6】陣列麻吉罵下篇：Sort、Every、Find、Some</title>
      <link href="/javascript-es6-array-part02/"/>
      <url>/javascript-es6-array-part02/</url>
      
        <content type="html"><![CDATA[<p>在我們初學 Javascript ，最常用到的就是<code>for</code>迴圈，但當案子的複雜度增加，<br>我們常常都要在迴圈外面先建立一個空陣列，而且迴圈都不知道迴到哪去（？）<br>因此 ES6 中，有新增幾個陣列的方法，在這邊介紹幾個陣列的麻吉罵。</p><p>此篇文章的資料及範例程式碼皆擷取自<a href="https://developer.mozilla.org/zh-TW/" target="_blank" rel="noopener">MDN</a>。</p><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" target="_blank" rel="noopener">Sort</a>、<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/every" target="_blank" rel="noopener">Every</a>、<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/find" target="_blank" rel="noopener">Find</a>、<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/some" target="_blank" rel="noopener">Some</a></p><a id="more"></a><ul><li>Sort<br>使用 <code>sort</code> 將陣列中的元素排列至其應當的位置上並返回此陣列。</li><li>Every<br>使用 <code>every</code> 遍歷陣列的每個元素，當陣列的元素只要有一個不符合函式條件，即回傳<code>false</code>，全部的元素都通過條件，即返回<code>true</code>。</li><li>Find<br><code>find</code> 遍歷陣列的每個元素，回傳陣列第一個符合函式條件的元素，callback 隨即結束，若都不符合，則回傳<code>undefined</code>。</li><li>Some<br>使用 <code>some</code> 遍歷陣列的每個元素，當陣列的元素只要有一個符合函式條件，即回傳<code>true</code>，陣列中全部的元素都不符合條件，即返回<code>false</code>。</li></ul><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">arr.sort([compareFunction]);</span><br></pre></td></tr></table></figure></p><p><code>compareFunction</code>：指定函數來定義排序順序。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> items = [</span><br><span class="line">  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">'Edward'</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">21</span> &#125;,</span><br><span class="line">  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">'Sharpe'</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">37</span> &#125;,</span><br><span class="line">  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">'And'</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">45</span> &#125;,</span><br><span class="line">  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">'The'</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">-12</span> &#125;,</span><br><span class="line">  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">'Magnetic'</span> &#125;,</span><br><span class="line">  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">'Zeros'</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">37</span> &#125;,</span><br><span class="line">];</span><br><span class="line">items.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (a.name &gt; b.name) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">if</span> (a.name &lt; b.name) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-comment">// a must be equal to b</span></span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>比較 a , b 元素</th><th>結果</th></tr></thead><tbody><tr><td>compareFunction(a, b) &gt;0</td><td>將 <code>b</code> 排在比 <code>a</code> index 還小處</td></tr><tr><td>compareFunction(a, b) =0</td><td>互相不改變順序</td></tr><tr><td>compareFunction(a, b) &lt;0</td><td>將 <code>a</code> 排在比 <code>b</code> index 還小處</td></tr></tbody></table><h2 id="every"><a href="#every" class="headerlink" title="every"></a>every</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">arr.every(callback[, thisArg])</span><br></pre></td></tr></table></figure></p><ul><li>callback<br>測試元素的函式，可帶入三個傳入參數。<ul><li>element<br>目前被處理中的元素。</li><li>index 選填<br>目前被處理中元素的索引值。</li><li>array 選填<br>呼叫<code>every</code>的陣列本身。</li></ul></li><li>thisArg 選填<br>執行<code>function</code>的<code>this</code>。</li></ul><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isBigEnough</span>(<span class="hljs-params">element, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> element &gt;= <span class="hljs-number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>].every(isBigEnough); <span class="hljs-comment">// false</span></span><br><span class="line">[<span class="hljs-number">12</span>, <span class="hljs-number">54</span>, <span class="hljs-number">18</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>].every(isBigEnough); <span class="hljs-comment">// true</span></span><br></pre></td></tr></table></figure></p><p>因為第一個<code>isBigEnough</code>陣列的<code>5</code>不符合函式條件，因為<code>every</code>回傳<code>false</code>，<br>第二個<code>isBigEnough</code>的陣列元素，全部都符合函式條件，回傳<code>true</code>。</p><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">arr.find(callback[, thisArg])</span><br></pre></td></tr></table></figure></p><ul><li>callback<br>測試元素的函式，可帶入三個傳入參數。<ul><li>element<br>目前被處理中的元素。</li><li>index 選填<br>目前被處理中元素的索引值。</li><li>array 選填<br>呼叫<code>find</code>的陣列本身。</li></ul></li><li>thisArg 選填<br>執行<code>function</code>的<code>this</code>。</li></ul><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> array1 = [<span class="hljs-number">5</span>, <span class="hljs-number">12</span>, <span class="hljs-number">8</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> found = array1.find(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> element &gt; <span class="hljs-number">10</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(found);</span><br><span class="line"><span class="hljs-comment">// expected output: 12</span></span><br></pre></td></tr></table></figure></p><p><code>find</code>執行後，第一個符合<code>element &gt; 10</code>條件的數值為<code>12</code>，<br>則<code>found</code>的變數值為<code>12</code>，且傳入變數<code>found</code>為數值，而非陣列。</p><h2 id="some"><a href="#some" class="headerlink" title="some"></a>some</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">arr.some(callback[, thisArg])</span><br></pre></td></tr></table></figure></p><ul><li>callback<br>測試元素的函式，可帶入三個傳入參數。<ul><li>element<br>目前被處理中的元素。</li><li>index 選填<br>目前被處理中元素的索引值。</li><li>array 選填<br>呼叫<code>some</code>的陣列本身。</li></ul></li><li>thisArg 選填<br>執行<code>function</code>的<code>this</code>。</li></ul><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isBiggerThan10</span>(<span class="hljs-params">element, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> element &gt; <span class="hljs-number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>].some(isBiggerThan10); <span class="hljs-comment">// false</span></span><br><span class="line">[<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>].some(isBiggerThan10); <span class="hljs-comment">// true</span></span><br></pre></td></tr></table></figure></p><p>因為第一個<code>isBiggerThan10</code>陣列全部不符合函式條件，所以回傳<code>false</code>，<br>第二個<code>isBiggerThan10</code>的第一個元素<code>12</code>，符合函式條件，則回傳<code>true</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30】Day07：Array Cardio Day 2</title>
      <link href="/javascript-30-day07/"/>
      <url>/javascript-30-day07/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://javascript30.com/" target="_blank" rel="noopener">javascript 30day</a></p></blockquote><a id="more"></a><h3 id="目標：說明並練習這些在-JS-中常用的幾個陣列方法"><a href="#目標：說明並練習這些在-JS-中常用的幾個陣列方法" class="headerlink" title="目標：說明並練習這些在 JS 中常用的幾個陣列方法"></a><span style="color:#ff5900">目標：說明並練習這些在 JS 中常用的幾個陣列方法</span></h3><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ul><li>Array.prototype.some()</li><li>Array.prototype.find()</li><li>Array.prototype.findIndex()</li></ul><p><a href="/2018/02/15/javascript/ES6/array02">參考文章：【 ES6 】陣列麻吉罵下篇：Sort、Every、Find、Some</a></p><p><strong>Array.prototype.some()</strong></p><h3 id="一-使用-some-確認陣列是否有元素-gt-19-。"><a href="#一-使用-some-確認陣列是否有元素-gt-19-。" class="headerlink" title="一. 使用 some 確認陣列是否有元素 &gt;=19 。"></a>一. 使用 <code>some</code> 確認陣列是否有元素 &gt;=19 。</h3><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> isAdult = people.some(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">person</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">const</span> currentYear = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getFullYear();</span><br><span class="line">  <span class="hljs-keyword">if</span> (currentYear - person.year &gt;= <span class="hljs-number">19</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-comment">//Output:true</span></span><br></pre></td></tr></table></figure></p><p>或改寫成 <code>arrow function</code></p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> isAdult = people.some(<span class="hljs-function"><span class="hljs-params">person</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getFullYear() - person.year &gt;= <span class="hljs-number">19</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(&#123; isAdult &#125;);</span><br></pre></td></tr></table></figure></p><p><code>some</code>會遍歷整個陣列的元素傳進<code>function</code>，確認元素是否符合條件，假設其中一個元素符合條件，<br>即返回<code>true</code>，假設整個陣列都沒有元素符合條件，返回<code>false</code>。</p><p><strong>Array.prototype.every()</strong></p><h3 id="二-使用-every-確認陣列是否有元素-gt-19。"><a href="#二-使用-every-確認陣列是否有元素-gt-19。" class="headerlink" title="二. 使用 every 確認陣列是否有元素 &gt;=19。"></a>二. 使用 <code>every</code> 確認陣列是否有元素 &gt;=19。</h3><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> allAdults = people.every(<span class="hljs-function"><span class="hljs-params">person</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getFullYear() - person.year &gt;= <span class="hljs-number">19</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(&#123; allAdults &#125;);</span><br></pre></td></tr></table></figure></p><p><code>every</code>會遍歷整個陣列的元素傳進<code>function</code>，檢查陣列中所有元素是否符合條件，符合條件即回傳<code>true</code>，<br>只要有一個元素不符合，則回傳<code>false</code>。</p><p><strong>Array.prototype.find()</strong></p><h3 id="三-尋找-id-是-823424-的留言。"><a href="#三-尋找-id-是-823424-的留言。" class="headerlink" title="三. 尋找 id 是 823424 的留言。"></a><span id="三-尋找-id-是-823424-的留言">三. 尋找 id 是 823424 的留言。</span></h3><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> comment = comments.find(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">comment</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (comment.id == <span class="hljs-string">'823423'</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(comment);</span><br><span class="line"><span class="hljs-comment">//Output:&#123;text: "Super good", id: 823423&#125;</span></span><br></pre></td></tr></table></figure></p><p>試著自己改寫<code>arrow function</code>。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> comment = comments.find(<span class="hljs-function"><span class="hljs-params">comment</span> =&gt;</span> comment.id == <span class="hljs-string">'823423'</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(comment);</span><br></pre></td></tr></table></figure></p><p><code>find</code>會遍歷整個陣列，假使有元素符合條件，及返回元素值為<br><code>true</code>的元素，<br>和<code>filter</code>不同的差別為，<code>find</code>只會回傳第一個符合條件的元素值。</p><p><strong>Array.prototype.findIndex()</strong></p><h3 id="四-刪除-id-為-823434-的留言"><a href="#四-刪除-id-為-823434-的留言" class="headerlink" title="四.刪除 id 為 823434 的留言"></a><span id="四刪除-id-為-823434-的留言">四.刪除 id 為 823434 的留言</span></h3><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> index = comments.findIndex(<span class="hljs-function"><span class="hljs-params">comment</span> =&gt;</span> comment.id === <span class="hljs-number">823423</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(index);</span><br><span class="line"><span class="hljs-comment">//Output:1</span></span><br><span class="line">comments.splice(index, <span class="hljs-number">1</span>);</span><br></pre></td></tr></table></figure></p><p>或是將<code>comments.splice(index, 1);</code>改寫成</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> newComments = [...comments.slice(<span class="hljs-number">0</span>, index), ...comments.slice(index + <span class="hljs-number">1</span>)];</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS30系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ES6】陣列麻吉罵上篇：ForEach、Filter、Map、Reduce</title>
      <link href="/javascript-es6-array-part01/"/>
      <url>/javascript-es6-array-part01/</url>
      
        <content type="html"><![CDATA[<p>在我們初學 Javascript ，最常用到的就是<code>for</code>迴圈，但當案子的複雜度增加，<br>我們常常都要在迴圈外面先建立一個空陣列，而且迴圈都不知道迴到哪去（？）<br>因此 ES6 中，有新增幾個陣列的方法，在這邊介紹幾個陣列的麻吉罵。</p><p>此篇文章的資料及範例程式碼皆擷取自<a href="https://developer.mozilla.org/zh-TW/" target="_blank" rel="noopener">MDN</a>。</p><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" target="_blank" rel="noopener">ForEach</a>、<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" target="_blank" rel="noopener">Filter</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener">Map</a>、<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="noopener">Reduce</a></p><a id="more"></a><ul><li>forEach<br><code>forEach</code> 循環陣列的每個元素。</li><li>filter()<br><code>filter</code> 遍歷陣列的每個元素，回傳 <code>true</code> 時，目前的值會保留在原本的陣列，這會回傳一個新陣列，而不是修改原本陣列的值。</li><li>map()<br><code>map</code> 會給你一組一樣長度的新陣列，雖然<code>filter</code>也是產生一個新的陣列，但<code>filter</code>僅會把有符合<code>function</code>檢驗的元素回傳到新陣列（陣列長度不一定相同）。</li><li>reduce()<br>使用 <code>reduce</code> 把陣列內的內容組合並最終回傳一個結果。</li></ul><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">arr.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params">currentValue[, index[, array]]</span>) </span>&#123;</span><br><span class="line">&#125;[, thisArg]);</span><br></pre></td></tr></table></figure></p><ul><li>callback<br>將把<code>array</code>的子元素當作參數，各別帶進這個<code>function</code>。</li><li>currentValue<br>目前被處理中的元素。</li><li>index 選填<br>目前被處理中元素的索引值。</li><li>array 選填<br>呼叫<code>forEach</code>的 array 本身。</li><li>thisArg 選填<br>執行<code>function</code>的<code>this</code>。</li></ul><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> items = [<span class="hljs-string">'item1'</span>, <span class="hljs-string">'item2'</span>, <span class="hljs-string">'item3'</span>];</span><br><span class="line"><span class="hljs-keyword">const</span> copy = [];</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">  copy.push(items[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 for 迴圈。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> items = [<span class="hljs-string">'item1'</span>, <span class="hljs-string">'item2'</span>, <span class="hljs-string">'item3'</span>];</span><br><span class="line"><span class="hljs-keyword">const</span> copy = [];</span><br><span class="line"></span><br><span class="line">items.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;</span><br><span class="line">  copy.push(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>使用 forEach。</p><p>比較下來，forEach 跟 for 迴圈是有同樣效果，但 forEach 省略一長串的寫法。</p><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> newArray = arr.filter(callback[, thisArg])</span><br></pre></td></tr></table></figure></p><ul><li>callback<br>測試陣列中的每個元素，回傳值為<code>true</code>的元素值，則保留在新陣列中可帶入三個傳入參數。<ul><li>currentValue<br>目前被處理中的元素。</li><li>index 選填<br>目前被處理中元素的索引值。</li><li>array 選填<br>呼叫<code>forEach</code>的 array 本身。</li></ul></li><li>thisArg 選填<br>執行<code>function</code>的<code>this</code>。</li></ul><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> newArray = arr.filter(callback[, thisArg])</span><br></pre></td></tr></table></figure></p><p>filter 會將陣列中通過 function 檢驗的元素組成一組新陣列。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> words = [<span class="hljs-string">'spray'</span>, <span class="hljs-string">'limit'</span>, <span class="hljs-string">'elite'</span>, <span class="hljs-string">'exuberant'</span>, <span class="hljs-string">'destruction'</span>, <span class="hljs-string">'present'</span>];</span><br><span class="line"><span class="hljs-keyword">const</span> result = [];</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (words[i].length &gt; <span class="hljs-number">6</span>) &#123;</span><br><span class="line">    result.push(words[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(result);</span><br><span class="line"><span class="hljs-comment">// expected output: Array ["exuberant", "destruction", "present"]</span></span><br></pre></td></tr></table></figure></p><p>使用 for 迴圈。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> words = [<span class="hljs-string">'spray'</span>, <span class="hljs-string">'limit'</span>, <span class="hljs-string">'elite'</span>, <span class="hljs-string">'exuberant'</span>, <span class="hljs-string">'destruction'</span>, <span class="hljs-string">'present'</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> result = words.filter(<span class="hljs-function"><span class="hljs-params">word</span> =&gt;</span> word.length &gt; <span class="hljs-number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(result);</span><br><span class="line"><span class="hljs-comment">// expected output: Array ["exuberant", "destruction", "present"]</span></span><br></pre></td></tr></table></figure></p><p>使用 filter，跟原 for 比較，省略使用 if、push 的方法，且程式碼更為乾淨簡潔。</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> new_array = arr.map(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params">currentValue[, index[, array]]</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// Return element for new_array</span></span><br><span class="line">&#125;[, thisArg])</span><br></pre></td></tr></table></figure></p><ul><li>callback<br>為產生新陣列的回呼函式。</li><li>currentValue<br>目前被處理中的元素。</li><li>index 選填<br>目前被處理中元素的索引值。</li><li>array 選填<br>呼叫<code>map</code>的陣列。</li><li>thisArg 選填<br>執行<code>function</code>的<code>this</code>。</li></ul><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> kvArray = [&#123; <span class="hljs-attr">key</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">10</span> &#125;, &#123; <span class="hljs-attr">key</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">20</span> &#125;, &#123; <span class="hljs-attr">key</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">30</span> &#125;];</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> reformattedArray = kvArray.map(<span class="hljs-function"><span class="hljs-params">obj</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> rObj = &#123;&#125;;</span><br><span class="line">  rObj[obj.key] = obj.value;</span><br><span class="line">  <span class="hljs-keyword">return</span> rObj;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// reformattedArray：[&#123;1: 10&#125;, &#123;2: 20&#125;, &#123;3: 30&#125;],</span></span><br><span class="line"><span class="hljs-comment">// kvArray is still:</span></span><br><span class="line"><span class="hljs-comment">// [&#123;key: 1, value: 10&#125;,</span></span><br><span class="line"><span class="hljs-comment">//  &#123;key: 2, value: 20&#125;,</span></span><br><span class="line"><span class="hljs-comment">//  &#123;key: 3, value: 30&#125;]</span></span><br></pre></td></tr></table></figure></p><p>使用 map，map 會給你一組一樣長度的新陣列，filter 同樣產生一個新陣列，<br>但因新陣列僅有符合 function 檢驗的元素（陣列長度不一定相同）。</p><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">arr.reduce(callbackFn[(accumlator, currentValue, currentIndex, array)], initialValue);</span><br></pre></td></tr></table></figure></p><p>reduce 將組合的初始數值及陣列中的各個值，傳入函數，化為單一值。</p><ul><li>callbackFn -<code>accumlator</code><br>用來組合累積回呼函式回傳值的組合器。組合器是上一次呼叫後，所回傳的累算數值。 -<code>currentValue</code><br>當次欲組合的元素數值。 -<code>currentIndex</code>選填<br>原陣列所處理中的元素索引。 -<code>array</code> 選填<br>呼叫<code>reduce()</code>方法的陣列。</li><li><code>initialValue</code> 選填<br>組合傳入的初始值，為額外的陣列的初始加值。</li></ul><p>當回呼函式第一次被呼叫時，accumulator 與 currentValue 的值可能為兩種不同的狀況：</p><p>若在呼叫<code>reduce()</code>時有提供<code>initialValue</code>（也就是初始值），<br>則<code>accumulator</code>（組合器）將會等於<code>initialValue</code>，<br>且 <code>currentValue</code>會等於陣列中的第一個元素值。</p><p>若沒有提供 <code>initialValue</code>（初始值），則 <code>accumulator</code>（組合器）會等於陣列的第一個元素值，<br>且 <code>currentValue</code>將會等於陣列的第二個元素值。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">accumulator, currentValue, currentIndex, array</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> accumulator + currentValue;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// output:10</span></span><br></pre></td></tr></table></figure></p><table><thead><tr><th>callback</th><th>accumulator</th><th>currentValue</th><th>currentIndex</th><th>array</th><th>return value</th></tr></thead><tbody><tr><td>first call</td><td>1</td><td>2</td><td>1</td><td>[1, 2, 3, 4 ,5]</td><td>3</td></tr><tr><td>second call</td><td>3</td><td>3</td><td>2</td><td>[1, 2, 3, 4 ,5]</td><td>6</td></tr><tr><td>third call</td><td>6</td><td>4</td><td>3</td><td>[1, 2, 3, 4 ,5]</td><td>10</td></tr><tr><td>fourth call</td><td>10</td><td>5</td><td>4</td><td>[1, 2, 3, 4 ,5]</td><td>15</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30】Day06：Ajax Type Ahead</title>
      <link href="/javascript-30-day06/"/>
      <url>/javascript-30-day06/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://javascript30.com/" target="_blank" rel="noopener">javascript 30day</a></p></blockquote><a id="more"></a><h3 id="目標：完成搜尋功能，並在搜尋關鍵字加上顏色辨識。"><a href="#目標：完成搜尋功能，並在搜尋關鍵字加上顏色辨識。" class="headerlink" title="目標：完成搜尋功能，並在搜尋關鍵字加上顏色辨識。"></a><span style="color:#ff5900">目標：完成搜尋功能，並在搜尋關鍵字加上顏色辨識。</span></h3><h2 id="一、首先將目標-json-指定為變數，使用fetch方法取得資料，塞進空陣列。"><a href="#一、首先將目標-json-指定為變數，使用fetch方法取得資料，塞進空陣列。" class="headerlink" title="一、首先將目標 json 指定為變數，使用fetch方法取得資料，塞進空陣列。"></a>一、首先將目標 json 指定為變數，使用<code>fetch</code>方法取得資料，塞進空陣列。</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">fetch(<span class="hljs-string">'目標url'</span>, HeadersObject)</span><br><span class="line">  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//處理 response</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// Error :(</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p><h2 id="二、建立一個RegExp，使用match方法進行比對。"><a href="#二、建立一個RegExp，使用match方法進行比對。" class="headerlink" title="二、建立一個RegExp，使用match方法進行比對。"></a>二、建立一個<code>RegExp</code>，使用<code>match</code>方法進行比對。</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">numberWithCommas</span>(<span class="hljs-params">x</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> x.toString().replace(<span class="hljs-regexp">/\B(?=(\d&#123;3&#125;)+(?!\d))/g</span>, <span class="hljs-string">','</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 利用正規表示法，在人口數量增加逗點</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayMatches</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">const</span> matchArray = findMatches(<span class="hljs-keyword">this</span>.value, cities);</span><br><span class="line">  <span class="hljs-comment">//輸入值</span></span><br><span class="line">  <span class="hljs-keyword">const</span> html = matchArray</span><br><span class="line">    .map(<span class="hljs-function"><span class="hljs-params">place</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="hljs-keyword">const</span> regex = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-keyword">this</span>.value, <span class="hljs-string">'gi'</span>);</span><br><span class="line">      <span class="hljs-comment">// 呼叫 RegExp 物件的建構函式</span></span><br><span class="line">      <span class="hljs-keyword">const</span> cityName = place.city.replace(regex, <span class="hljs-string">`&lt;span class="hl"&gt;<span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>.value&#125;</span>`</span>);</span><br><span class="line">      <span class="hljs-keyword">const</span> stateName = place.state.replace(regex, <span class="hljs-string">`&lt;span class="hl"&gt;<span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>.value&#125;</span>`</span>);</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-string">`</span></span><br><span class="line"><span class="hljs-string">&lt;li&gt;</span></span><br><span class="line"><span class="hljs-string">&lt;span class="name"&gt;<span class="hljs-subst">$&#123;cityName&#125;</span>, <span class="hljs-subst">$&#123;stateName&#125;</span> </span></span><br><span class="line"><span class="hljs-string">&lt;span class="population"&gt;<span class="hljs-subst">$&#123;numberWithCommas(place.population)&#125;</span></span></span><br><span class="line"><span class="hljs-string">&lt;/li&gt;</span></span><br><span class="line"><span class="hljs-string">`</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .join(<span class="hljs-string">''</span>);</span><br><span class="line">  suggestions.innerHTML = html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="三、監聽change及keyup事件，讓鍵盤在輸入時觸發比對。"><a href="#三、監聽change及keyup事件，讓鍵盤在輸入時觸發比對。" class="headerlink" title="三、監聽change及keyup事件，讓鍵盤在輸入時觸發比對。"></a>三、監聽<code>change</code>及<code>keyup</code>事件，讓鍵盤在輸入時觸發比對。</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">searchInput.addEventListener(<span class="hljs-string">'change'</span>, displayMatches);</span><br><span class="line">searchInput.addEventListener(<span class="hljs-string">'keyup'</span>, displayMatches);</span><br></pre></td></tr></table></figure></p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ul><li>fetch / then / catch / blob</li><li>spread 展開運算子 （ es6 ）</li><li>regExp （ 正規表達式 ）</li><li>match</li><li>replace</li></ul>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS30系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30】Day05：Flex Panel Gallery</title>
      <link href="/javascript-30-day05/"/>
      <url>/javascript-30-day05/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://javascript30.com/" target="_blank" rel="noopener">javascript 30day</a></p></blockquote><a id="more"></a><h3 id="目標：利用-flex-做面板特效"><a href="#目標：利用-flex-做面板特效" class="headerlink" title="目標：利用 flex 做面板特效"></a><span style="color:#ff5900">目標：利用 flex 做面板特效</span></h3><h2 id="一、將主畫面排版"><a href="#一、將主畫面排版" class="headerlink" title="一、將主畫面排版"></a>一、將主畫面排版</h2><p>首先將主畫面排版完成，在各畫面（ panel ）的父層（ panels ）下<code>display:flex</code>，<br>並在各畫面下<code>flex:1</code>，意思為平均分配多餘的空間。</p><h2 id="二、處理字體效果"><a href="#二、處理字體效果" class="headerlink" title="二、處理字體效果"></a>二、處理字體效果</h2><p>再來處理畫面中字體的特效，將畫面中的子元素下垂直水平置中，且為垂直排序。</p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ul><li>transitionend Event</li><li>flexbox</li></ul>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS30系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30】Day04：Array Cardio Day 1</title>
      <link href="/javascript-30-day04/"/>
      <url>/javascript-30-day04/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/js30day/small3.jpg" alt></p><blockquote><p><a href="https://javascript30.com/" target="_blank" rel="noopener">javascript 30day</a></p></blockquote><a id="more"></a><h3 id="目標：說明並練習這些在-JS-中常用的幾個陣列方法"><a href="#目標：說明並練習這些在-JS-中常用的幾個陣列方法" class="headerlink" title="目標：說明並練習這些在 JS 中常用的幾個陣列方法"></a><span style="color:#ff5900">目標：說明並練習這些在 JS 中常用的幾個陣列方法</span></h3><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ul><li>Array.prototype.filter()</li><li>Array.prototype.map()</li><li>Array.prototype.reduce()</li><li>Array.prototype.sort()</li></ul><h2 id="補充"><a href="#補充" class="headerlink" title="補充"></a>補充</h2><ul><li>Array.prototype.forEach()</li></ul><p><a href="/2018/02/15/javascript/ES6/array">參考文章：【 ES6 】陣列麻吉罵上篇：ForEach、Filter、Map、Reduce</a></p><p><strong>Array.prototype.filter()</strong></p><h3 id="一-使用-filter-挑選出生在-15-世紀的發明家。"><a href="#一-使用-filter-挑選出生在-15-世紀的發明家。" class="headerlink" title="一. 使用 filter 挑選出生在 15 世紀的發明家。"></a>一. 使用 <code>filter</code> 挑選出生在 15 世紀的發明家。</h3><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> fifteen = inventors.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">inventor</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (inventor.year &gt;= <span class="hljs-number">1500</span> &amp;&amp; inventor.year &lt; <span class="hljs-number">1600</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//keep it!!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.table(fifteen);</span><br></pre></td></tr></table></figure></p><p>或改寫成 <code>arrow function</code></p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> fifteen = inventors.filter(<span class="hljs-function"><span class="hljs-params">inventor</span> =&gt;</span> inventor.year &gt;= <span class="hljs-number">1500</span> &amp;&amp; inventor.year &lt; <span class="hljs-number">1600</span>);</span><br></pre></td></tr></table></figure></p><p><strong>Array.prototype.map()</strong></p><p>###二. 給予一組擁有 first 與 last 屬性的陣列。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> fullNames = inventors.map(<span class="hljs-function"><span class="hljs-params">inventor</span> =&gt;</span> $&#123;inventor.first&#125; $&#123;inventor.last&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(fullNames);</span><br></pre></td></tr></table></figure></p><p><strong>Array.prototype.sort()</strong></p><h3 id="三-將發明家陣列從年老到年輕排序。"><a href="#三-將發明家陣列從年老到年輕排序。" class="headerlink" title="三. 將發明家陣列從年老到年輕排序。"></a>三. 將發明家陣列從年老到年輕排序。</h3><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> ordered = inventors.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (a.year &gt; b.year) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">  &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> ordered = inventors.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> (a.year &gt; b.year ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>));</span><br><span class="line"><span class="hljs-built_in">console</span>.table(ordered);</span><br></pre></td></tr></table></figure></p><p><strong>Array.prototype.reduce()</strong></p><h3 id="四-發明家們總共活了多少年？"><a href="#四-發明家們總共活了多少年？" class="headerlink" title="四. 發明家們總共活了多少年？"></a>四. 發明家們總共活了多少年？</h3><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> totalYears = inventors.reduce(<span class="hljs-function">(<span class="hljs-params">total, inventor</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> total + (inventor.passed - inventor.year);</span><br><span class="line">&#125;, <span class="hljs-number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(totalYears);</span><br></pre></td></tr></table></figure></p><h3 id="五-排序活最久到活最少的發明家"><a href="#五-排序活最久到活最少的發明家" class="headerlink" title="五. 排序活最久到活最少的發明家"></a>五. 排序活最久到活最少的發明家</h3><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> oldest = inventors.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">const</span> lastGuy = a.passed - a.year;</span><br><span class="line">  <span class="hljs-keyword">const</span> nextGuy = b.passed - b.year;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> lastGuy &gt; nextGuy ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.table(oldest);</span><br></pre></td></tr></table></figure></p><h3 id="六-建立一個名字裡有包含’de’的清單"><a href="#六-建立一個名字裡有包含’de’的清單" class="headerlink" title="六. 建立一個名字裡有包含’de’的清單"></a>六. 建立一個名字裡有包含’de’的清單</h3><p><a href="https://en.wikipedia.org/wiki/Category:Boulevards_in_Paris" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Category:Boulevards_in_Paris</a></p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> category = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.mw-category'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> links = <span class="hljs-built_in">Array</span>.from(category.querySelectorAll(<span class="hljs-string">'a'</span>));</span><br><span class="line"><span class="hljs-comment">// 選取所有a連結，並組成陣列</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> de = links.map(<span class="hljs-function"><span class="hljs-params">link</span> =&gt;</span> link.textContent).filter(<span class="hljs-function"><span class="hljs-params">streetName</span> =&gt;</span> streetName.includes(<span class="hljs-string">'de'</span>));</span><br></pre></td></tr></table></figure></p><h3 id="七-按字母排序名字"><a href="#七-按字母排序名字" class="headerlink" title="七. 按字母排序名字"></a>七. 按字母排序名字</h3><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> alpha = people.sort(<span class="hljs-function">(<span class="hljs-params">lastOne, nextOne</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="hljs-keyword">const</span> [aLast, aFirst] = lastOne.split(<span class="hljs-string">', '</span>);</span><br><span class="line">  <span class="hljs-keyword">const</span> [bLast, bFirst] = nextOne.split(<span class="hljs-string">', '</span>);</span><br><span class="line">  <span class="hljs-keyword">return</span> aLast &gt; bLast ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(alpha);</span><br></pre></td></tr></table></figure></p><p><code>people</code>字串陣列以<code>Beck, Glenn</code>結構所組成的，使用<code>split</code>方法分割姓名，<br>拆解為<code>[aLast, aFirst] = [Beck, Glenn]</code>的模式，使用<code>sort</code>排序後，再傳回<code>alpha</code>。</p><p><code>stringObj.split([separator[, limit]])</code></p><ul><li>回傳為字串分割成的字串陣列。</li><li><code>stringObj</code> 必要項。要分割的 String 物件或字串常值。 <code>split</code> 方法不會修改這個物件。</li><li><code>separator</code> 選擇項。字串或規則運算式物件，可識別用來分隔字串的一個或多個字元。如果省略，則會傳回包含整個字串的單一元素陣列。</li><li><code>limit</code> 選擇項。用來限制陣列中所傳回元素個數的值。</li></ul><h3 id="八-總結各項例子"><a href="#八-總結各項例子" class="headerlink" title="八. 總結各項例子"></a>八. 總結各項例子</h3><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> data = [</span><br><span class="line">  <span class="hljs-string">'car'</span>,</span><br><span class="line">  <span class="hljs-string">'car'</span>,</span><br><span class="line">  <span class="hljs-string">'truck'</span>,</span><br><span class="line">  <span class="hljs-string">'truck'</span>,</span><br><span class="line">  <span class="hljs-string">'bike'</span>,</span><br><span class="line">  <span class="hljs-string">'walk'</span>,</span><br><span class="line">  <span class="hljs-string">'car'</span>,</span><br><span class="line">  <span class="hljs-string">'van'</span>,</span><br><span class="line">  <span class="hljs-string">'bike'</span>,</span><br><span class="line">  <span class="hljs-string">'walk'</span>,</span><br><span class="line">  <span class="hljs-string">'car'</span>,</span><br><span class="line">  <span class="hljs-string">'van'</span>,</span><br><span class="line">  <span class="hljs-string">'car'</span>,</span><br><span class="line">  <span class="hljs-string">'truck'</span>,</span><br><span class="line">  <span class="hljs-string">'pogostick'</span>,</span><br><span class="line">];</span><br><span class="line">&#123;</span><br><span class="line">  car: <span class="hljs-number">1</span>;</span><br><span class="line">  truck: <span class="hljs-number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> transportation = data.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj, item</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (!obj[item]) &#123;</span><br><span class="line">    obj[item] = <span class="hljs-number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  obj[item]++;</span><br><span class="line">  <span class="hljs-keyword">return</span> obj;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(transportation);</span><br></pre></td></tr></table></figure></p><p>初始先予給一個空物件，假設物件沒有<code>item</code>的屬性，則新增一個<code>item</code>屬性，數值為 0，<br>若有相同的 item 屬性，則做累加，結束後回傳物件。</p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS30系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30】Day03：JS Playing with CSS Variables</title>
      <link href="/javascript-30-day03/"/>
      <url>/javascript-30-day03/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://javascript30.com/" target="_blank" rel="noopener">javascript 30day</a></p></blockquote><a id="more"></a><h3 id="目標：讓使用者可調整邊距顏色、寬度，及模糊度"><a href="#目標：讓使用者可調整邊距顏色、寬度，及模糊度" class="headerlink" title="目標：讓使用者可調整邊距顏色、寬度，及模糊度"></a><span id="目標讓使用者可調整邊距顏色-寬度及模糊度"><span style="color:#ff5900">目標：讓使用者可調整邊距顏色、寬度，及模糊度</span></span></h3><h2 id="JS-Playing-with-CSS-Variables-and-JS-Day03"><a href="#JS-Playing-with-CSS-Variables-and-JS-Day03" class="headerlink" title="JS Playing with CSS Variables and JS Day03"></a><span id="js-playing-with-css-variables-and-js-day03">JS Playing with CSS Variables and JS Day03</span></h2><h2 id="一、將欲改變的屬性命名-css-變數"><a href="#一、將欲改變的屬性命名-css-變數" class="headerlink" title="一、將欲改變的屬性命名 css 變數"></a><span id="一-將欲改變的屬性命名-css-變數">一、將欲改變的屬性命名 css 變數</span></h2><p><figure class="highlight hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-selector-pseudo">:root</span> &#123;</span><br><span class="line">  –base: #ffc600;</span><br><span class="line">  –<span class="hljs-selector-tag">spacing</span>: 50<span class="hljs-selector-tag">px</span>;</span><br><span class="line">  –<span class="hljs-selector-tag">blur</span>: 10<span class="hljs-selector-tag">px</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 變數命名</span><br><span class="line"></span><br><span class="line"><span class="hljs-selector-tag">img</span> &#123;</span><br><span class="line">  <span class="hljs-attribute">padding</span>: <span class="hljs-built_in">var</span>(–spacing);</span><br><span class="line">  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">var</span>(–base);</span><br><span class="line">  <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">blur</span>(var(–blur));</span><br><span class="line">&#125;</span><br><span class="line">// 呼叫變數</span><br></pre></td></tr></table></figure></p><h2 id="二、監聽-input"><a href="#二、監聽-input" class="headerlink" title="二、監聽 input"></a>二、監聽 input</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> inputs = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'.controls input'</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleUpdate</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">const</span> suffix = <span class="hljs-keyword">this</span>.dataset.sizing || <span class="hljs-string">''</span>;</span><br><span class="line">  <span class="hljs-built_in">document</span>.documentElement.style.setProperty(<span class="hljs-string">`--<span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>.name&#125;</span>`</span>, <span class="hljs-keyword">this</span>.value + suffix);</span><br><span class="line">  <span class="hljs-comment">// 使用 document.documentElement.style.setProperty('變數名稱', '數值');</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inputs.forEach(<span class="hljs-function"><span class="hljs-params">input</span> =&gt;</span> input.addEventListener(<span class="hljs-string">'change'</span>, handleUpdate));</span><br><span class="line">inputs.forEach(<span class="hljs-function"><span class="hljs-params">input</span> =&gt;</span> input.addEventListener(<span class="hljs-string">'mousemove'</span>, handleUpdate));</span><br></pre></td></tr></table></figure></p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ul><li>css variables</li><li>data-attribute</li><li>forEach</li></ul>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS30系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【筆記】 如何寫出好註解</title>
      <link href="/how-to-write-annotation/"/>
      <url>/how-to-write-annotation/</url>
      
        <content type="html"><![CDATA[<p>註解的目的是協助使用者了解程式碼作者的思想</p><a id="more"></a><h2 id="了解不該註解的部份"><a href="#了解不該註解的部份" class="headerlink" title="了解不該註解的部份"></a>了解不該註解的部份</h2><p>註解必須有價值</p><p>如何區分？</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> cafeBean;</span><br><span class="line"><span class="hljs-comment">//宣告 咖啡豆變數</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> cafeBean;</span><br><span class="line"><span class="hljs-comment">//回傳 咖啡豆</span></span><br></pre></td></tr></table></figure></p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cafeFuc</span> (<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">var</span> cafe = <span class="hljs-number">3</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;cafe.length;i++)&#123;</span><br><span class="line">        <span class="hljs-keyword">var</span> cafeNum += cafe[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>這些註解並沒有提供額外的資訊，讓使用者更易閱讀程式碼，宣告與註解完全相同，應該刪除註解或改善內容。</p><h3 id="不要註解不好的名稱，應修正名稱。"><a href="#不要註解不好的名稱，應修正名稱。" class="headerlink" title="不要註解不好的名稱，應修正名稱。"></a>不要註解不好的名稱，應修正名稱。</h3><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],</span><br><span class="line">  deleteArr = [];</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (arr[i] &gt; <span class="hljs-number">2</span>) &#123;</span><br><span class="line">    deleteArr.push(arr[i]);</span><br><span class="line">    <span class="hljs-comment">// 刪除arr1,2的結果</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(deleteArr);</span><br></pre></td></tr></table></figure></p><p>deleteArr 看起來像刪除 arr 裡的數值，但 arr 的內容並不會被更動，此時應該更正命名如下。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],</span><br><span class="line">  rebuildArr = [];</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (arr[i] &gt; <span class="hljs-number">2</span>) &#123;</span><br><span class="line">    rebuildArr.push(arr[i]);</span><br><span class="line">    <span class="hljs-comment">// 刪除arr1,2 重組後的結果</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(rebuildArr);</span><br></pre></td></tr></table></figure></p><p>利用註解補救程式碼不佳的可讀性</p><h2 id="紀錄自己的想法"><a href="#紀錄自己的想法" class="headerlink" title="紀錄自己的想法"></a>紀錄自己的想法</h2><p>記下寫程式時的重要想法</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">//後端回傳的json相當雜亂，但因重組資料耗費的時間成本太高，先將就使用。</span></span><br></pre></td></tr></table></figure></p><p>讓讀者知道來龍去脈，省去時間做沒有效果的最佳化</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">//公車離站及末班車駛離的即時資料數值回傳皆為11，alert一律顯示'無公車進站'</span></span><br></pre></td></tr></table></figure></p><p>少這段註解，避免讀者浪費時間測試或直接下手修正程式碼。</p><h3 id="註解程式碼缺陷"><a href="#註解程式碼缺陷" class="headerlink" title="註解程式碼缺陷"></a>註解程式碼缺陷</h3><p>以下是許多程式設計師採用的標記</p><table><thead><tr><th>標記</th><th>意義</th></tr></thead><tbody><tr><td>TODO:</td><td>作者還沒處理的部份</td></tr><tr><td>FIXME:</td><td>已知的問題</td></tr><tr><td>HACK:</td><td>承認解決方法不夠優雅</td></tr><tr><td>xxx:</td><td>危險！重要問題</td></tr></tbody></table><p>每個團隊對於標計有各自的規範及使用時機，<br>例如 TODO 被保留受到注意的問題，<br>那麼大多數的小問題可以使用 todo:(小寫)。</p><h3 id="常數的註解"><a href="#常數的註解" class="headerlink" title="常數的註解"></a>常數的註解</h3><p>常數只是單純的數值，但加上註解仍有幫助。</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> cafeBeanMaxmum = <span class="hljs-number">200</span>;</span><br><span class="line"><span class="hljs-comment">//加上合理的上限——咖啡豆進貨上限</span></span><br></pre></td></tr></table></figure></p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> zoom = <span class="hljs-number">12</span>;</span><br><span class="line"><span class="hljs-comment">//zoom12為檢視googleMap的最佳比例</span></span><br></pre></td></tr></table></figure></p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">makeAcafe(inputValue);</span><br><span class="line"><span class="hljs-comment">//執行製作一杯咖啡的時間，特別注意太糟的輸入值</span></span><br></pre></td></tr></table></figure></p><h3 id="全局註解"><a href="#全局註解" class="headerlink" title="全局註解"></a>全局註解</h3><p>詳述檔案</p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 這隻sass主要為儲存變數、RWD斷點規劃</span></span><br><span class="line"></span><br><span class="line">..</span><br></pre></td></tr></table></figure></p><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">switch</span> (status) &#123;</span><br><span class="line">  <span class="hljs-keyword">case</span> <span class="hljs-string">'go'</span>:</span><br><span class="line">    <span class="hljs-comment">// 去程顯示畫面</span></span><br><span class="line">    $(<span class="hljs-string">'.choose'</span>).hide();</span><br><span class="line">    $(<span class="hljs-string">'.showMap-go'</span>).show();</span><br><span class="line">    $(<span class="hljs-string">'.showMap-back'</span>).hide();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//顯示google Map</span></span><br><span class="line">    <span class="hljs-keyword">var</span> map;</span><br><span class="line">    initMap();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">case</span> <span class="hljs-string">'back'</span>:</span><br><span class="line">    <span class="hljs-comment">// 回程顯示畫面</span></span><br><span class="line">    $(<span class="hljs-string">'.showMap-go'</span>).hide();</span><br><span class="line">    $(<span class="hljs-string">'.showMap-back'</span>).show();</span><br><span class="line">    $(<span class="hljs-string">'.choose'</span>).hide();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">var</span> map;</span><br><span class="line">    initMap();</span><br><span class="line">    <span class="hljs-keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">case</span> <span class="hljs-string">'choose'</span>:</span><br><span class="line">  <span class="hljs-keyword">default</span>:</span><br><span class="line">    <span class="hljs-comment">// 選擇路線顯示畫面</span></span><br><span class="line">    $(<span class="hljs-string">'.choose'</span>).show();</span><br><span class="line">    $(<span class="hljs-string">'.showMap-go'</span>).show();</span><br><span class="line">    $(<span class="hljs-string">'.showMap-back'</span>).hide();</span><br><span class="line">    <span class="hljs-keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>維持註解的簡潔</li><li>避免模擬兩可的代名詞（它、這個、那個）</li><li>修整草率的語句</li></ul>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 攻城屍筆記 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30】Day01：JavaScript Drum Kit</title>
      <link href="/javascript-30-day01/"/>
      <url>/javascript-30-day01/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://javascript30.com/" target="_blank" rel="noopener">javascript 30day</a></p></blockquote><a id="more"></a><h3 id="目標：按鍵盤按鍵，使畫面有動態效果及聲音。"><a href="#目標：按鍵盤按鍵，使畫面有動態效果及聲音。" class="headerlink" title="目標：按鍵盤按鍵，使畫面有動態效果及聲音。"></a><span style="color:#ff5900">目標：按鍵盤按鍵，使畫面有動態效果及聲音。</span></h3><h2 id="一、按下鍵盤事件"><a href="#一、按下鍵盤事件" class="headerlink" title="一、按下鍵盤事件"></a>一、按下鍵盤事件</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'keydown'</span>, playSound);</span><br><span class="line"><span class="hljs-comment">//利用 window 監聽 keydown 事件來偵測使用者按下的按鈕。</span></span><br></pre></td></tr></table></figure></p><h2 id="二、連結聲音"><a href="#二、連結聲音" class="headerlink" title="二、連結聲音"></a>二、連結聲音</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">playSound</span>(<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">const</span> audio = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">`audio[data-key="<span class="hljs-subst">$&#123;e.keyCode&#125;</span>"]`</span>);</span><br><span class="line">  <span class="hljs-comment">// 利用 template literals 加入變數，選擇音檔。</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">const</span> key = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">`.key[data-key="<span class="hljs-subst">$&#123;e.keyCode&#125;</span>"]`</span>);</span><br><span class="line">  <span class="hljs-comment">// 選擇按鍵</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (!audio) <span class="hljs-keyword">return</span>;</span><br><span class="line">  audio.currentTime = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-comment">// 每次按鍵重新播放聲音</span></span><br><span class="line"></span><br><span class="line">  key.classList.add(<span class="hljs-string">'playing'</span>);</span><br><span class="line">  <span class="hljs-comment">// 加入 css 效果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="三、事件動畫效果"><a href="#三、事件動畫效果" class="headerlink" title="三、事件動畫效果"></a>三、事件動畫效果</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line">keys.forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> key.addEventListener(<span class="hljs-string">'transitionend'</span>, removeTransition));</span><br><span class="line"><span class="hljs-comment">// function 傳入 forEach 遍輪 key ， 使每個按鍵監聽 transitionend 事件。</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeTransition</span>(<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (e.propertyName !== <span class="hljs-string">'transform'</span>) <span class="hljs-keyword">return</span>;</span><br><span class="line">  <span class="hljs-comment">// 跳過 CSS transform 屬性</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">this</span>.classList.remove(<span class="hljs-string">'playing'</span>);</span><br><span class="line">  <span class="hljs-comment">// 移除 css 效果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ul><li>forEach</li><li>template literals</li><li>arrow function</li><li>transitionend</li></ul>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS30系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JS30】Day02：CSS + JS Clock</title>
      <link href="/javascript-30-day02/"/>
      <url>/javascript-30-day02/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://javascript30.com/" target="_blank" rel="noopener">javascript 30day</a></p></blockquote><a id="more"></a><h3 id="目標：使畫面指針依照電腦時間進行動態效果。"><a href="#目標：使畫面指針依照電腦時間進行動態效果。" class="headerlink" title="目標：使畫面指針依照電腦時間進行動態效果。"></a><span style="color:#ff5900">目標：使畫面指針依照電腦時間進行動態效果。</span></h3><h2 id="一、-調整畫面指針"><a href="#一、-調整畫面指針" class="headerlink" title="一、 調整畫面指針"></a>一、 調整畫面指針</h2><p>設定指針的 CSS 下屬性。</p><p><figure class="highlight hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-selector-tag">transform-origin</span>: 100%;</span><br><span class="line">// 改變位置水平垂直位置</span><br><span class="line"><span class="hljs-selector-tag">transform</span>: <span class="hljs-selector-tag">rotate</span>(90<span class="hljs-selector-tag">deg</span>);</span><br><span class="line">// 改變角度，使指針以 12 點鐘方向為起始</span><br><span class="line"><span class="hljs-selector-tag">transition-timing-function</span>: <span class="hljs-selector-tag">cubic-bezier</span>(0<span class="hljs-selector-class">.1</span>, 2<span class="hljs-selector-class">.7</span>, 0<span class="hljs-selector-class">.25</span>, 1);</span><br><span class="line">// 利用貝茲曲線製造出指針動態的彈出效果</span><br></pre></td></tr></table></figure></p><h2 id="二、取得當下時間"><a href="#二、取得當下時間" class="headerlink" title="二、取得當下時間"></a>二、取得當下時間</h2><p><figure class="highlight js hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setDate</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">const</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">const</span> seconds = now.getSeconds();</span><br><span class="line">  <span class="hljs-comment">// 取得秒數</span></span><br><span class="line">  <span class="hljs-keyword">const</span> secondsDegree = (seconds / <span class="hljs-number">60</span>) * <span class="hljs-number">360</span> + <span class="hljs-number">90</span>;</span><br><span class="line">  <span class="hljs-comment">// 計算角度</span></span><br><span class="line">  secondsHand.style.transform = <span class="hljs-string">`rotate(<span class="hljs-subst">$&#123;secondsDegree&#125;</span>deg)`</span>;</span><br><span class="line">  <span class="hljs-comment">// 使用style transform 動態改變角度</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">const</span> mins = now.getMinutes();</span><br><span class="line">  <span class="hljs-keyword">const</span> minsDegree = (mins / <span class="hljs-number">60</span>) * <span class="hljs-number">360</span> + <span class="hljs-number">90</span>;</span><br><span class="line">  minsHand.style.transform = <span class="hljs-string">`rotate(<span class="hljs-subst">$&#123;minsDegree&#125;</span>deg)`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">const</span> hour = now.getHours();</span><br><span class="line">  <span class="hljs-keyword">const</span> hourDegree = (mins / <span class="hljs-number">12</span>) * <span class="hljs-number">360</span> + <span class="hljs-number">90</span>;</span><br><span class="line">  hourHand.style.transform = <span class="hljs-string">`rotate(<span class="hljs-subst">$&#123;hourDegree&#125;</span>deg)`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(setDate, <span class="hljs-number">1000</span>);</span><br><span class="line"><span class="hljs-comment">// 每秒執行一次 setDate function</span></span><br></pre></td></tr></table></figure></p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ul><li>newDate</li><li>transform</li><li>el.style.styleAttribute</li></ul>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS30系列 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
